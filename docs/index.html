<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-05-02 Mon 00:53 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Understanding Bill Gospher's continued fraction arithmetic (implemented in Python)</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Hsin-Hao Yu" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-115187658-1"></script>
<script>window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);}gtag('js', new Date());gtag('config','UA-115187658-1');</script>
<script type="text/javascript">
// @license magnet:?xt=urn:btih:e95b018ef3580986a04669f1b5879592219e2a7a&dn=public-domain.txt Public Domain
<!--/*--><![CDATA[/*><!--*/
     function CodeHighlightOn(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.add("code-highlighted");
         target.classList.add("code-highlighted");
       }
     }
     function CodeHighlightOff(elem, id)
     {
       var target = document.getElementById(id);
       if(null != target) {
         elem.classList.remove("code-highlighted");
         target.classList.remove("code-highlighted");
       }
     }
    /*]]>*///-->
// @license-end
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "left",
        displayIndent: "0em",

        "HTML-CSS": { scale: 85,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 85,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 85},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<h1 class="title">Understanding Bill Gospher's continued fraction arithmetic (implemented in Python)</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf53cdd1">1. Introduction</a></li>
<li><a href="#org04fc4fb">2. Representing rational numbers as continued fractions</a></li>
<li><a href="#orgde93a5e">3. Calculating the convergents of a continued fraction</a></li>
<li><a href="#orgef562bd">4. Continued fractions as recursive functions</a></li>
<li><a href="#org12ed5d1">5. Calculating convergents using matrices</a></li>
<li><a href="#org7ebf550">6. Turning convergents into continued fractions using the Euclidean algorithm</a></li>
<li><a href="#org4652b83">7. Simple transformations of continued fractions</a></li>
<li><a href="#orgb0230ef">8. Arithmetic (Step 1): From matrices to tensors</a></li>
<li><a href="#org336d9f9">9. Arithmetic (Step 2):  Representing arithmetic operations</a></li>
<li><a href="#orgd48be3a">10. Arithmetic (Step 3): Calculating convergents using tensors</a></li>
<li><a href="#org3a3bb2b">11. Arithmetic (Step 4): Applying the Euclidean algorithm to convergents</a></li>
<li><a href="#orgb9a439c">12. The final section with complex figures</a></li>
<li><a href="#orgac5232a">13. Appendix: Quotients/remainders for matrices</a></li>
<li><a href="#orge49341a">14. Appendix: Quotients/remainders for tensors</a></li>
<li><a href="#org14e9007">15. Appendix: Unit tests</a>
<ul>
<li><a href="#org6e1477a">15.1. Using continued fractions to represent rational numbers</a></li>
<li><a href="#org5411378">15.2. Convergents</a></li>
<li><a href="#org06e7bef">15.3. Symbolic Euclidean algorithm</a></li>
<li><a href="#org912672f">15.4. Transformations of continued fractions</a></li>
<li><a href="#org2481658">15.5. Bihomography</a></li>
<li><a href="#org6f67870">15.6. Imports</a></li>
</ul>
</li>
<li><a href="#org58b0963">16. Appendix: Display utilities</a>
<ul>
<li><a href="#orgd896234">16.1. Tabulated display utilities</a>
<ul>
<li><a href="#org9bf1827">16.1.1. Take inputs from continued fractions</a></li>
<li><a href="#orgd88c654">16.1.2. Process output</a></li>
<li><a href="#org1f93994">16.1.3. Convert to array</a></li>
<li><a href="#orgd7eb9b2">16.1.4. Display/export</a></li>
</ul>
</li>
<li><a href="#org3fe5b4b">16.2. Tabulated displays: 2D</a></li>
<li><a href="#org38462fa">16.3. Tabulated displays: 3D</a></li>
<li><a href="#org6bfff74">16.4. Pretty printing utilities</a></li>
<li><a href="#org402a420">16.5. LaTeX utilities</a></li>
<li><a href="#orgc9d9df2">16.6. Imports</a></li>
</ul>
</li>
<li><a href="#org056b444">17. Appendix: Imports and outlines</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgf53cdd1" class="outline-2">
<h2 id="orgf53cdd1"><span class="section-number-2">1</span> Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Continued fractions are very often said to be the most natural or elegant way to represent numbers. Imagine a parallel universe, in which continued fractions are used as the dominant number system. People there use continued fractions for everything. So you'd think they calculate with them, too. But can you calculate with continued fractions? Most presentations on this subject don't talk about arithmetic at all. This gives the impression that you can't really do anything with them, except for looking for patterns in the coefficients when they are used to represent irrational numbers.
</p>

<p>
In fact, in 1972, mathematician and computer scientist Bill Gospher developed an ingenious method for doing <i>exact</i> arithmetic on continued fractions. Unfortunately, this method was published as an informal memo, which left out many details. I decided to implement the main idea in Python, and explain the reasoning in my own way. You can find Gospher original memo and additional information <a href="https://perl.plover.com/classes/cftalk/INFO/gosper.html">here</a>. The source code is available <a href="https://github.com/hsinhaoyu/cont_frac">here</a>.
</p>
</div>
</div>

<div id="outline-container-org04fc4fb" class="outline-2">
<h2 id="org04fc4fb"><span class="section-number-2">2</span> Representing rational numbers as continued fractions</h2>
<div class="outline-text-2" id="text-2">
<p>
Since we'll use rational numbers a lot, let's define a class:
</p>
<div class="org-src-container">
<pre class="src src-python">class Rational(NamedTuple('Rational', [('a', int), ('b', int)])):
    """Rational(a, b) = a/b"""
    def __repr__(self):
	return f'{self.a}/{self.b}'
</pre>
</div>

<p>
How to convert a rational number to a continued fraction? Observing that
</p>

<p>
\[
\frac{254}{100}
= 2 + \frac{54}{100}
= 2 + \frac{1}{\frac{100}{54}}
= 2 + \frac{1}{1 + \frac{46}{54}}
= 2 + \frac{1}{1 + \frac{1}{\frac{46}{54}}}
\]
</p>

<p>
it should be obvious that the solution is just the <a href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Euclidean algorithm</a> for finding the greatest common divider: we first decompose the numerator \(a\) as \(a=b*q+r\), where \(b\) is the denominator, \(q\) is an integer called the <i>quotient</i>, and \(r\) is the remainder. We output \(q\), and repeat the process, using \(b\) as the numerator and \(r\) as the denominator. We stop when the numerator becomes 0. 
</p>
<div class="org-src-container">
<pre class="src src-python"># Convert a rational number to a continued fraction

def qr(a: int, b: int) -&gt; Tuple[int, int]:
    """
    Find the quotient and remainder of a rational number.

    a = b * q + r, return (q, r).
    :param a: The numerator of the rational number
    :param b: The denominator of the rational number
    :return: (quotient, remainder)
    """
    q = math.floor(a / b)  # the quotient
    r = a - b * q          # the remainder
    return (q, r)

def r2cf_(rn: Rational) -&gt; Iterator[Tuple[int, int]]:
    """
    Turn a rational number into a continued fraction.

    The Euclidean algoirthm.
    :param rn: The rational number
    :return: An iterator of the old denominator and the quotient
    """
    a, b = rn
    while True:
	q, r = qr(a, b)
	yield b, q
	if r == 0:
	    break
	a, b = b, r

def r2cf(rn: Rational) -&gt; Iterator[int]:
    """
    Turn a rational number to a continued fraction.

    :param rn: The rational number
    :return: An iterator of integers
    """
    def second(x: tuple):
	return x[1]
    return map(second, r2cf_(rn))
</pre>
</div>

<p>
Now we can use <code>r2cf</code> to convert a rational number into a continued fraction. In this article, I use Python generators to represent continued fractions, because they can have infinite number of terms. However, in the specific case of <code>r2cf</code>, the generators returned always have finite numbers of terms, because the continued fractions associated with rational numbers always have finite numbers of terms. This is one of the fundamental properties of rational numbers.
</p>
<div class="org-src-container">
<pre class="src src-python">
nc = r2cf(Rational(254, 100))
print(list(nc))
</pre>
</div>

<pre class="example">
[2, 1, 1, 5, 1, 3]
</pre>


<p>
This means that
\[
\frac{ 254 }{ 100 }=
2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}
\]
</p>

<p>
We can display the process in a tabular format. For example:
</p>
<div class="org-src-container">
<pre class="src src-python">
print(r2cf_tab(Rational(254, 100)))
</pre>
</div>

<pre class="example">
254
100   2   
 54   1   
 46   1   
  8   5   
  6   1   
  2   3   
  0

</pre>


<p>
On the top, we begin with the rational number \(\frac{254}{100}\). The quotient 2, displayed on the side, is the first term of the continued fraction. The rational number now becomes \(\frac{100}{54}\), and we continue the process until we reach 0. As a side note, the penultimate numerator 2 is the greatest common divider for 254 and 100, according to the Euclidean algorithm.
</p>

<p>
Interestingly, the reciprocal of \(\frac{254}{100}\) (that is, \(\frac{100}{254}\)) is represented by the following as a continued fraction:
</p>
<div class="org-src-container">
<pre class="src src-python">
nc = r2cf(Rational(100, 254))
print(list(nc))
</pre>
</div>

<pre class="example">
[0, 2, 1, 1, 5, 1, 3]
</pre>


<p>
It's the same sequence with an additional 0 at the beginning! This is our first clue that a continued fraction can be transformed by performing some operations at the beginning of the Euclidean algorithm. We'll come back to this point later.
</p>
</div>
</div>

<div id="outline-container-orgde93a5e" class="outline-2">
<h2 id="orgde93a5e"><span class="section-number-2">3</span> Calculating the convergents of a continued fraction</h2>
<div class="outline-text-2" id="text-3">
<p>
Given a continued fraction, how do we calculate its value? If the series is finite, we can easily write a recursive function. However, if it's an infinite series, we need a method to incrementally approximate the value as more terms are received. Also, we want the evaluation to be accumulative, so that each update is based on the previous one.
</p>

<p>
This question has an easy solution if we use a series of rational numbers to approximate the continued fraction. Each term in the series is called a <i>convergent</i>. The formula for the convergents can be derived easily with mathematical induction, and it is implemented below. For the moment, we'll use the formula just a convenience to get the job done. We'll get deeper into its meaning in the next section.
</p>
<div class="org-src-container">
<pre class="src src-python"># Calculate the convergents of a continued fraction

def cf_convergents0(cf: Iterator[int]) -&gt; Iterator[Rational]:
    """
    Calculate the convergents of a continued fraction.

    :param cf: A continued fraction
    :return: An iterator of rational numbers
    """
    p1, p0 = 1, 0
    q1, q0 = 0, 1

    for a in cf:
	p = a * p1 + p0
	q = a * q1 + q0
	yield Rational(p, q)

	p0, p1 = p1, p
	q0, q1 = q1, q
</pre>
</div>

<p>
<a id="org4cdfa94"></a>For example, for the continued fraction \([2, 1, 1, 5, 1, 3]\), we get
</p>
<div class="org-src-container">
<pre class="src src-python">
print(list(cf_convergents0(iter([2, 1, 1, 5, 1, 3]))))
</pre>
</div>

<pre class="example">
[2/1, 3/1, 5/2, 28/11, 33/13, 127/50]
</pre>


<p>
In other words, 
\(2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}\)
can be approximated with
\(\frac{2}{1}\),\(\frac{3}{1}\),\(\frac{5}{2}\),\(\frac{28}{11}\),\(\frac{33}{13}\),\(\frac{127}{50}\)
.
</p>

<p>
For convenience, we define a specialized version of <code>cf_convergents0</code> just for finite-term continued fractions. It returns the rational number corresponding to the continued fraction:
</p>
<div class="org-src-container">
<pre class="src src-python">def cf2r0(cf: Iterator[int]) -&gt; Rational:
    """
    The value of a finite-length continued fraction as a rational number.

    This function will get into an infinite loop if the iterator doesn't stop.
    """
    return list(cf_convergents0(cf))[-1]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">
print(cf2r0(iter([2, 1, 1, 5, 1, 3])))
</pre>
</div>

<pre class="example">
127/50
</pre>


<p>
Another example: the irrational number \(e\) can be expressed as a continued fraction by this code:
</p>
<div class="org-src-container">
<pre class="src src-python"># Examples of continued fractions

def cf_e() -&gt; Iterator[int]:
    '''e as a continued fraction'''
    yield 2
    k = 0
    while True:
	# a finite generator comprehension
	for i in (j for j in [1, 2 * k + 2, 1]):
	    yield i
	k = k + 1
</pre>
</div>

<p>
It has infinite number of terms, but the series follows a simple pattern. This is just the first 16 terms:
</p>
<div class="org-src-container">
<pre class="src src-python">
print(list(islice(cf_e(), 16)))
</pre>
</div>

<pre class="example">
[2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, 1, 1, 10, 1]
</pre>


<p>
Here are the convergents, as rational and as floating point numbers:
</p>
<div class="org-src-container">
<pre class="src src-python">
conv_ = cf_convergents0(cf_e())
conv = list(islice(conv_, 16)) # the first 16 convergents
for c in conv:
    print(f'{repr(c):&lt;20} {c[0]/c[1]:.8f}')
</pre>
</div>

<pre class="example" id="org6c8a8e2">
2/1                  2.00000000
3/1                  3.00000000
8/3                  2.66666667
11/4                 2.75000000
19/7                 2.71428571
87/32                2.71875000
106/39               2.71794872
193/71               2.71830986
1264/465             2.71827957
1457/536             2.71828358
2721/1001            2.71828172
23225/8544           2.71828184
25946/9545           2.71828182
49171/18089          2.71828183
517656/190435        2.71828183
566827/208524        2.71828183
</pre>
</div>
</div>

<div id="outline-container-orgef562bd" class="outline-2">
<h2 id="orgef562bd"><span class="section-number-2">4</span> Continued fractions as recursive functions</h2>
<div class="outline-text-2" id="text-4">
<p>
<a id="org5f7c167"></a>
Given the first 3 terms in a continued fraction \([5, 1, 4...]\), let \(x\) denote the reciprocal of the value of the remaining series. We can express the convergent as \(f_1(x)\), \(f_2(x)\), \(f_3(x)\)&#x2026;, where
</p>

\begin{equation*}
    f_1(x) = 5 + \frac{1}{x}
\end{equation*}

\begin{equation*}
    f_2(x) = 5 + \frac{1}{1 + \frac{1}{x}} = f_1(1 + \frac{1}{x})
\end{equation*}

\begin{equation*}
    f_3(x) = 5 + \frac{1}{1 + \frac{1}{4 + \frac{1}{x}}} = f_1(f_2(4 + \frac{1}{x}))
\end{equation*}

<p>
Or more compactly, let
</p>
\begin{equation*}
    h(a, x) = a + \frac{1}{x}
\end{equation*}

<p>
then
</p>
\begin{equation*}
    f_1(x) = h(5, x)
\end{equation*}

\begin{equation*}
    f_2(x) = h(5, h(1, x))
\end{equation*}

\begin{equation*}
    f_3(x) = h(5, h(1, h(4, x))) 
\end{equation*}

<p>
This way, we express the approximation as a recursive process. If the continued fraction stops at the third term, its value is \(h_3(\infty) = h(5, h(1, h(4, \infty)))\). Infinity might seem odd here, but remember that \(x\) is the reciprocal of the rest of the sequence. So it just means that the rest of the sequence evaluates to 0.
</p>

<p>
Before we rush to translate this into code, let's dig deeper. If we use column vectors to represent rational numbers:
</p>

\begin{equation*}
    \begin{bmatrix}
           p \\
           q
    \end{bmatrix} = \frac{p}{q}
\end{equation*}

<p>
Then we can turn everything into linear algebra:
</p>

\begin{equation*}
    h(a, x) = a + \frac{1}{x} = \frac{ax + 1}{x}
\end{equation*}

<p>
can be written in our matrix notation as
</p>

\begin{equation*}

    \begin{bmatrix}
        ax + 1 \\
        x
    \end{bmatrix}

    =

    \begin{bmatrix}
        a & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix}
\end{equation*}

<p>
Furthermore, 
</p>

\begin{equation*}
    f_3(x) = h(5, h(1, h(4, x)))
\end{equation*}

<p>
can be written as
</p>

\begin{equation*}

    \begin{bmatrix}
        5 & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        1 & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        4 & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix}

    = 

    \begin{bmatrix}
        29 & 6 \\
        5 & 1
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix}

\end{equation*}

<p>
So, the 2-by-2 matrix
</p>

<p>
\(\begin{bmatrix}
    29 & 6 \\
     5 & 1
\end{bmatrix}\)
</p>

<p>
represents a function that approximates a continued fraction with more terms. If the continued fractions has only 3 terms, we terminate the process by evaluating
</p>

\begin{equation*}

    \begin{bmatrix}
        29 & 6 \\
         5 & 1
    \end{bmatrix}

    \begin{bmatrix}
        1 \\
        0 
    \end{bmatrix}

    = 

    \begin{bmatrix}
        29 \\
         5
    \end{bmatrix}

    = \frac{29}{5}
\end{equation*}

<p>
Multiplying the matrix with
\(\begin{bmatrix}
    1 \\
    0 
\end{bmatrix}\) turns the function into a rational value, which is the first column of the matrix.
</p>
</div>
</div>

<div id="outline-container-org12ed5d1" class="outline-2">
<h2 id="org12ed5d1"><span class="section-number-2">5</span> Calculating convergents using matrices</h2>
<div class="outline-text-2" id="text-5">
<p>
Now, we are ready to rewrite the formula in <code>cf_convergents0</code> as matrix multiplications:
</p>
<div class="org-src-container">
<pre class="src src-python"># Calculate the convergents using matrix multiplication

def h(a: int) -&gt; np.ndarray:
    '''Homographic matrix for one term of continued fraction'''
    return np.array([[a, 1], [1,0]])

def cf_convergents1_(cf: Iterator[int]) -&gt; Iterator[np.ndarray]:
    """
    The convergents (as matrices) of a continued fraction.

    :param cf: The continued fraction
    :return: An iterator of 2x2 matrices representing the convergents
    """
    res = np.array([[1, 0], [0, 1]])
    for a in cf:
	res = np.matmul(res, h(a))
	yield res

def cf_convergents1(cf: Iterator[int]) -&gt; Iterator[Rational]:
    """
    The convergents (as rational numbers ) of a continued fraction

    :param cf: The continued fraction
    :return: An iterator of rational numbers
    """
    mLst = cf_convergents1_(cf)
    for m in mLst:
	yield Rational(m[0, 0], m[1, 0])
</pre>
</div>

<p>
<a id="orgc3289ce"></a>Let's try it on an example that we used <a href="#org4cdfa94">previously</a>:
</p>
<div class="org-src-container">
<pre class="src src-python">
print(list(cf_convergents1(iter([2, 1, 1, 5, 1, 3]))))
</pre>
</div>

<pre class="example">
[2/1, 3/1, 5/2, 28/11, 33/13, 127/50]
</pre>


<p>
A very charming thing that Gosper did was that he used a compact tabulated format to illustrate the process. It's unnecessary for the computation, but I think it looks pretty cool:
</p>
<div class="org-src-container">
<pre class="src src-python">
print(cf_convergents1_tab(iter([5, 1, 4])))
</pre>
</div>

<pre class="example">
    4  1  5   
29  6  5  1  0
 5  1  1  0  1

</pre>


<p>
This table is read from the right to the left. The right-to-left direction takes some getting used to, but it's needed to preserve the normal representation of matrices. The first row represents the terms of the continued fraction. What are the numbers below the first row? They are the matrices representing the convergents associated with \([5, 1, 4]\). To see why, we calculate the matrices for each additional term in the continued fraction:
</p>
<div class="org-src-container">
<pre class="src src-python">
itr = cf_convergents1_(iter([5, 1, 4]))
print(next(itr),"\n")
print(next(itr),"\n")
print(next(itr))
</pre>
</div>

<pre class="example">
[[5 1]
 [1 0]] 

[[6 5]
 [1 1]] 

[[29  6]
 [ 5  1]]
</pre>


<p>
You can see these matrices shift leftwards in the tabular representation, with adjacent matrices sharing a column. Suppose that the current matrix is
\(\begin{bmatrix}
    p & q \\
    r & s
\end{bmatrix}\), and we have to update it with a new term \(a_n\) in the continued fraction. The updated matrix is
</p>
\begin{equation*}
    \begin{bmatrix}
        p & q \\
        r & s
    \end{bmatrix}
    \begin{bmatrix}
        a_n & 1 \\
        1 & 0
    \end{bmatrix} =
    \begin{bmatrix}
        a_n p + q & p \\
        a_n r + s & r
    \end{bmatrix}
\end{equation*}

<p>
This explains the shift, and we have recovered the formula in <code>cf_convergents0</code>.
</p>

<p>
Finally, we define a specialized version of <code>cf_convergents1</code> just for finite-term continued fractions. 
</p>
<div class="org-src-container">
<pre class="src src-python">def cf2r1(cf: Iterator[int]) -&gt; Rational:
    """
    Turn a continued fraction into a rational number.

    The continued fraction must have finite length.
    If not, this function will get into an infinite loop.

    :param cf: The continued fraction
    :return: A rational number
    """
    return list(cf_convergents1(cf))[-1]
</pre>
</div>
</div>
</div>

<div id="outline-container-org7ebf550" class="outline-2">
<h2 id="org7ebf550"><span class="section-number-2">6</span> Turning convergents into continued fractions using the Euclidean algorithm</h2>
<div class="outline-text-2" id="text-6">
<p>
In this section, we'll calculate convergents as in <code>cf_convergent1</code>, but as it happens, we'll also turn them into continued fractions. This seems to be a pointless exercise, because a continued fraction is what we start with! Indeed, at the end of this section, we'll see that our code receives a continued fraction, and just returns the same series. However, in the next section, it will be used to do interesting things.
</p>

<p>
Let's take the continued fraction \([5, 1, 4... ]\) as an example. Since we already know from the <a href="#orgc3289ce">last section</a> that the third convergent of \([5, 1, 4]\) is \(\frac{29}{5}\), can't we just turn \(\frac{29}{5}\) into a continued fraction, using the <code>r2cf</code> function that we have already written? It is not as simple as that, because \([5, 1, 4]\) and \([5, 1, 4...]\) are not the same. For the former, the third convergent is just a rational number. However, for the latter, the third convergent 
\(\begin{bmatrix}
    29 & 6 \\
     5 & 1
\end{bmatrix}\) represents the function \(\frac{29x + 6}{5x + 1}\). To turn it into a continued fraction, we'll need to take the rest of the series, represented by \(x\), into account.
</p>

<p>
How? The answer is still the Euclidean algorithm, but we have to use it symbolically rather than numerically.
</p>

<p>
The first step is to symbolically represent the function as a quotient and a remainder. I implemented this operation in <code>qr_matrix</code> in the <a href="#org9cc3d37">Appendix</a>. We can use it on the third convergent:
</p>
<div class="org-src-container">
<pre class="src src-python">
pp_qr(qr_matrix(np.array([[29, 6], [5, 1]])))
</pre>
</div>

<pre class="example">
5  5  1
   4  1
</pre>


<p>
This means that \(f_3(x) = \frac{29x+6}{5x+1} = 5 + \frac{1}{\frac{5x+1}{4x+1}}\). Why is the quotient 5? Since \(\lim_{x \to 0} f_3(x) = 6\) and \(\lim_{x \to \infty} f_3(x) = \frac{29}{5} = 5.8\), the function is bounded by \(5.8 < f_3(x) < 6\) (note that \(0 < x < \infty\)). The quotient therefore has to be 5.
</p>


<div id="org42c9b79" class="figure">
<p><img src="figs/fig1.png" alt="fig1.png" width="400" />
</p>
</div>

<p>
Now, we are ready to implement the symbolic form of the Euclidean algorithm by calling <code>qr_matrix</code> repeatedly:
</p>
<div class="org-src-container">
<pre class="src src-python">def euclid_matrix_(m: np.ndarray) -&gt; Iterator[Tuple[int, np.ndarray]]:
    """
    Symbolic Euclidean algorithm for a homographic function.

    :param m: The 2x2 matrix representing the function.
    :return: An iterator of the quotient and the remainder.
    """
    while True:
	if m[0][0] == 0 and [0][1] == 0:
	    # if there is no remain, stop
	    break
	else:
	    (q, r) = qr_matrix(m)
	    if q is not None:
		yield q, r
		m = r
	    else:
		# if the quotient cannot be determined, stop
		break
</pre>
</div>

<p>
Let's try it on
\(\begin{bmatrix}
    70 & 29 \\
    12 & 5
\end{bmatrix}\)
</p>

<div class="org-src-container">
<pre class="src src-python">
q = euclid_matrix_(np.array([[70, 29], [12, 5]]))
for (r, m) in q:
    pp_qr((r, m))
    print()
</pre>
</div>

<pre class="example">
5 12  5
  10  4

1 10  4
   2  1

4  2  1
   2  0

</pre>


<p>
So there is enough information in \(\frac{70x+29}{12x+5}\) to precisely determine 3 terms (5, 1, 4). The last matrix represents \(\frac{2x+1}{2x}\), an unbounded function. This means that depending on the next term of the input, the function can evaluate to any value. We don't have enough information to determine the quotient, so we have to stop.
</p>

<p>
<a id="orgf9227c3"></a>
As before, Gospher stacked the matrices in a compact format to illustrate the process:
</p>
<div class="org-src-container">
<pre class="src src-python">
print(euclid_matrix_tab(np.array([[70, 29], [12, 5]])))
</pre>
</div>

<pre class="example">

70 29   
12  5  5
10  4  1
 2  1  4
 2  0   

</pre>


<p>
This is a just an extension of the format that we use to visualize <code>r2cf</code>: we start with \(\begin{bmatrix} 70 & 29 \\ 12 & 5\end{bmatrix}\), end with \(\begin{bmatrix}2 & 1 \\ 2 & 0\end{bmatrix}\), and output 5, 1, 4 in the process. 
</p>

<p>
Now, we can combine convergent calculation with the symbolic Euclidean algorithm. The first function below <code>cf_transform_</code> returns the desired information (the quotient) along with internal states of the algorithm. It's useful for debugging and visualization. We use a second function <code>cf_transform</code> to filter out the internal states:
</p>
<div class="org-src-container">
<pre class="src src-python">def cf_transform_(cf: Iterator[int], m0: np.ndarray = np.identity(2, int), finite_term = True) -&gt; Iterator[Tuple[Optional[int], Optional[np.ndarray], np.ndarray, int, bool]]:
    """
    Transform a continued fraction.

    Exposes the internal states of the algorithm for visualization.
    A step can do: 1. Update the homographic matrix
		   2. Update, and an Euclidean step
		   3. Only an Euclidean step

    :param cf: The continued fraction.
    :param m0: The initial 2x2 matrix representing the transformatiom.
    :param finite-term: True, if cf is a continued fraction with finite terms.
			False, if cf represents a truncated continued fraction.
    :return: q: The quotient. None if the Euclidean step cannot be performed.
	     r: The remainder. None if the Euclidean step cannot be performed.
	     m: The 2x2 matrix before the Euclidean step
	     a: The term of the continued fraction that was used in this update
	     new_a: Was a new a term used?
		    False if this step only did Euclidean
    """
    m = m0
    for a in cf:
	m = np.matmul(m, h(a))
	new_a = True
	for (q, r) in euclid_matrix_(m):
	    yield q, r, m, a, new_a
	    new_a = False
	    m = r
	if new_a:
	    # Nothing was yielded.
	    # This convergent cannot be turned into a continued fraction
	    yield (None, None, m, a, new_a)

    # We will only reach this point if the series is finite
    if finite_term and m[1][0] != 0:
	for s in r2cf(Rational(m[0][0], m[1][0])):
	    yield s, None, m, a, False

def cf_transform(cf: Iterator[int], m0: np.ndarray = np.identity(2, int), finite_term = True) -&gt; Iterator[int]:
    """
    Transform the input continued fraction into a new continued fraction.

    :param cf: The continued fraction.
    :param m0: The 2x2 matrix representing the transformation.
    :param finite_term: Is cf a finite-term fraction?
			Set to false if cf is a finite truncation of
			an infinite continued fractuon
    :return: A new continued fraction
    """
    for res in cf_transform_(cf, m0, finite_term):
	(q, r, m, a, new_a) = res
	if q is not None:
	    yield q
	else:
	    # q can be None, indicating that more terms are needed
	    # to continue. It can be ignored
	    pass
</pre>
</div>

<p>
Run it on a continued fraction, and it just returns the same sequence. It doesn't seem to do any transformation. We'll see why the function is called <code>cf_transform</code> in the next section. 
</p>
<div class="org-src-container">
<pre class="src src-python">
print(list(cf_transform(iter([2, 1, 1, 5, 1, 3]))))
</pre>
</div>

<pre class="example">
[2, 1, 1, 5, 1, 3]
</pre>


<p>
This seems to be anti-climatic for quite a bit of work&#x2026; but here's something cool. Gospher combined the two stacked matrix representations that we have seen, to illustrate every step in the algorithm:
</p>

<div class="org-src-container">
<pre class="src src-python">
print(cf_transform_tab(iter([2, 1, 1, 5, 1, 3])))
</pre>
</div>

<pre class="example">
  3 1 5 1 1 2    
        3 2 1 0  
      2 1 1 0 1 2
    6 1 1 0     1
  6 5 1 0       1
4 1 1 0         5
3 1 0           1
1 0             3

</pre>


<p>
The numbers on the right are the outputs of <code>cf_transform</code>.
</p>
</div>
</div>

<div id="outline-container-org4652b83" class="outline-2">
<h2 id="org4652b83"><span class="section-number-2">7</span> Simple transformations of continued fractions</h2>
<div class="outline-text-2" id="text-7">
<p>
The beauty of the matrix representation is that we can transform convergents with a function of the form \(f(x) = \frac{px+q}{rx+s}\). All we need is an additional matrix multiplication on the left side! This can be calculated by giving <code>cf_transform</code> an initial matrix.
</p>

<p>
<a id="org7036902"></a>
The continued fraction \([2, 1, 1, 5, 1]\) is \(\frac{33}{13}\). Let's double that, and turn it back to a continued fraction:
</p>
<div class="org-src-container">
<pre class="src src-python">
print("[2, 1, 1, 5, 1] is ", cf2r1(iter([2, 1, 1, 5, 1])))
print("The continued fraction of 66/13 is ", list(r2cf(Rational(66, 13))), "\n")
print(r2cf_tab(Rational(66, 13)))
</pre>
</div>

<pre class="example">
[2, 1, 1, 5, 1] is  33/13
The continued fraction of 66/13 is  [5, 13] 

   66
   13   5   
    1   13  
    0

</pre>


<p>
According to the above, \(2 * [2, 1, 1, 5, 1]\) is \([5, 13]\). How do we end up with fewer terms? We can illustrate the process by running <code>cf_transform_tab</code> with the initial matrix \(\begin{bmatrix} 2 & 0 \\ 0 & 1 \end{bmatrix}\) (which stands for the function \(f(x) = 2x\)):
</p>
<div class="org-src-container">
<pre class="src src-python">
m0 = np.array([[2, 0], [0, 1]], int)
cf = cf_transform(iter([2, 1, 1, 5, 1]), m0 = m0)
print(" 2 * [2, 1, 1, 5, 1] is ", list(cf), "\n")
print(cf_transform_tab(iter([2, 1, 1, 5, 1]), m0 = m0))
</pre>
</div>

<pre class="example">
2 * [2, 1, 1, 5, 1] is  [5, 13] 

    1  5  1  1  2      
      10  6  4  2  0   
13 11  2  1  1  0  1  5
 1  1  0  1          13

</pre>


<p>
Take one of the matrices in the tabulated display \(\begin{bmatrix} 6 & 4 \\ 1 & 1\end{bmatrix}\) for example. The range of \(\frac{6x+4}{x+1}\) is too wide (between 4 and 6) for the quotient to be determined. The algorithm therefore needs another term of the continued fraction. The matrix shifts leftwards without outputting a quotient. That's why the transformed continued fraction has a smaller number of terms. 
</p>

<p>
Previously, we saw that the reciprocal of a continued fraction has an addition 0 in the beginning. Let's verify that with the initial matrix \(\begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}\) (which stands for the function \(f(x) = \frac{1}{x}\)): 
</p>
<div class="org-src-container">
<pre class="src src-python">
m0 = np.array([[0, 1], [1, 0]], int)
cf = cf_transform(iter([2, 1, 1, 5, 1]), m0 = m0)
print("The reciprocal of [2, 1, 1, 5, 1] is ", list(cf), "\n")
print(cf_transform_tab(iter([2, 1, 1, 5, 1]), m0 = m0))
</pre>
</div>

<pre class="example" id="orge386c17">
The reciprocal of [2, 1, 1, 5, 1] is  [0, 2, 1, 1, 5, 1] 

   1 5 1 1 2    
         1 0 1  
       3 2 1 0 0
     2 1 1 0   2
   6 1 1 0     1
 6 5 1 0       1
 1 1 0         5
 1 0           1

</pre>

<p>
Another example: what is \(\frac{2}{3-\sqrt{2}}\) as a continued fraction? First, \(\sqrt{2} = [1, 2, 2, 2...]\), so we should define an infinite generator:
</p>
<div class="org-src-container">
<pre class="src src-python">def cf_sqrt2():
    """A generator representing sqrt(2) as a continued fraction"""
    yield 1
    while True:
	yield 2
</pre>
</div>

<p>
Then, we just need to run <code>cf_transform</code> with \(\begin{bmatrix} 0 & 2 \\ -1 & 3 \end{bmatrix}\) (which stands for \(\frac{2}{-x + 3}\)):
</p>
<div class="org-src-container">
<pre class="src src-python">
m0 = np.array([[0, 2], [-1, 3]], int)
cf = islice(cf_transform(cf_sqrt2(), m0 = m0), 6)
print(" 2 / (3 - sqrt(2)) is ", pp_inf_cf(list(cf)), "\n")
print(cf_transform_tab(islice(cf_sqrt2(), 6), m0 = m0))
</pre>
</div>

<pre class="example" id="orgcad20cc">
2 / (3 - sqrt(2)) is  [1,3,1,4,1,4...] 

    2  2  2  2  2  1      
             4  2  0  2   
          8  3  2 -1  3  1
       5  2  1  0        3
   10  4  2  0           1
 5  2  1  0              4
 4  2  0                 1
 1  0                    4

</pre>
<p>
The answer is a periodic continued fraction \([1, 3, 1, 4, 1, 4...]\).
</p>

<p>
Another example: what is \(\tanh{\frac{1}{2}} = \frac{e-1}{e+1}\)? We have already defined the continued fraction for \(e\), so it's just a matter of choosing the right initial matrix (\(\begin{bmatrix} 1 & -1 \\ 1 & 1 \end{bmatrix}\), representing \(\frac{x-1}{x+1}\)):
</p>
<div class="org-src-container">
<pre class="src src-python">
m0 = np.array([[1, -1], [1, 1]], int)
cf = islice(cf_transform(cf_e(), m0 = m0), 6)
print("(e-1)/(e+1) is ", pp_inf_cf(list(cf)), "\n")
print(cf_transform_tab(islice(cf_e(), 12), m0 = m0))
</pre>
</div>

<pre class="example" id="org3a42544">
(e-1)/(e+1) is  [0,2,6,10,14,18...] 

     8  1  1  6  1  1  4  1  1  2  1  2      
                                   1  1 -1   
                                4  3  1  1  0
                      12  7  5  2  1  1     2
             20 11  9  2  1  1  0  1        6
    28 15 13  2  1  1  0  1                10
 17  2  1  1  0  1                         14
  1  0  1                                  17

</pre>
<p>
The answer is a continued fraction with a simple pattern: after the second term, add 4 to the previous term.
</p>

<p>
I find the tabulated displays visually appealing, so I wrote some external codes (in <i>Mathematica</i>) to give them some colors. The colors make it easier to see the patterns in the numbers.
</p>

<div id="orgdf4aa2a" class="figure">
<p><img src="figs/cf_transform_summary.png" alt="cf_transform_summary.png" width="600" />
</p>
</div>

<p>
Before we proceed further, there is a small but important point that should be clarified. In the last example, we transformed \(e\) to calculate \(\frac{e-1}{e+1}\). It was done by truncating \(e\)'s infinite number of terms, retaining only the first 6 terms. This might give the impression that <code>cf_transform</code> is for approximating \(\frac{e-1}{e+1}\). That is not the case. The entire point of Gospher's work is to show that <i>exact</i> continued fraction arithmetic is possible. If this is not clear to you, let's define a different interface to <code>cf_transform_</code>, to make the point more obvious.
</p>
<div class="org-src-container">
<pre class="src src-python">def cf_transform_func(cf: Iterator[int], m0: np.ndarray) -&gt; Tuple[List[int], np.ndarray]:
    """
    Transform a continued continuation with finite number of terms.

    Returns a list (representing the transformed fraction) and the
    last homographic function so that it can be used on more terms.

    If cf is infinite, this function won't terminate.

    :param cf: The input continuned fraction.
    :param m0: A 2x2 matrix representing the transformation
    :return: A list representing the transformed fraction, and
	     a 2x2 matrix representing the homographic function
    """
    outputs: List[int] = []
    out_m: Optional[np.ndarray] = None
    for res in cf_transform_(cf, m0, finite_term = False):
	(q, r, m, a, new_a) = res
	if q is not None:
	    outputs = outputs + [q]
	    out_m = r
	else:
	    out_m = m
    assert isinstance(out_m, np.ndarray)
    return outputs, out_m
</pre>
</div>

<p>
I call this function <code>cf_transform_func</code>, to emphasize that the output is a list integers, <i>and</i> a function represented by a matrix. The list of integers is an approximation, but together with the function, we have the exact solution to the computation. Why is it exact? Because if we have more terms of \(e\), we can send it to the function to get more output terms. This is a recursive process that can continue forever.
</p>

<p>
The example below, we call <code>cf_transform_func</code> with the first 6 terms of \(e\). We get 3 terms (0, 2, 6), and the function \(f(x) = \frac{9x + 2}{x}\), represented by the matrix. We can get 6 more terms of \(e\), and call <code>cf_transform_func</code> again with the matrix to continue the process.
</p>
<div class="org-src-container">
<pre class="src src-python">
m0 = np.array([[1, -1], [1, 1]], int)
cf = cf_e()
cf6 = islice(cf, 6)
(outs, m) = cf_transform_func(cf6, m0 = m0)
print("Using the first 6 terms of e, (e-1)/(e+1) is ", outs)
print("The homomorphic function is:\n ", m)
# take 6 more terms from e
cf6 = islice(cf, 6)
# we can continue our calculations to get more terms
(outs, m) = cf_transform_func(cf6, m0 = m)
print("With 6 more terms of e, we get ", outs)
</pre>
</div>

<pre class="example">
Using the first 6 terms of e, (e-1)/(e+1) is  [0, 2, 6]
The homomorphic function is:
  [[9 2]
 [1 0]]
With 6 more terms of e, we get  [10, 14]
</pre>
</div>
</div>

<div id="outline-container-orgb0230ef" class="outline-2">
<h2 id="orgb0230ef"><span class="section-number-2">8</span> Arithmetic (Step 1): From matrices to tensors</h2>
<div class="outline-text-2" id="text-8">
<p>
We have been dealing with one continued fraction at a time. In those situations, all operations involve functions of the form \(f(x) = \frac{px+q}{rx+s}\). They are known as <i>homographic functions</i>, and they can be represented by the matrix \(\begin{bmatrix} p & q \\ r & s \end{bmatrix}\). How do we generalize it to operations involving two continued fractions?
</p>

<p>
The problem is solved with <i>bihomographic functions</i> of the form \(f(x, y) = \frac{axy + bx + cy + d}{exy + fx + gy + h}\), where \(x\) and \(y\) are the unknown terms for the two continued fractions \(a\) and \(b\) respectively. We can write it in matrix form as:
</p>

\begin{equation*}
f(x, y) = \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} b & d \\ a & c \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} \bigg/
          \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} f & h \\ e & g \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix}
\end{equation*}


<p>
Since we are working with two matrices as a single entity, it's natural to use tensors to represent bihomographic functions:
</p>
<div class="org-src-container">
<pre class="src src-python"># Tensor representations of bihomographic functions

def tFrom2x4(m: np.ndarray) -&gt; np.ndarray:
    """
    Translate a bihomographic function from algebraic to tensor form.

    :param m: A 2x4 matrix representing the function
    :return: A 2x2x2 tensor
    """
    ((a, b, c, d), (e, f, g, h)) = m.tolist()
    return np.array([[[b, d], [a, c]], [[f, h], [e, g]]])

def tTo2x4(m: np.ndarray) -&gt; np.ndarray:
    """
    Translate a bihomographic function from tensor to algebraic form.

    :param m: A 2x2x2 tensor
    :return: A 2x4 matrix
    """

    (((b, d), (a, c)), ((f, h), (e, g))) = m.tolist()
    return np.array([[a, b, c, d], [e, f, g, h]])
</pre>
</div>

<p>
I need a utility function to make it easy to access so many numbers in the tensors:
</p>
<div class="org-src-container">
<pre class="src src-python">def tensor_ref(t: np.ndarray, label: str) -&gt; Union[int, Tuple[int, int]]:
    """
    Easy accessing elements of a tensor

    :param t: A 2x2x2 tensor
    :param label: a-h refers to a number in the tensor
		  xy, x, y, 1 refers to numerator/denominator pairs
    :return: A number, or a pair of numbers
    """
    assert t.shape == (2, 2, 2)
    assert label in ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'xy', 'x', 'y', '1']
    lookup = {}
    lookup['a']  = t[0,1,0]
    lookup['b']  = t[0,0,0]
    lookup['c']  = t[0,1,1]
    lookup['d']  = t[0,0,1]
    lookup['e']  = t[1,1,0]
    lookup['f']  = t[1,0,0]
    lookup['g']  = t[1,1,1]
    lookup['h']  = t[1,0,1]
    lookup['xy'] = lookup['a'], lookup['e']
    lookup['x']  = lookup['b'], lookup['f']
    lookup['y']  = lookup['c'], lookup['g']
    lookup['1']  = lookup['d'], lookup['h']
    return lookup[label]
</pre>
</div>

<p>
What happens to \(f(x, y)\), with the addition of a new term \(a_n\) of \(a\)?
</p>

\begin{equation*}
f(a_n + \frac{1}{x}, y) = \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} a_n b  + d & b \\ a_n a + c & a \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} \bigg /
                          \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} a_n f  + h & f \\ a_n e + g & e \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} 
\end{equation*}

<p>
This is familiar, isn't it? It's exactly the same update rule that we use for updating the convergents! All we need to do is to right-multiply \(\begin{bmatrix} a_n & 1 \\ 1 & 0\end{bmatrix}\) the two matrices.
</p>

<p>
We can do the same with a new term \(b_n\) for \(b\):
</p>

\begin{equation*}
f(x, b_n + \frac{1}{y}) = \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} a & c \\ b_n a + b & b_n c + d \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} \bigg /
                          \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} e & g \\ b_n e + f & b_n g + h \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} 
\end{equation*}

<p>
This is basically the same thing, except that the direction is different. This corresponds to left-multiplying \(\begin{bmatrix} 0 & 1 \\ 1 & b_n\end{bmatrix}\).
</p>

<p>
The above suggests an elegant way to visualize continued fraction arithmetic: if we imagine that two matrices form a 2x2x2 cube, this cube moves leftwards upon receiving a new term of \(a\), and it moves downwards upon receiving a new term of \(b\). As before, we'll also use the Euclidean algorithm to convert the bihomographic function into continued fractions. When we get to perform the Euclidean step, the 2x2x2 cube moves in the third dimension. The following figure illustrates that continued fraction arithmetic is a direct generalization of the 2D case:
</p>


<div id="org670d040" class="figure">
<p><img src="figs/cf_space.png" alt="cf_space.png" width="500px" />
</p>
</div>

<p>
To implement the cube movements in Python, I use my favorite Numpy function: <code>einsum</code> (Einstein's sum; see <a href="https://ajcr.net/Basic-guide-to-einsum/">this tutorial</a>). If the very compact notation (invented by Einstein) seems cryptic, don't worry. It's just repeated matrix multiplication.
</p>
<div class="org-src-container">
<pre class="src src-python">def apply_a(t: np.ndarray, a: int) -&gt; np.ndarray:
    '''Move tensor t to the left by taking a new term of a'''
    ha = h(a)
    return np.einsum('dyx,xz-&gt;dyz', t, ha)

def h_rotated(b: int) -&gt; np.ndarray:
    '''A rotated version of the 2x2 homgraphic matrix'''
    return np.array([[0, 1], [1, b]])

def apply_b(t: np.ndarray, b: int) -&gt; np.ndarray:
    '''Move tensor t downwards by taking a new term of b'''
    hb = h_rotated(b)
    return np.einsum('zy,dyx-&gt;dzx', hb, t)

def apply_ab(t: np.ndarray, term: int, label: str) -&gt; np.ndarray:
    """
    Apply a new term to the bihomographic tensor

    :param t: The tensor
    :param term: The new term to be applied to the tensor
    :param label: Is the term from continued fraction a or b?
    :return: A new 2x2x2 tensor
    """
    assert label in ['a', 'b']
    if label == 'a':
	return apply_a(t, term)
    else:
	return apply_b(t, term)
</pre>
</div>
</div>
</div>
<div id="outline-container-org336d9f9" class="outline-2">
<h2 id="org336d9f9"><span class="section-number-2">9</span> Arithmetic (Step 2):  Representing arithmetic operations</h2>
<div class="outline-text-2" id="text-9">
<p>
Something is curious about the discussion so far. We have a generic method for ingesting terms of two continued fractions, but how do we actually perform a specific operation on them? It's not hard to see that it all depends on the initial matrices. With appropriately chosen initial matrices, we can do multiplication, addition, division, subtraction, and their combinations. I think it's quite a remarkable result, because when we are dealing with numbers with multiple terms, multiplication is usually harder than addition. With continued fraction, the computational steps are exactly the same!
</p>

<p>
I made the following two figures to explain how addition and multiplication are done. Here's \(a+b\). We begin with just the initial matrices (first row), add the first term of \(a\), and then add the first term of \(b\). 
</p>

<div id="org11b5316" class="figure">
<p><img src="figs/addition.png" alt="addition.png" width="500px" />
</p>
</div>

<p>
Here's the same process for multiplication:
</p>

<div id="org3815128" class="figure">
<p><img src="figs/multiplication.png" alt="multiplication.png" width="500px" />
</p>
</div>

<p>
These are the initial tensors for the four basic operations:
</p>
<div class="org-src-container">
<pre class="src src-python"># Initial tensors for basic arithemtic operations

tForAddition = np.array([[[1, 0], [0, 1]], [[0, 1], [0, 0]]])
tForSubtraction = np.array([[[1, 0], [0, -1]], [[0, 1], [0, 0]]])
tForMultiplication = np.array([[[0, 0], [1, 0]], [[0, 1], [0, 0]]])
tForDivision = np.array([[[1, 0], [0, 0]], [[0, 0], [0, 1]]])
</pre>
</div>

<p>
To make sure that the addition matrix works:
</p>
<div class="org-src-container">
<pre class="src src-python">
t = tForAddition
t = apply_ab(t, 2, 'a')
t = apply_ab(t, 3, 'b')
t = apply_ab(t, 4, 'a')
t = apply_ab(t, 5, 'b')
print(tTo2x4(t))
</pre>
</div>

<pre class="example">
[[109  21  26   5]
 [ 20   4   5   1]]
</pre>


<p>
\(\begin{bmatrix} 109 & 21 & 26 & 5 \\ 20 & 4 & 5 & 1 \end{bmatrix}\) means \(\frac{109xy + 21x + 26y + 5}{20xy + 4x + 5y + 1}\), which equals \((2+\frac{1}{4+\frac{1}{x}}) + (3+\frac{1}{5+\frac{1}{y}})\). That's correct.
</p>

<p>
Let's try multiplication:
</p>
<div class="org-src-container">
<pre class="src src-python">
t = tForMultiplication
t = apply_ab(t, 2, 'a')
t = apply_ab(t, 3, 'b')
t = apply_ab(t, 4, 'a')
print(tTo2x4(t))
</pre>
</div>

<pre class="example">
[[27  9  6  2]
 [ 4  0  1  0]]
</pre>


<p>
\(\frac{27xy+9x+6y+2}{4xy+y} = (2 + \frac{1}{4+\frac{1}{x}}) \cdot (3+\frac{1}{y})\). That's also correct.
</p>
</div>
</div>

<div id="outline-container-orgd48be3a" class="outline-2">
<h2 id="orgd48be3a"><span class="section-number-2">10</span> Arithmetic (Step 3): Calculating convergents using tensors</h2>
<div class="outline-text-2" id="text-10">
<p>
By updating the bihomographic function with new terms of \(a\) and \(b\), we can generate a series of rational numbers that converges to the result. The following code does this by applying a new term of \(a\), and then a new term of \(b\)&#x2026; and so on. This is not the only way to update the tensors. Any process that applies the terms in sequence will work. You can, for example, update with two terms of \(a\), and then two terms of \(b\).
</p>
<div class="org-src-container">
<pre class="src src-python"># Continued fraction arithmethic - convergents

def arithmetic_convergents_(a: Iterator[int], b: Iterator[int], t0 = tForAddition) -&gt; Iterator[Tuple[str, int, np.ndarray]]:
    """
    The convergents of doing arithemtic on two continued fractions.

    This version exposes the internal steps for visualization and debugging.
    New terms of the two continued fractions are applied alternately

    :param a: The first continued fraction.
    :param b: The second continued fraction.
    :param t0: The 2x2x2 tensor representing the operation.
    :return: The source (a or b?), the term, and the result (a 2x2x2 tensor)
    """
    res = t0.copy()
    while True:
	an = next(a, None)
	bn = next(b, None)

	if an is None and bn is None:
	    break

	if an is not None:
	    res = apply_ab(res, an, 'a')
	    yield 'a', an, res
	if bn is not None:
	    res = apply_ab(res, bn, 'b')
	    yield 'b', bn, res

def arithmetic_convergents(a: Iterator[int], b: Iterator[int], t0 = tForAddition) -&gt; Iterator[Rational]:
    """
    The convergents of doing arithmetic on two continued fraction.

    This version returns an iteartor of rational numbers.
    :param a: The first continued fraction.
    :param b: The second continued fraction.
    :param t0: The 2x2x2 tensor representing the operation.
    :return: An iterator of rational numbers
    """
    c = arithmetic_convergents_(a, b, t0)
    for _, _, res in c:
	r = tensor_ref(res, 'xy')
	assert isinstance(r, tuple)
	yield Rational(r[0], r[1])
</pre>
</div>

<p>
We have calculated <a href="#org7036902">previously</a> that \(2*[2, 1, 1, 5, 1] = \frac{66}{13}\). Let's verify it by adding the continued fraction to itself:
</p>
<div class="org-src-container">
<pre class="src src-python">
a = iter([2, 1, 1, 5, 1])
b = iter([2, 1, 1, 5, 1])
print(list(arithmetic_convergents(a, b, tForAddition)))
</pre>
</div>

<pre class="example">
[1/0, 4/1, 5/1, 6/1, 11/2, 20/4, 111/22, 616/121, 727/143, 858/169]
</pre>


<p>
Yup. \(\frac{858}{169}\) equals to \(\frac{66}{13}\).
</p>

<p>
Let's try subtraction. Observe that \([2, 1, 1, 5, 1] - [2, 1, 1, 5, 1]\) does become 0 (that is \(\frac{0}{169}\)):
</p>
<div class="org-src-container">
<pre class="src src-python">
a = iter([2, 1, 1, 5, 1])
b = iter([2, 1, 1, 5, 1])
print(list(arithmetic_convergents(a, b, tForSubtraction)), "\n")
</pre>
</div>

<pre class="example">
[-1/0, 0/1, 1/1, 0/1, -1/2, 0/4, 1/22, 0/121, -1/143, 0/169] 

</pre>


<p>
Note that the numerator oscillates between -1, 0, and 1, while the denominator gets larger and larger.
</p>

<p>
How about division? Yup. \(\frac{429}{429}=1\).
</p>
<div class="org-src-container">
<pre class="src src-python">
a = iter([2, 1, 1, 5, 1])
b = iter([2, 1, 1, 5, 1])
print(list(arithmetic_convergents(a, b, tForDivision)), "\n")
</pre>
</div>

<pre class="example">
[0/1, 2/2, 3/2, 3/3, 5/6, 10/10, 56/55, 308/308, 363/364, 429/429] 

</pre>


<p>
Finally, let's try \(\sqrt{2}*\sqrt{2}\). With infinite number of terms, the answer should be 2. With finite number of terms, however, we get an approximation of 2 (\(\frac{9801}{4900}=2.0002\)).
</p>
<div class="org-src-container">
<pre class="src src-python">
a = islice(cf_sqrt2(), 6)
b = islice(cf_sqrt2(), 6)  
print(list(arithmetic_convergents(a, b, tForMultiplication)), "\n")
</pre>
</div>

<pre class="example">
[1/0, 1/1, 3/2, 9/4, 21/10, 49/25, 119/60, 289/144, 697/348, 1681/841, 4059/2030, 9801/4900] 

</pre>


<p>
Now we've come to visualization. Again, Gospher developed an ingenious method for visualizing the computational process, representing 2x2x2 tensors with a pseudo-3D effect. I decided not to implement his method because I find it hard to read. Instead, I will display the numerator and the denominator matrices separately. This format is not as compact as Gospher's method, but it works better when the numbers get large. In the figure below, the upper "band" is the evolution of the numerator matrix, and the lower band does the same for the denominator matrix. Note that for a 2x2 matrix in either band, you should read off the number in the lower-left corner, because \(\lim_{\substack{x\to \infty \\ y\to \infty}} \frac{axy + bx + cy + d}{exy + fx + gy + h} = \frac{a}{e}\).
</p>
<div class="org-src-container">
<pre class="src src-python">
a = iter([2, 1, 1, 5, 1])
b = iter([2, 1, 1, 5, 1])  
print(arithmetic_convergents_tab(a, b, tForAddition))  
</pre>
</div>

<pre class="example" id="orgb7b7a4c">
      1   5   1   1   2        
                  2   1   0    
              1   1   0   1   2
          9   5   4   1       1
     61  11   6   5           1
131 111  20  11               5
727 616 111                   1
858 727                        
                  1   0   1    
              0   0   0   0    
          2   1   1   0        
     11   2   1   1            
 26  22   4   2                
143 121  22                    
169 143                        

</pre>
<p>
The result \(\frac{858}{168}\) comes from the numbers at the lower-left corners of the two bands. Note that the row on top and the column on the right represent the two continued fractions.
</p>

<p>
Finally, some colors:
</p>

<div id="org48d0e05" class="figure">
<p><img src="figs/arithmetic_convergents.png" alt="arithmetic_convergents.png" width="600px" />
</p>
</div>

<p>
Unfortunately, I think these displays are not very satisfying, because the numbers tend to grow monotonically. That's because we haven't performed any Euclidean step. That's for the next section.
</p>
</div>
</div>

<div id="outline-container-org3a3bb2b" class="outline-2">
<h2 id="org3a3bb2b"><span class="section-number-2">11</span> Arithmetic (Step 4): Applying the Euclidean algorithm to convergents</h2>
<div class="outline-text-2" id="text-11">
<p>
Since our tensors are just representations of bihomographic functions, it's straightforward to apply the Euclidean algorithm symbolically on them. <code>euclid_tensor_</code> is almost identical to <code>euclid_matrix_</code> in code structure:
</p>
<div class="org-src-container">
<pre class="src src-python"># Continued fraction arithmetic - full version with Euclidean steps

def euclid_tensor_(t: np.ndarray) -&gt; Iterator[Tuple[int, np.ndarray]]:
    """
    Symbolic Euclidean step for tensor t

    :param t: The 2x2x2 tensor
    :return: An iterator of quotient (an int) and remainder (a tensor)
    """
    while True:
	if np.all(t[0]==0):
	    # if the numerator is all zero, stop
	    break
	else:
	    (q, r) = qr_tensor(t)
	    if q is not None:
		yield q, r
		t = r
	    else:
		break
</pre>
</div>

<p>
In the following example, we manage to extract three terms from the bihomographic function \(f(x, y) = \frac{3466xy + 1150x + 483y + 216}{1318xy + 601x + 182y + 83}\):
</p>
<div class="org-src-container">
<pre class="src src-python">
t = np.array([[[1550, 216], [3466, 483]], [[601, 83], [1318, 182]]])          
res = euclid_tensor_(t)
for (q, r) in res:
    print(q)
</pre>
</div>

<pre class="example">
2
1
1
</pre>



<p>
A tabulated format can be used to visualize the process. It is a generalization of the format that we used to visualize the symbolic Euclidean algorithm (see <a href="#orgf9227c3">here</a>), except that we are now flipping entire matrices instead of rows.
</p>
<div class="org-src-container">
<pre class="src src-python">
t = np.array([[[1550, 216], [3466, 483]], [[601, 83], [1318, 182]]])          
c = euclid_tensor_tab(t)
print(c)
</pre>
</div>

<pre class="example" id="orgb19e99e">
1550  216     
3466  483     
 601   83    2
1318  182     
 348   50    1
 830  119     
 253   33    1
 488   63     
  95   17     
 342   56     

</pre>
<p>
The algorithm stops after 3 steps, because the bihomographic function associated with the remainder of the last step \(f(x, y) = \frac{488xy+253x+63y+33}{342xy+95x+56y+17}\) is bounded by \(\frac{63}{56}=1.125\) and \(\frac{253}{95}=2.66316\). The range is too wide to determine a quotient.
</p>


<div id="org2d9c37e" class="figure">
<p><img src="figs/fig2.png" alt="fig2.png" width="400" />
</p>
</div>

<p>
Now it's time to combine the Euclidean algorithm (<code>euclid_tensor_</code>) with convergent calculation (<code>arithmetic_convergents_</code>). The code structure is basically the same as <code>cf_transform_</code>, except that there is one additional issue to consider: when we work with just one continued fraction, if the Euclidean step fails to determine a quotient, the only thing that we can do is to ingest one more term from the continued fraction. But now we have two continued fractions, so we have to decide which one to use. In terms of the 3D space, the question becomes: should we move the cube left or down? The decision is more or less arbitrary, because the Euclidean step will eventually sort out the result, as long as the terms from the two continued fractions are ingested sequentially. However, for visualization, we want to perform the Euclidean step as soon as possible, to prevent the numbers in the tensor from becoming too big. I use some heuristics from Gospher's paper to make this decision. The implementation (<code>ABQueue</code>) is in the <a href="#org3f4efaa">Appendix</a>.
</p>
<div class="org-src-container">
<pre class="src src-python">def cf_arithmetic_(cf_a: Iterator[int], cf_b: Iterator[int], t0: np.ndarray, finite_term = True) -&gt; Iterator:
    """
    Perform arithmetic operation on two continued fraction.

    :param cf_a: The first continued fraction.
    :param cf_b: The second continued fraction.
    :param t0: The 2x2x2 tensor representing the opertion.
    :param finite_term: Is this a finite-length continued fraction,
			or a truncation of an infinite one?
    :return: q - quotient (None if no Euclidean step performed)
	     r - remainder (2x2x2 tensor)
	     t - the tensor before the Euclidean step
	     term - the term used in the update
	     label - where does the term come from? cf_a or cf_b?
	     new_term - was a new term (either from cf_a or cf_b) used?
			It's false if only an Euclidean step was performed.
    """
    t = t0
    next_ab = ABQueue(cf_a, cf_b)

    while True:
	term, label = next_ab(t)
	if term is None and label is None:
	    # cf_a and cf_b are exhausted
	    break
	else:
	    assert isinstance(term, int)
	    assert isinstance(label, str)
	    t = apply_ab(t, term, label)
	    new_term = True
	    for (q, r) in euclid_tensor_(t):
		yield q, r, t, term, label, new_term
		t = r
		new_term = False
	    if new_term:
		# Nothing was yielded.
		# This means that an Euclidean step was not performed
		yield None, None, t, term, label, new_term

    # we will only reach this point if cf_a and cf_b have finite terms
    if finite_term and tensor_ref(t, 'e') != 0:
	rxy = tensor_ref(t, 'xy')
	assert isinstance(rxy, tuple)
	for s in r2cf(Rational(rxy[0], rxy[1])):
	    yield s, None, t, None, None, False
    else:
	# if the 'e' term is 0, that means the quotient is 0.
	# there is no need to return it
	pass

def cf_arithmetic(cf_a: Iterator[int], cf_b: Iterator[int], t0: np.ndarray, finite_term = True) -&gt; Iterator[int]:
    """
    Perform arithmetic operation on two continued fractions.

    :param cf_a: The first continued fraction.
    :param cf_b: The second continued fraction.
    :param t0: The operation, represented by a 2x2x2 tensor.
    :param finite_term: Is this a continued fraction with finite terms,
			or a truncated one?
    :return: An iterator of the new continued fraction
    """
    for res in cf_arithmetic_(cf_a, cf_b, t0, finite_term = finite_term):
	(q, r, t, term, label, new_term) = res
	if q is not None:
	    yield q

def cf_arithmetic_func(cf_a: Iterator[int], cf_b: Iterator[int], t0: np.ndarray) -&gt; Tuple[List[int], np.ndarray]:
    """
    Perform arithmetic operations on two finite-length continued fraction.

    Return a new fraction, and a bihomographic functiom, which can be
    applied to more terms.

    :param cf_a: The first finite-length continued fraction.
    :param cf_b: The second finite-length continued fraction.
    :param t0: A 2x2x2 tensor representing the operation.
    :return: A list, representing terms of the new continued fraction.
	     A 2x2x2 tensor representing the final bihomographic function.
    """
    outputs: List[int] = []
    out_t: Optional[np.ndarray] = None
    for res in cf_arithmetic_(cf_a, cf_b, t0, finite_term = False):
	q, r, t, term, label, new_term = res
	if q is not None:
	    outputs = outputs + [q]
	    out_t = r
	else:
	    out_t = t

    assert isinstance(out_t, np.ndarray)
    return outputs, out_t
</pre>
</div>

<p>
In an earlier <a href="#org7036902">section</a>, we showed that \(2 * [2, 1, 1, 5, 1] = [5, 13]\). Let's see if we can duplicate this by adding \([2, 1, 1, 5, 1]\) to itself.
</p>
<div class="org-src-container">
<pre class="src src-python">
a = iter([2, 1, 1, 5, 1])
b = iter([2, 1, 1, 5, 1])
print(list(cf_arithmetic(a, b, tForAddition)))
</pre>
</div>

<pre class="example">
[5, 13]
</pre>


<p>
It works! Subtraction?
</p>
<div class="org-src-container">
<pre class="src src-python">
a = iter([2, 1, 1, 5, 1])
b = iter([2, 1, 1, 5, 1])
print(list(cf_arithmetic(a, b, tForSubtraction)))
</pre>
</div>

<pre class="example">
[0]
</pre>


<p>
Yup! Multiplication?
</p>
<div class="org-src-container">
<pre class="src src-python">
a = iter([2, 1, 1, 5, 1])
b = iter([2, 1, 1, 5, 1])
print(list(cf_arithmetic(a, b, tForMultiplication)))
</pre>
</div>

<pre class="example">
[6, 2, 3, 1, 18]
</pre>


<p>
So, \(\Bigg( 2 + \frac{1}{1 + \frac{1}{1 + \frac{1}{5 + \frac{1}{1}}}} \Bigg)^2 = 6 + \frac{1}{2 + \frac{1}{3 + \frac{1}{1 + \frac{1}{18}}}}\). This is pretty cool, and it's something that we couldn't do before.
</p>


<p>
How about division?
</p>
<div class="org-src-container">
<pre class="src src-python">
a = iter([2, 1, 1, 5, 1])
b = iter([2, 1, 1, 5, 1])
print(list(cf_arithmetic(a, b, tForDivision)))
</pre>
</div>

<pre class="example">
[1]
</pre>


<p>
Also works. One more sanity check. This is a different way of demonstrating that the reciprocal of a continued fraction has an additional 0 in front. Note that the terms of a continued fraction are unique, except for the last one. \([2, 1, 1, 6]\) is just a different way of expressing \([2, 1, 1, 5, 1]\).
</p>
<div class="org-src-container">
<pre class="src src-python">
a = iter([1])
b = iter([2, 1, 1, 5, 1])
print(list(cf_arithmetic(a, b, tForDivision)))
</pre>
</div>

<pre class="example">
[0, 2, 1, 1, 6]
</pre>


<p>
Finally, a more difficult question: \(\sqrt{2} * \sqrt{2} = 2\). Because \(\sqrt{2}\) is an irrational number, we'll get 2 only if we have infinite number of terms. With finite number of terms, the best that we can do is approximation.
</p>

<p>
With 6 terms of \(\sqrt{2}\), we get \(2 + \frac{1}{4900}\)
</p>
<div class="org-src-container">
<pre class="src src-python">
a = islice(cf_sqrt2(), 6)
b = islice(cf_sqrt2(), 6)
print(list(cf_arithmetic(a, b, tForMultiplication)))
</pre>
</div>

<pre class="example">
[2, 4900]
</pre>


<p>
With 8 terms of \(\sqrt{2}\), we get \(2 + \frac{1}{5654884}\). So indeed, we are getting more accurate approximations of 2.
</p>
<div class="org-src-container">
<pre class="src src-python">
a = islice(cf_sqrt2(), 10)
b = islice(cf_sqrt2(), 10)
print(list(cf_arithmetic(a, b, tForMultiplication)))
</pre>
</div>

<pre class="example">
[2, 5654884]
</pre>


<p>
We don't have to truncate the inputs to finite terms. If the two continued fractions have infinite number of terms, we'll get the first term of the result (2) easily. However, if we ask for a second term, the program will get stuck in an infinite loop.
</p>
<div class="org-src-container">
<pre class="src src-python">
a = cf_sqrt2()
b = cf_sqrt2()
res = cf_arithmetic(a, b, tForMultiplication)
print(next(res))
</pre>
</div>

<pre class="example">
2
</pre>
</div>
</div>

<div id="outline-container-orgb9a439c" class="outline-2">
<h2 id="orgb9a439c"><span class="section-number-2">12</span> The final section with complex figures</h2>
<div class="outline-text-2" id="text-12">
<p>
Finally, we'll replicate a complex example in Gospher's paper. This example involves \(a=\frac{e^2+1}{e^2-1} = [1, 3, 5, 7\cdots]\), and \(b=\sqrt{6}=[2, 2, 4, 2, 4, 2\cdots]\). The goal is to calculate \(\frac{2ab+a}{ab+b}\).
</p>

<p>
First, define the two continued fractions:
</p>
<div class="org-src-container">
<pre class="src src-python">def cf_sqrt6():
    """sqrt(6) = [2, 2, 4, 2, 4, 2...]"""
    yield 2
    yield 2
    while True:
	yield 4
	yield 2

def cf_coth1():
    """(e^2+1)/(e^2-1) = [1, 3, 5, 7...]"""
    s = 1
    while True:
	yield s
	s = s + 2
</pre>
</div>

<p>
Then we calculate with <code>cf_arithmettic</code>:
</p>
<div class="org-src-container">
<pre class="src src-python">
t0 = np.array([[[1, 0], [2, 0]], [[0, 0], [1, 1]]])
b = islice(cf_sqrt6(), 4)
a = islice(cf_coth1(), 4)
c = cf_arithmetic(a, b, t0, finite_term = False)
print(list(c))
</pre>
</div>

<pre class="example">
[1, 2, 1, 2, 1, 1]
</pre>


<p>
Visualizing the process is much more difficult than the 2D cases. The tabulated display that I implemented is not very intuitive. It takes some time to learn to read it.
</p>
<div class="org-src-container">
<pre class="src src-python">
t0 = np.array([[[1, 0], [2, 0]], [[0, 0], [1, 1]]])
b = islice(cf_sqrt6(), 4)
a = islice(cf_coth1(), 4)
c = cf_arithmetic_tab(a, b, t0)
c.include_out = False
print(c)
</pre>
</div>

<pre class="example" id="orgefaed19">
        7    5    3    1          
                       1    0     
             8    2    2    0    2
            20    5    5    0     
                       0    0     
             7    2    1    1     
       74   14    4    2    2    2
      185   35   10               
             1    0               
       31    6    1               
       67   13    2              4
      299   58                    
       12    2                    
 366   51    9                    
1550  216   38                   2
3466  483                         
 116   16    4                    
 601   83   20                    
1318  182                         
 348   50                         
 830  119                         
 253   33                         
 488   63                         
  95   17                         
 342   56                         

</pre>

<p>
This rendering should make it easier to understand what is going on:
</p>


<div id="org9be6ab8" class="figure">
<p><img src="figs/cf_arithmetic_summary.png" alt="cf_arithmetic_summary.png" width="600" />
</p>
</div>

<p>
These images are fun to look at. Here's another one that I like. This is \(e+e=2e\). I rotated it to give it a horizontal orientation. 
</p>

<div id="orga737c64" class="figure">
<p><img src="figs/e2rotated_edit.png" alt="e2rotated_edit.png" width="600" />
</p>
</div>
</div>
</div>

<div id="outline-container-orgac5232a" class="outline-2">
<h2 id="orgac5232a"><span class="section-number-2">13</span> Appendix: Quotients/remainders for matrices</h2>
<div class="outline-text-2" id="text-13">
<p>
Given a homographic function represented by a 2x2 matrix, determine if the Euclidean step can be performed. If yes, return the quotient.
<a id="org9cc3d37"></a>
</p>
<div class="org-src-container">
<pre class="src src-python"># Simple transformation of continued fraction

flip_m = np.array([[0, 1], [1, 0]])
identity_m = np.array([[1, 0], [0, 1]])

def flip_remain(m: np.ndarray, q: int) -&gt; np.ndarray:
    """
    Caclulate the remainder, and then flip

    :param m: A 2x2 matrix
    :param q: The quotient
    :return: A 2x2 matrix
    """
    assert q &gt;= 0
    r = m[0] - m[1] * q
    m[0] = r
    return np.matmul(flip_m, m)

def qr_matrix(m: np.ndarray) -&gt; Tuple[Optional[int], np.ndarray]:
    """
    Calculate the quotient and the remainder of a 2x2 matrix

    :param m: A 2x2 matrix
    :return: The quotient (None if it cannot be found)
	     The remainder (2x2 matrix; idetity if quotient cannot be found)
    """

    assert not(m[1][0] == 0 and m[1][1] == 0)
    # This means that the series has already ended.
    # Nothing further needs to be done
    # The caller should not call qr_matrix in this case

    m2 = m.copy()

    if m2[1][0] == 0 or m2[1][1] == 0:
	# If the function is unbounded, the quotient cannot be determined
	return (None, identity_m)
    elif m2[1][1] &lt; 0:
	# This means that the denominator can be made 0 (i.e., a singularity)
	return (None, identity_m)
    else:
	# If the function is bounded...
	v0: float = m[0][0] / m[1][0]
	v1: float = m[0][1] / m[1][1]
	v0, v1 = sorted([v0, v1])
	d0: int = math.floor(v0)
	d1: int = math.floor(v1)
	if d0 == d1:
	    # If d1 and d2 are the same, the quotient is determined
	    # Calculate the remain, and flip the matrix
	    m2 = flip_remain(m2, d1)
	    return d1, m2
	elif d1 == d0 + 1:
	    if d1 == v1:
		# This means that d1 is the upper-bound
		# it's only reached at 0 or infinity 
		# So d0 is the quotient
		m2 = flip_remain(m2, d0)
		return d0, m2
	    else:
		# The bounds are not tight enough to determine the quotient
		return (None, identity_m)
	else:
	    # The bounds are not tight enough to determine the quotient
	    return (None, identity_m)
</pre>
</div>
</div>
</div>

<div id="outline-container-orge49341a" class="outline-2">
<h2 id="orge49341a"><span class="section-number-2">14</span> Appendix: Quotients/remainders for tensors</h2>
<div class="outline-text-2" id="text-14">
<p>
<a id="org3f4efaa"></a>
</p>
<div class="org-src-container">
<pre class="src src-python"># Continued fraction arithmetic - Euclidean algorithmn

def qr_tensor(t: np.ndarray) -&gt; Tuple[Optional[int], np.ndarray]:
    """
    Find the quotient and remainder of a 2x2x2 tensor

    :param t: The tensor
    :return: The quotient (None if cannot be determined)
	     The remainder (2x2x2 tensor; identity if quotient is None
    """

    t1 = t.copy()
    if np.all(t1[1]&gt;0):
	# if the denominator matrix doesn't have any 0 or negative number
       r = t_ratios(t)
       if r[0][0] == r[0][1] == r[1][0] == r[1][1]:
	   # if the integer parts are all the same, we've got a quotient
	   q = r[0][0]
	   rem = np.array([t1[1], t1[0] - q * t1[1]])
	   return (q, rem)
       else:
	   # the range is too big to determine the quotient
	   return (None, np.array([identity_m, identity_m]))
    else:
	# the denominator can be zero. The dihomographic function is unbounded
	return (None, np.array([identity_m, identity_m]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def t_ratios(t: np.ndarray) -&gt; list:
    """
    Calculate the floor ratios of the numerator and the denominator terms.

    Make sure that the denominator doesn't have 0 or negative numbers

    :param t: the 2x2x2 tensor
    :return: A 2x2 matrix (as list of lists)
    """
    def r(label):
	numerator, denominator = tensor_ref(t, label)
	return [numerator/denominator, math.floor(numerator/denominator), label]

    zz = [r('xy'), r('x'), r('y'), r('1')]
    # sort by the floating point ratio
    zz_sorted = sorted(zz, key = lambda item: item[0])

    zz_max = zz_sorted[-1]
    if zz_max[0] == zz_max[1]:
	# In this situation, the upper-bound zz_max[0] will never be reached
	# so we return the value - 1
	zz_max[1] = zz_max[1] - 1

    dict = {}
    for item in zz_sorted:
	dict[item[2]] = item[1]

    return [[dict['x'], dict['1']], [dict['xy'], dict['y']]]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"># Continued fraction arithmetic - scoring

def score(t: np.ndarray) -&gt; float:
    """
    A scoring function for the 2x2x2 tensor.

    A higher number means that the tensor is
    getting closer for a quotient to be determined
    """

    def r(label):
	numerator, denominator = tensor_ref(t, label)
	return math.floor(numerator/denominator)

    # number of zero in the denominator
    # a negative value means that the denominator can be made zero
    n_zero = np.count_nonzero(t[1]&lt;=0)
    if n_zero == 3 or n_zero == 4:
	# 0 can be removed in 2 moves
	return -2 
    elif n_zero == 2:
	if tensor_ref(t, 'f') == 0 and tensor_ref(t, 'h') == 0:
	    if r('xy') == r('y'):
		# 0 0
		# 2 2
		# after one step, in a good position
		return -0.5
	    else:
		# 0 0
		# 2 3
		# both zeros can be removed in one step
		return -1.0
	elif tensor_ref(t, 'h') == 0 and tensor_ref(t, 'g') == 0:
	    if r('xy') == r('x'):
		# 2 0
		# 2 0
		# in good position in one step
		return -0.5
	    else:
		# 2 0
		# 3 0
		# both zeroes can be remoevd in one step
		return -1
	else:
	    return -2
    elif n_zero == 1:
	if tensor_ref(t, 'e') == 0:
	    # 3 8
	    # 0 1
	    # takes 2 moves to remove 0
	    return -2.0
	elif tensor_ref(t, 'f') == 0:
	    if r('xy') == r('y'):
		# 0 x
		# 2 2
		# in good position in one step
		return -0.5
	    else:
		# 0 2
		# 3 4
		return -1.0
	elif tensor_ref(t, 'g') == 0:
	    if (r('xy') == r('x')):
		# 2 3
		# 2 0
		return -0.5
	    else:
		# 2 3
		# 3 0                
		return -1.0
	else:
	    if (r('xy') == r('x')) or (r('xy') == r('y')):
		# 2 0
		# 2 3
		return -0.5
	    else:
		return -1.0
    else: # no zereos in the denominator
	r_  = t_ratios(t)
	if r_[0][0] == r_[0][1] == r_[1][0] == r_[1][1]:
	    # the 4 ratios are all the same. This is the best situation
	    return 4.0
	elif (r_[0][0] == r_[1][0]) or (r_[1][0] == r_[1][1]):
	    # 3 1       1 2
	    # 3 2 or    3 3
	    return 1.0
	else:
	    return 0.0
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def ABQueue(a: Iterator[int], b: Iterator[int]) -&gt; Callable[[np.ndarray], Tuple[Optional[int], Optional[str]]]:
    """
    Return next term either from the first or the second continued fraction.

    The source is selected by the scoring function.

    :param a: The first continued fraction.
    :param b: The second continued fraction.
    :return: A closure. Give 2x2x2 tensor, return a new term, and the source.
    """
    current_a = None
    current_b = None
    last_tie = 'b'

    def ABQueue_(t: np.ndarray) -&gt; Tuple[Optional[int], Optional[str]]:
	nonlocal current_a
	nonlocal current_b
	nonlocal last_tie

	def dequeue(label: str) -&gt; Tuple[Optional[int], Optional[str]]:
	    nonlocal current_a
	    nonlocal current_b
	    nonlocal last_tie
	    assert label in ['a', 'b', 'alt']
	    if label == 'a':
		next_term = current_a
		current_a = None
		return next_term, 'a'
	    elif label == 'b':
		next_term = current_b
		current_b = None
		return next_term, 'b'
	    else:
		assert label == 'alt'
		if last_tie == 'a':
		    next_term = current_b
		    current_b = None
		    last_tie = 'b'
		    return next_term, 'b'
		else:
		    next_term = current_a
		    current_a = None
		    last_tie = 'a'
		    return next_term, 'a'

	if current_a is None:
	    current_a = next(a, None)
	if current_b is None:
	    current_b = next(b, None)

	if current_a is None and current_b is None:
	    # both a and b are empty
	    return None, None
	elif current_a is None:
	    # if a is empty, return b
	    return dequeue('b')
	elif current_b is None:
	    # if b is empty, return a
	    return dequeue('a')
	else:
	    t_a = apply_ab(t, current_a, 'a')
	    t_b = apply_ab(t, current_b, 'b')
	    s_a, s_b = score(t_a), score(t_b)
	    if s_a == s_b:
		return dequeue('alt')
	    if s_a &lt; s_b:
		return dequeue('b')
	    else:
		return dequeue('a')
    return ABQueue_
</pre>
</div>
</div>
</div>

<div id="outline-container-org14e9007" class="outline-2">
<h2 id="org14e9007"><span class="section-number-2">15</span> Appendix: Unit tests</h2>
<div class="outline-text-2" id="text-15">
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;TEST_IMPORTS&gt;&gt;
&lt;&lt;TEST_R2CF&gt;&gt;
&lt;&lt;TEST_QR_MATRIX&gt;&gt;
&lt;&lt;TEST_CONVERGENTS&gt;&gt;
&lt;&lt;TEST_CF2R&gt;&gt;
&lt;&lt;TEST_CF_TRANSFORM&gt;&gt;
&lt;&lt;TEST_BIHO&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-org6e1477a" class="outline-3">
<h3 id="org6e1477a"><span class="section-number-3">15.1</span> Using continued fractions to represent rational numbers</h3>
<div class="outline-text-3" id="text-15-1">
<div class="org-src-container">
<pre class="src src-python">class TestR2cf(object):
    def test_basic(self):
	res = r2cf(Rational(254, 100))
	assert list(res) == [2, 1, 1, 5, 1, 3]
</pre>
</div>
</div>
</div>

<div id="outline-container-org5411378" class="outline-3">
<h3 id="org5411378"><span class="section-number-3">15.2</span> Convergents</h3>
<div class="outline-text-3" id="text-15-2">
<div class="org-src-container">
<pre class="src src-python"># Apply this test to two functions, because they should be equivalent
@pytest.mark.parametrize('conv_func', [cf_convergents0, cf_convergents1])
def test_convergents_basci1(conv_func):
    lst = list(conv_func(iter([2, 1, 1, 5, 1, 3])))
    assert lst[0] == Rational(2, 1)
    assert lst[1] == Rational(3, 1)
    assert lst[2] == Rational(5, 2)
    assert lst[3] == Rational(28, 11)
    assert lst[4] == Rational(33, 13)
    assert lst[5] == Rational(127, 50)
    assert len(lst) == 6

# Apply this test to two functions, because they should be equivalent
@pytest.mark.parametrize('conv_func', [cf_convergents0, cf_convergents1])
def test_convergents_basic2(conv_func):
    lst = list(cf_convergents0(iter([1, 2, 3, 4, 5])))
    assert lst[0] == Rational(1, 1)
    assert lst[1] == Rational(3, 2)
    assert lst[2] == Rational(10, 7)
    assert lst[3] == Rational(43, 30)
    assert lst[4] == Rational(225, 157)
    assert len(lst) == 5
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"># cf2r0 and cf2r1 should be equivalent
@pytest.mark.parametrize('cf2r_func', [cf2r0, cf2r1])
def test_cf2r(cf2r_func):
    assert cf2r_func([2, 1, 1, 5, 1, 3]) == Rational(127, 50)
    assert cf2r_func([1, 2, 3, 4, 5]) == Rational(225, 157)
</pre>
</div>
</div>
</div>

<div id="outline-container-org06e7bef" class="outline-3">
<h3 id="org06e7bef"><span class="section-number-3">15.3</span> Symbolic Euclidean algorithm</h3>
<div class="outline-text-3" id="text-15-3">
<div class="org-src-container">
<pre class="src src-python">class TestQRMatrix(object):
    def qr(self, m):
	res = qr_matrix(np.array(m))
	if res is None:
	    return None
	else:
	    (q, r) = res
	    return q, r.tolist()

    def test_basic1(self):
	# (4x+2)/(3x+2) is between 4/2 and 2/2 (1 to 1.33)
	# increasing
	m = [[4, 2], [3, 2]]
	(q, r) = self.qr(m)
	assert q == 1 and r == [[3, 2], [1, 0]]

    def test_basic2(self):
	# (70x + 29)/ (12x + 5) is between 29/5 and 35/6 (5.8 to 5.88)
	# increasing. an example in the paper
	m = [[70, 29], [12, 5]]
	(q, r) = self.qr(m)
	assert q == 5 and r == [[12, 5], [10, 4]]

    def test_basic3(self):
	# (12x + 5) / (10 x + 4) is between 6/5 and 5/4 (1.2 to 1.25)
	# decreasing. an example in the paper
	m = [[12, 5], [10, 4]]
	(q, r) = self.qr(m)
	assert q == 1 and r == [[10, 4], [2, 1]]

    def test_edgecase1(self):
	# (10x + 4) / (2x + 1) is bounded between 4 and 5
	# the quotient is 4, because it is 5 only at infinity
	# increasing. an example in the paper
	m = [[10, 4], [2, 1]]
	(q, r) = self.qr(m)
	assert q == 4 and r == [[2, 1], [2, 0]]

    def test_edgecase2(self):
	# (8x + 3) / (2x + 1) is bounded between 3 and 4
	# it is only 4 if x is infinity, so the quotient has to be 3
	# increasing
	m = [[8, 3], [2, 1]]
	(q, r) = self.qr(m)
	assert q == 3 and r == [[2, 1], [2, 0]]

    def test_edgecase3(self):
	# (29x + 6) / (5x + 1) is bounded between 5.8 and 6
	# it is only 6 if x is 0, so the coefficient has to be 5
	# decreasing
	m = [[29, 6], [5, 1]]
	(q, r) = self.qr(m)
	assert q == 5 and r == [[5, 1], [4, 1]]

    def test_unbounded1(self):
	# 4x + 2 is unbounded
	m = [[4, 2], [0, 1]]
	(q, r) = self.qr(m)
	assert q is None

    def test_unbounded2(self):
	# (4x + 2) / 3 is unbounded
	m = [[4, 2], [3, 0]]
	(q, r) = self.qr(m)
	assert q is None

    def test_unbounded3(self):
	# 2x / (2x - 1) is unbounded, because there is a singularity at x = 1/2
	# This is in the paper
	m = [[2, 0], [2, -1]]
	(q, r) = self.qr(m)
	assert q is None

    def test_zero_coeff(self):
	# (1x + 2) / (2x + 3) is bounded between 1/2 and 2/3 (0.5 to 0.666)
	m = [[1, 2], [2, 3]]
	(q, r) = self.qr(m)
	assert q == 0 and r == [[2, 3], [1, 2]]

    def test_too_wide(self):
	# (7x + 5) / (x + 1) is bounded between 5 and 7. 
	m = [[7, 5], [1, 1]]
	(q, r) = self.qr(m)
	assert q is None
</pre>
</div>
</div>
</div>

<div id="outline-container-org912672f" class="outline-3">
<h3 id="org912672f"><span class="section-number-3">15.4</span> Transformations of continued fractions</h3>
<div class="outline-text-3" id="text-15-4">
<div class="org-src-container">
<pre class="src src-python">class TestCFTransform(object):
    def test_cf_transform_basic1(self):
	""" 2 * [2, 1, 1, 5, 1] == 66/13"""
	m0 = np.array([[2, 0], [0, 1]], int)
	cf1 = list(cf_transform(iter([2, 1, 1, 5, 1]), m0 = m0))
	cf2 = list(r2cf(Rational(66, 13)))
	assert cf1 == cf2

    def test_cf_transform_basic2(self):
	""" 1 / [2, 1, 1, 5, 1] == [0, 2, 1, 1, 5, 1]"""
	m0 = np.array([[0, 1], [1, 0]], int)
	cf1 = list(cf_transform(iter([2, 1, 1, 5, 1]), m0 = m0))
	cf2 = [0, 2, 1, 1, 5, 1]
	assert cf1 == cf2
</pre>
</div>
</div>
</div>

<div id="outline-container-org2481658" class="outline-3">
<h3 id="org2481658"><span class="section-number-3">15.5</span> Bihomography</h3>
<div class="outline-text-3" id="text-15-5">
<div class="org-src-container">
<pre class="src src-python">class TestBiho(object):
    def test_biho_basic1(self):
	(a, b, c, d, e, f, g, h) = (1, 2, 3, 4, 5, 6, 7, 8)
	m = np.array([[a, b, c, d], [e, f, g, h]])
	t = tFrom2x4(m)
	assert np.array_equal(t, np.array([[[b, d], [a, c]], [[f, h], [e, g]]]))

    def test_biho_basic2(self):
	(a, b, c, d, e, f, g, h) = (1, 2, 3, 4, 5, 6, 7, 8)
	m = np.array([[a, b, c, d], [e, f, g, h]])
	t = np.array([[[b, d], [a, c]], [[f, h], [e, g]]])
	assert np.array_equal(tTo2x4(t), m)
</pre>
</div>
</div>
</div>
<div id="outline-container-org6f67870" class="outline-3">
<h3 id="org6f67870"><span class="section-number-3">15.6</span> Imports</h3>
<div class="outline-text-3" id="text-15-6">
<div class="org-src-container">
<pre class="src src-python">import numpy as np
import pytest
from cont_frac import *
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org58b0963" class="outline-2">
<h2 id="org58b0963"><span class="section-number-2">16</span> Appendix: Display utilities</h2>
<div class="outline-text-2" id="text-16">
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;IO_IMPORTS&gt;&gt;
&lt;&lt;TAB_UTILS&gt;&gt;
&lt;&lt;TABS&gt;&gt;
&lt;&lt;TABS3D&gt;&gt;
&lt;&lt;MISC&gt;&gt;  
&lt;&lt;LATEX_UTILS&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-orgd896234" class="outline-3">
<h3 id="orgd896234"><span class="section-number-3">16.1</span> Tabulated display utilities</h3>
<div class="outline-text-3" id="text-16-1">
<p>
<code>Chart</code> is a class for constructing and exporting tabulated displays. It can be used for 2D (i.e., operations involving one continued fraction) or 3D (operations involving two continued fractions) displays. For 2D displayed, the homographic matrices are converted into bihomographic tensors.
</p>
<div class="org-src-container">
<pre class="src src-python"># Utilities for tabulated displays

class Chart(object):
    """Construction and export tabulated displays"""
    def __init__(self, m: np.ndarray = tForAddition):
	if len(m.shape) == 2:
	    # if initialized with a matrix intead of a tensor
	    self.include_b = False
	    self.mode2D = True
	    self.current_tensor = Chart.m2t(m)
	    self.boards = self.current_tensor.tolist()
	else:
	    self.boards = m.tolist()
	    self.include_b = True
	    self.mode2D = False
	    self.current_tensor = m.copy()

	self.output: List[Optional[int]] = [None]
	self.a: List = []
	self.b: List = [[]]
	self.include_a = True
	self.include_out = True

    @staticmethod
    def m2t(m: np.ndarray) -&gt; np.ndarray:
	"""Convert a homographic matrix into a bihomographic tensor"""
	return np.array([[[m[0,0], m[0,1]], [0, 0]], [[m[1,0], m[1,1]], [0, 0]]])

    &lt;&lt;ACCEPT_INPUT&gt;&gt;
    &lt;&lt;PROCESS_OUTPUT&gt;&gt;
    &lt;&lt;MAKE_ARRAY&gt;&gt;
    &lt;&lt;DISPLAY_EXPORT&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-org9bf1827" class="outline-4">
<h4 id="org9bf1827"><span class="section-number-4">16.1.1</span> Take inputs from continued fractions</h4>
<div class="outline-text-4" id="text-16-1-1">
<div class="org-src-container">
<pre class="src src-python">def move_left(self, t: np.ndarray, a: int):
    """t is the matrix or tensor after a new term of a"""
    if len(t.shape)==2 and self.mode2D:
	t2 = Chart.m2t(t)
    else:
	t2 = t

    assert tensor_ref(t2, 'y') == tensor_ref(self.current_tensor, 'xy')
    assert tensor_ref(t2, '1') == tensor_ref(self.current_tensor, 'x')
    self.current_tensor = t2

    # add a new column for all boards
    for i in range(len(self.boards)):
	for j in range(len(self.boards[0])):
	    self.boards[i][j] = [None] + self.boards[i][j]

    self.boards[-2][-2][0] = tensor_ref(t2, 'b')
    self.boards[-2][-1][0] = tensor_ref(t2, 'a')
    self.boards[-1][-2][0] = tensor_ref(t2, 'f')
    self.boards[-1][-1][0] = tensor_ref(t2, 'e')
    self.a = [a] + self.a

def move_down(self, t: np.ndarray, b: int):
    """t is the matrix or tensor after a new term of b"""
    assert tensor_ref(t, 'x') == tensor_ref(self.current_tensor, 'xy')
    assert tensor_ref(t, '1') == tensor_ref(self.current_tensor, 'y')
    self.current_tensor = t
    new_row_numerator   = [None] * len(self.boards[0][0])
    new_row_denominator = [None] * len(self.boards[1][0])
    new_row_numerator[0] = tensor_ref(t, 'a') # type: ignore
    new_row_numerator[1] = tensor_ref(t, 'c') # type: ignore
    new_row_denominator[0] = tensor_ref(t, 'e') # type: ignore
    new_row_denominator[1] = tensor_ref(t, 'g') # type: ignore
    self.boards[-2] = self.boards[-2] + [new_row_numerator]
    self.boards[-1] = self.boards[-1] + [new_row_denominator]
    self.b[-1] = self.b[-1] + [b]

    # all boards under have to be expanded
    for i in range(0, len(self.boards)-2):
	self.boards[i] = self.boards[i] + [[None] * len(new_row_numerator)]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd88c654" class="outline-4">
<h4 id="orgd88c654"><span class="section-number-4">16.1.2</span> Process output</h4>
<div class="outline-text-4" id="text-16-1-2">
<p>
After an Euclidean step, we "move under" by creating a new board.
</p>
<div class="org-src-container">
<pre class="src src-python">def move_under(self, t: np.ndarray, output: int):
    """
    t is the matrix or tensor after a Euclidean step.
    output is the quotient
    """
    if len(t.shape)==2 and self.mode2D:
	t2 = Chart.m2t(t)
    else:
	t2 = t

    assert tensor_ref(self.current_tensor, 'f') == tensor_ref(t2, 'b')
    assert tensor_ref(self.current_tensor, 'h') == tensor_ref(t2, 'd')
    assert tensor_ref(self.current_tensor, 'e') == tensor_ref(t2, 'a')
    assert tensor_ref(self.current_tensor, 'g') == tensor_ref(t2, 'c')
    self.current_tensor = t2

    n_rows = len(self.boards[0])
    n_cols = len(self.boards[0][0])
    def new_row():
	return [None] * n_cols
    new_boards = [new_row() for i in range(n_rows)]

    new_boards[-2][0] = tensor_ref(t2, 'f')
    new_boards[-2][1] = tensor_ref(t2, 'h')
    new_boards[-1][0] = tensor_ref(t2, 'e')
    new_boards[-1][1] = tensor_ref(t2, 'g')
    self.boards = self.boards + [new_boards]

    new_b = [None] * len(self.b[-1])
    self.b = self.b + [new_b]

    self.output = self.output + [output]
</pre>
</div>
</div>
</div>

<div id="outline-container-org1f93994" class="outline-4">
<h4 id="org1f93994"><span class="section-number-4">16.1.3</span> Convert to array</h4>
<div class="outline-text-4" id="text-16-1-3">
<div class="org-src-container">
<pre class="src src-python">def board_to_array(self, board: List, b: List, out: Optional[int], truncate_board = False) -&gt; List:
    new_content: List[List[Optional[int]]] = []
    for i, row in enumerate(board):
	skip = False
	if self.mode2D and i%2==1:
	    skip = True

	if truncate_board:
	    if row.count(None) == len(row):
		skip = True

	if not skip:
	    new_row = row.copy()

	    if self.include_b:
		if i == 0:
		    new_row = new_row + [None]
		elif b is None:
		    new_row = new_row + [None]
		elif i &lt;= len(b):
		    new_row = new_row + [b[i-1]]
		else:
		    new_row = new_row + [None]

	    if self.include_out:
		if i == len(board) - 2:
		    new_row = new_row + [out]
		else:
		    new_row = new_row + [None]

	    new_content = new_content + [new_row]
    return new_content

def to_array(self, truncate_board = False) -&gt; list:
    content: List[List] = []
    row: List[Optional[int]] = []
    n_cols = len(self.boards[0][0])

    if self.include_a:
	row = row + [None]
	if self.include_b:
	    row = row + [None]
	if self.include_out:
	    row = row + [None]
	row = self.a + row
	row = [None] * (n_cols - len(self.a) - 1) + row # type: ignore
	content = content + [row]

    for i in range(len(self.boards)):
	board = self.boards[i]
	b = self.b[i] if i&lt;len(self.b) else None
	out = self.output[i] if i&lt;len(self.output) else None
	content = content + self.board_to_array(board, b, out, truncate_board = truncate_board)

    return content
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd7eb9b2" class="outline-4">
<h4 id="orgd7eb9b2"><span class="section-number-4">16.1.4</span> Display/export</h4>
<div class="outline-text-4" id="text-16-1-4">
<div class="org-src-container">
<pre class="src src-python">@staticmethod
def pp_item(item: int, field_width: int) -&gt; str:
    if item is None:
	return " " * field_width
    else:
	return f"{item : &gt; {field_width}}"

@staticmethod
def pp_row(row: list, field_width: int) -&gt; str:
    return reduce(lambda s, item: s + Chart.pp_item(item, field_width), row, "") + "\n"

def __repr__(self) -&gt; str:
    content = self.to_array(truncate_board = True)

    content_nonone = [[c for c in row if c is not None] for row in content]
    content_nonone = [r for r in content_nonone if r != []]
    mx = max(map(max, content_nonone))
    field_width = len(str(mx)) + 1

    s = reduce(lambda s, r: s + Chart.pp_row(r, field_width), content, "")
    return s

def export_csv(self, filename: str, truncate_board = False):
    content = self.to_array(truncate_board = truncate_board)
    with open(filename, mode = 'w') as outfile:
	writer = csv.writer(outfile)
	writer.writerows(content)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org3fe5b4b" class="outline-3">
<h3 id="org3fe5b4b"><span class="section-number-3">16.2</span> Tabulated displays: 2D</h3>
<div class="outline-text-3" id="text-16-2">
<div class="org-src-container">
<pre class="src src-python"># Tabulated displays: 2D

def r2cf_tab(rn: Rational) -&gt; str:
    """
    Show the prpocess of converting a rational numner
    to a continued fraction
    """
    def row(st: str, x: tuple):
	b, q = x
	return st + f"{b : &gt; 5}  {q : &lt; 5}\n"
    str0 = f"{rn.a : &gt; 5}\n"
    return reduce(row, r2cf_(rn), str0) + f"{0 : &gt; 5}\n"
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def cf_convergents1_tab(cf: Iterator[int]) -&gt; Chart:
    """
    Show the process of converting a continued fraction
    to a rational number
    """
    chart = Chart(m = np.identity(2, int))
    chart.include_out = False
    (cf1, cf2) = tee(cf)
    for (mat, a) in zip(cf_convergents1_(cf1), cf2):
	chart.move_left(mat, a)
    return chart
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def euclid_matrix_tab(m: np.ndarray) -&gt; Chart:
    """Show the matrix form of the Euclidean algorithm"""
    chart = Chart(m = m)
    for (q, r) in euclid_matrix_(m):
	chart.move_under(r, q)
    return chart
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def cf_transform_tab(cf: Iterator[int], m0 = np.identity(2, int)) -&gt; Chart:
    """Show the process of operating on a continued fraction.
    Make sure that cf has finite number of terms
    """
    chart = Chart(m = m0)
    res = cf_transform_(cf, m0)

    for (q, r, m, a, new_a) in res:
	if new_a:
	    chart.move_left(m, a)
	if q is None:
	    # this means that no euclid step was performed
	    # do nothing
	    pass
	else:
	    if r is not None:
		chart.move_under(r, q)
	    else:
		# r is None; the quotients are for rational numbers
		# rather than matrices
		chart.output = chart.output + [q]
    return chart
</pre>
</div>
</div>
</div>

<div id="outline-container-org38462fa" class="outline-3">
<h3 id="org38462fa"><span class="section-number-3">16.3</span> Tabulated displays: 3D</h3>
<div class="outline-text-3" id="text-16-3">
<div class="org-src-container">
<pre class="src src-python"># Tabulated displays: 3D

def arithmetic_convergents_tab(a: Iterator[int], b: Iterator[int], t0: np.ndarray = tForAddition) -&gt; Chart:
    """
    Show the process of calculating the convergents of
    arithmetical operations
    """
    c = Chart(t0)
    c.include_out = False
    for direction, coefficient, t in arithmetic_convergents_(a, b, t0):
	if direction == 'a':
	    c.move_left(t, coefficient)
	else:
	    c.move_down(t, coefficient)
    return c
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def euclid_tensor_tab(t):
    c = Chart(t)
    c.include_a = False
    c.include_b = False
    res = euclid_tensor_(t)
    for (q, r) in res:
	c.move_under(r, q)
    return c
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def cf_arithmetic_tab(cf_a, cf_b, t0):
    chart = Chart(m = t0)
    chart.include_a = True
    chart.include_b = True
    chart.include_out = True
    res = cf_arithmetic_(cf_a, cf_b, t0)

    for (q, r, t, term, label, new_term) in res:
	if new_term:
	    if label == 'a':
		chart.move_left(t, term)
	    else:
		assert label == 'b'
		chart.move_down(t, term)
	if q is None:
	    # this means that no Euclidean step was performed
	    # do nothing
	    pass
	else:
	    if r is not None:
		chart.move_under(r, q)
	    else:
		chart.output = chart.output + [q]
    return chart
</pre>
</div>
</div>
</div>

<div id="outline-container-org6bfff74" class="outline-3">
<h3 id="org6bfff74"><span class="section-number-3">16.4</span> Pretty printing utilities</h3>
<div class="outline-text-3" id="text-16-4">
<div class="org-src-container">
<pre class="src src-python"># Pretty printing utilities

def pp_qr(qr: Tuple[int, np.ndarray]) -&gt; None:
    '''Pretty print a tuple of a quotient and a remainder matrix'''
    q, r = qr
    print(f"{q:&gt;2} {r[0][0]:2} {r[0][1]:2}")
    print(f"   {r[1][0]:2} {r[1][1]:2}")
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def pp_inf_cf(cf: list) -&gt; str:
    """
    Pretty print a list representing the first couple terms of
    a longer continued fraction
    """
    res = "["
    res = res + reduce(lambda s, n: s + str(n) + ",", cf, "")
    res = res[:-1] + "...]"
    return res
</pre>
</div>
</div>
</div>

<div id="outline-container-org402a420" class="outline-3">
<h3 id="org402a420"><span class="section-number-3">16.5</span> LaTeX utilities</h3>
<div class="outline-text-3" id="text-16-5">
<div class="org-src-container">
<pre class="src src-python"># Utilities functions for LaTeX displays

def latex_cf(lst: list) -&gt; str:
    if len(lst) == 1:
	return str(lst[0])
    else:
	x = str(lst[0]) + "+"
	x = x + r"\frac{1}{" + latex_cf(lst[1:]) + "}"
	return x

def latex_rational(r: Rational) -&gt; str:
    return r"\frac{" + str(r.a) + "}{" + str(r.b) + "}"

def show_cf_expansion(r: Rational):
    print(r"\[")
    print(r"\frac{", r.a, "}{", r.b, "}=")
    nc = list(r2cf(r))
    print(latex_cf(nc))
    print(r"\]")

def show_rational_series(itr: Iterator[int]):
    rLst = list(cf_convergents0(itr))
    s = ""
    for r in rLst:
	s = s + "$" + latex_rational(r) + "$" + ","

    print(s[:-1])
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc9d9df2" class="outline-3">
<h3 id="orgc9d9df2"><span class="section-number-3">16.6</span> Imports</h3>
<div class="outline-text-3" id="text-16-6">
<div class="org-src-container">
<pre class="src src-python">from cont_frac import *
from typing import List
from functools import reduce
from itertools import tee
import csv
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org056b444" class="outline-2">
<h2 id="org056b444"><span class="section-number-2">17</span> Appendix: Imports and outlines</h2>
<div class="outline-text-2" id="text-17">
<p>
This is the outline of the main code <code>cont_frac.py</code>.
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;IMPORTS&gt;&gt;
&lt;&lt;RATIONAL_NUM&gt;&gt;
&lt;&lt;R2CF&gt;&gt;
&lt;&lt;CONVERGENTS0&gt;&gt;
&lt;&lt;CONVERGENTS1&gt;&gt;
&lt;&lt;QR_MATRIX&gt;&gt;
&lt;&lt;CF_TRANSFORM&gt;&gt;
&lt;&lt;BIHOMOGRAPHY&gt;&gt;  
&lt;&lt;QR_TENSOR&gt;&gt;
&lt;&lt;ARITHMETIC&gt;&gt;
&lt;&lt;CF_EXAMPLES&gt;&gt;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">def cf_pi():
    return iter([3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2, 2, 2])
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">import math
import numpy as np
from typing import NamedTuple, Iterator, Tuple, Optional, Callable, Union, List
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">from cont_frac import *
from cont_frac_io import *
from itertools import islice
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hsin-Hao Yu</p>
<p class="date">Created: 2022-05-02 Mon 00:53</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
