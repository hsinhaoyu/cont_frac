#+EXPORT_FILE_NAME: ../html/cont_frac.html
#+OPTIONS: broken-links:t
#+HTML_MATHJAX: align: left
#+HTML_MATHJAX: scale: 85
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
#+TITLE: Understanding Bill Gospher's continued fraction arithmetic (implemented in Python)

#+begin_src python :noweb no-export :tangle ../src/cont_frac.py
  <<IMPORTS>>
  <<RATIONAL_NUM>>
  <<R2CF>>
  <<CONVERGENTS0>>
  <<CONVERGENTS1>>
  <<QR_MATRIX>>
  <<CF_TRANSFORM>>
#+end_src

* Representing rational numbers as continued fractions
Since we'll use rational numbers a lot, let's define a class:
#+begin_src python :tangle no :noweb-ref RATIONAL_NUM
  # Rational(a, b) = a/b
  class Rational(NamedTuple('Rational', [('a', int), ('b', int)])):
      def __repr__(self):
          return f'{self.a}/{self.b}'
#+end_src

How to convert a rational number to a continued fraction? Observing that

\[
\frac{254}{100}
= 2 + \frac{54}{100}
= 2 + \frac{1}{\frac{100}{54}}
= 2 + \frac{1}{1 + \frac{46}{54}}
= 2 + \frac{1}{1 + \frac{1}{\frac{46}{54}}}
\]

it should be obvious that the solution is just the [[https://en.wikipedia.org/wiki/Euclidean_algorithm][Euclidean algorithm]] for finding the greatest common divider:
#+begin_src python :tangle no :noweb-ref R2CF
  # Convert a rational number to a continued fraction
  
  def qr(a: int, b: int) -> Tuple[int, int]:
      """a = b * q + r, return (q, r)"""
      q = math.floor(a / b)  # the quotient
      r = a - b * q          # the reminder
      return (q, r)

  def r2cf_(rn: Rational) -> Iterator[Tuple[int, int]]:
      a, b = rn    
      while True:
          q, r = qr(a, b)
          yield b, q
          if r == 0:
              break
          a, b = b, r

  def r2cf(rn: Rational) -> Iterator[int]:
      def second(x: tuple):
          return x[1]
      return map(second, r2cf_(rn))
#+end_src

Now we can use =r2cf= to convert a rational number into a continued fraction. In this article, continued fractions are represented by Python generators, because they can have infinite number of terms. However, the generators returned by =r2cf= are finite iterators because the continued fractions associated with rational numbers always have finite numbers of coefficients.
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  nc = r2cf(Rational(254, 100))
  print(list(nc))
#+end_src

#+RESULTS:
: [2, 1, 1, 5, 1, 3]

This means that
#+begin_src python :exports none :noweb no-export :results output raw :dir ../src/
  <<DEMO_IMPORTS>>
  <<LATEX_UTILS>>
  show_cf_expansion(Rational(254, 100))
#+end_src

#+RESULTS:
\[
\frac{ 254 }{ 100 }=
2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}
\]

We can display the process in a tabular format. For example:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(r2cf_tab(Rational(254, 100)))
#+end_src

#+RESULTS:
:   254
:   100   2   
:    54   1   
:    46   1   
:     8   5   
:     6   1   
:     2   3   
:     0
: 

This table shows that 2 (the penultimate row) is the greatest common divider of 254 and 100. As a byproduct of this process, we also get the coefficients of the corresponding continued fraction, which are the quotients displayed on the right.

Interestingly, the reciprocal of $\frac{254}{100}$ (that is, $\frac{100}{254}$) is represented by the following as a continued fraction:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  nc = r2cf(Rational(100, 254))
  print(list(nc))
#+end_src

#+RESULTS:
: [0, 2, 1, 1, 5, 1, 3]

It's the same sequence with an additional 0 at the beginning! This is our first clue that a continued fraction can be transformed by performing some operations at the beginning of the Euclidean algorithm. We'll come back to this point later.

*  Calculating the convergents of a continued fraction
Given a continued fraction, how do we calculate its value? If the series is finite, we can easily write a recursive function. However, if it's an infinite series, we need a method to incrementally approximate the value as more coefficients are received. Also, we want the evaluation to be accumulative, so that each update is based on the previous one.

This question has an easy solution if we use a series of rational numbers to approximate the continued fraction. Each term in the series is called a convergent. The formula for the convergents can be derived easily with mathematical induction, and it is implemented below. For the moment, we'll use the formula just a convenience to get the job done. We'll get deeper into its meaning in the next section.
#+begin_src python :tangle no :noweb-ref CONVERGENTS0
  # Calculate the convergents of a continued fraction
  
  def cf_convergents0(cf: Iterator[int]) -> Iterator[Rational]:
      """For a continued fraction cf, return an iterator of rational numbers to approximate it""" 
      p1, p0 = 1, 0
      q1, q0 = 0, 1

      for a in cf:
          p = a * p1 + p0
          q = a * q1 + q0
          yield Rational(p, q)

          p0, p1 = p1, p
          q0, q1 = q1, q
#+end_src

For example, for the continued fraction $[2, 1, 1, 5, 1, 3]$, we get
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_convergents0(iter([2, 1, 1, 5, 1, 3]))))
#+end_src

#+RESULTS:
: [2/1, 3/1, 5/2, 28/11, 33/13, 127/50]

In other words, 
#+begin_src python :exports none :noweb no-export :results output raw :dir ../src/
  <<LATEX_UTILS>>
  print("$" + latex_cf([2, 1, 1, 5, 1, 3]) + "$")
#+end_src

#+RESULTS:
$2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}$
can be approximated with
#+begin_src python :exports none :noweb no-export :results output raw :dir ../src/
  <<DEMO_IMPORTS>>
  <<LATEX_UTILS>>
  show_rational_series(iter([2, 1, 1, 5, 1, 3]))
#+end_src

#+RESULTS:
$\frac{2}{1}$,$\frac{3}{1}$,$\frac{5}{2}$,$\frac{28}{11}$,$\frac{33}{13}$,$\frac{127}{50}$
.

For convenience, we define a specialized version of =cf_convergents0= just for finite-term continued fractions. It returns the rational number corresponding to the continued fraction:
#+begin_src python :tangle no :noweb-ref CONVERGENTS0
  def cf2r0(cf: Iterator[int]) -> Rational:
      """Given a finite-term continued fraction, return its value as a rational number.
      This function will get into an infinite loop if the iterator doesn't stop.
      """
      return list(cf_convergents0(cf))[-1]
#+end_src

#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(cf2r0(iter([2, 1, 1, 5, 1, 3])))
#+end_src

#+RESULTS:
: 127/50

* Continued fraction approximation as function compositions
#+INCLUDE: functional_convergents.org

* Calculating convergents using the matrix notation
Now, we are ready to rewrite the formula in =cf_convergents0= as matrix multiplications:
#+begin_src python :tangle no :noweb-ref CONVERGENTS1
  def h(a):
      return np.array([[a, 1], [1,0]])

  def cf_convergents1_(cf: Iterator[int]) -> Iterator:
      res = np.array([[1, 0], [0, 1]])
      for a in cf:
          res = np.matmul(res, h(a))
          yield res

  def cf_convergents1(cf: Iterator[int]) -> Iterator[Rational]:
      mLst = cf_convergents1_(cf)
      for m in mLst:
          yield Rational(m[0, 0], m[1, 0])
#+end_src

Let's try it on the example given in the previous section:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_convergents1(iter([5, 1, 4]))))
#+end_src

#+RESULTS:
: [5/1, 6/1, 29/5]

Here's a longer sequence that we used previously:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_convergents1(iter([2, 1, 1, 5, 1, 3]))))
#+end_src

#+RESULTS:
: [2/1, 3/1, 5/2, 28/11, 33/13, 127/50]

A very charming thing that Gosper did was that he used a compact tabulated format to illustrate the process. It's unnecessary for the computation, but I think it looks pretty cool:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  cf_convergents1_tab(iter([5, 1, 4]))
#+end_src

#+RESULTS:
:        4   1   5    
:   29   6   5   1   0
:    5   1   1   0   1

This table is read from the right to the left. The right-to-left direction takes some getting used to, but it's needed to preserve the normal representation of matrices.

The first row represents the coefficients of the continued fraction. To understand the other numbers, we calculate the matrices for each additional coefficient in the continued fraction:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  itr = cf_convergents1_(iter([5, 1, 4]))
  print(next(itr),"\n")
  print(next(itr),"\n")
  print(next(itr))
#+end_src

#+RESULTS:
: [[5 1]
:  [1 0]] 
: 
: [[6 5]
:  [1 1]] 
: 
: [[29  6]
:  [ 5  1]]

You can see these matrices shift leftwards in the tabular representation, with adjacent matrices sharing a column. To see why, suppose that the current matrix is
$\begin{bmatrix}
    x_{11} & x_{12} \\
    x_{21} & x_{22}
\end{bmatrix}$, and we have to update it with a new term $a$ in the continued fraction. The updated matrix is
\begin{equation*}
    \begin{bmatrix}
        x_{11} & x_{12} \\
        x_{21} & x_{22}
    \end{bmatrix}
    \begin{bmatrix}
        a & 1 \\
        1 & 0
    \end{bmatrix} =
    \begin{bmatrix}
        ax_{11} & x_{11} \\
        ax_{21} & x_{21}
    \end{bmatrix}
\end{equation*}

This explains the shift, and we have recovered the formula in =cf_convergents0=.

Here's a longer series:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  cf_convergents1_tab(iter([2, 1, 1, 5, 1, 3]))
#+end_src

#+RESULTS:
:        3   1   5   1   1   2    
:  127  33  28   5   3   2   1   0
:   50  13  11   2   1   1   0   1

As before, we define a specialized version of =cf_convergents1= just for finite-term continued fractions. 
#+begin_src python :tangle no :noweb-ref CONVERGENTS1
  def cf2r1(cf: Iterator[int]) -> Rational:
      """Given a finite-term continued fraction, return its value as a rational number.
      This function will get into an infinite loop if the iterator doesn't stop.
      """
      return list(cf_convergents1(cf))[-1]
#+end_src

* Turning convergents into continued fractions
What if we want to calculate the convergents using the same process in =cf_convergent1=, but we want the output to be in the form of a continued fraction? At this point, this seems to be a pointless exercise, because a continued fraction is what we start with! But it will become useful in the coming sections.

Let's take the continued fraction $[5, 1, 4... ]$ as an example. Since we already know that the third convergent of $[5, 1, 4]$ is $\frac{29}{5}$, can't we just turn $\frac{29}{5}$ into a continued fraction? Remember that the third convergent of the infinite series $[5, 1, 4... ]$ is
$\begin{bmatrix}
    29 & 6 \\
     5 & 1
\end{bmatrix}$, which represents the function $\frac{29x + 6}{5x + 1}$. This is not the same as the third convergent of the finite series $[5, 1, 4]$, which is the rational number $\frac{29}{5}$.

So what do we do? It's still the Euclidean algorithm, but have to use it symbolically rather than numerically.

The most important step in the Euclidean algorithm is to express a number in terms of the quotient and the reminder of another number (see =qr()= in =euclid_=). I implemented the symbolic version of this operation in a function called =qr_matrix= in the Appendix. Consider the second convergent of $[5, 1, 4...]$, we use =qr_matrix= to calculate the quotient and the reminder:

#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(qr_matrix(np.array([[6, 5], [1, 1]])))
#+end_src

#+RESULTS:
: (5, array([[1, 1],
:        [1, 0]]))

This means that $f_2(x) = \frac{6x+5}{1x+1} = 5 + \frac{1}{\frac{1x + 1}{x}}$. Sine $\lim_{x \to 0} f_2(x) = 5$ and $\lim_{x \to \infty} f_2(x) = 6$, the function is bounded by $5 \leq f_2(x) < 6$. The quotient has to be 5, because the function is 6 only at infinity. 

Let's try another example: The 3rd convergent of the series is
$\begin{bmatrix}
    29 & 6 \\
     5 & 1
\end{bmatrix}$.

#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(qr_matrix(np.array([[29, 6], [5, 1]])))
#+end_src

#+RESULTS:
: None

Why does =qr_matrix= returns None? Calculus shows that the function is bounded $5.8 < f_3(x) \leq 6$. It's similar to the previous example, but in this case, the bounds are not tight enough to decide if the quotient is 5 or 6. That's why =qr_matrix= returns =None=, indicating that we have to wait for further information to resolve the quotient.

Note that we can't pick the smaller number 5, and pass the error to the next term. This is because for any rational number, the coefficients of the corresponding continued fraction is unique. We therefore have to get the coefficient 100% right before we move on to the next one.

Now we are ready to implement the symbolic form of the Euclidean algorithm:
#+begin_src python :tangle no :noweb-ref CF_TRANSFORM
  def euclid_matrix_(m):
      while True:
          res = qr_matrix(m)
          if res:
              q, r = res
              yield q, r
              m = r
          else:
              break
#+end_src

Let's try it on
$\begin{bmatrix}
    70 & 29 \\
    12 & 5
\end{bmatrix}$

#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  q = euclid_matrix_(np.array([[70, 29], [12, 5]]))
  for (r, m) in q:
      print(r, m)
#+end_src

#+RESULTS:
: 5 [[12  5]
:  [10  4]]
: 1 [[10  4]
:  [ 2  1]]
: 4 [[2 1]
:  [2 0]]

So there is enough information in $\frac{70x+29}{12x+5}$ to precisely determine 3 coefficients. 

As before, Gospher stacked the matrices in a compact format to illustrate the process:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  q = euclid_matrix_tab(np.array([[70, 29], [12, 5]]))
  print(q)
#+end_src

#+RESULTS:
:   70  29
:   12   5  5
:   10   4  1
:    2   1  4
:    2   0
:

Now, we can combine convergent calculation with the symbolic Euclidean algorithm:
#+begin_src python :tangle no :noweb-ref CF_TRANSFORM
  def cf_convergent2_(cf: Iterator[int], m0 = np.identity(2, int)) -> Iterator:
      m = m0
      for a in cf:
          m = np.matmul(m, h(a))
          q = -1
          for (q, r) in euclid_matrix_(m):
              yield q, r, m
              m = r
          if q == -1:
              # for this coefficient a, the convergent cannot be turned into a continued fraction
              yield (None, None, m)

      # we will only reach this point if the series is finite
      for s in euclid(Rational(m[0][0], m[1][0])):
          yield s, None, m

  def cf_convergent2(cf: Iterator[int], m0 = np.identity(2, int)) -> Iterator:
      for res in cf_convergent2_(cf, m0):
          if res:
              (q, r, m) = res
              if q is not None:
                  # cf_convergent2_ can return None to indicate that it needs more coefficients
                  # to continue. It can be ignored
                  yield q
#+end_src

Run it on a sequence, and it just returns the same sequence. 
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_convergent2(iter([2, 1, 1, 5, 1, 3]))))
#+end_src

#+RESULTS:
: [2, 1, 1, 5, 1, 3]

That seems to be anti-climatic for quite a bit of work... but here's something cool. Gospher combined the two stacked matrix representations that we have seen, to illustrate every step in the algorithm:

#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  cf_convergent2_tab(iter([2, 1, 1, 5, 1, 3]), field_width = 3)
#+end_src

#+RESULTS:
:      3  1  5  1  1  2   
:               3  2  1  0   
:            2  1  1  0  1  2 
:         6  1  1  0        1 
:      6  5  1  0           1 
:   4  1  1  0              5 
:   3  1  0                 1 
:   1  0                  

The numbers on the right are the outputs of =cf_convergent2=.

* Simple transformations of continued fractions
In the previous section, we start with a continued fraction $a$ represented as $[a_1, a_2, ...]$, and use matrix multiplication to calculate an rational series to approximate it. What if $a$ is embedded in another expression? Let $b=2a$.

#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_convergent1(iter([2, 1, 1, 5, 1])))[-1])
  print(list(euclid(Rational(66, 13))))
  print()
  print(euclid_tab(Rational(66, 13)))
#+end_src

#+RESULTS:
: 33/13
: [5, 13]
: 
:    66
:    13   5   
:     1   13  
:     0
: 

#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  m0 = np.array([[2, 0], [0, 1]], int)
  cd = cf_convergent2(iter([2, 1, 1, 5, 1]), m0 = m0)
  print(list(cd))
  print()
  cf_convergent2_tab(iter([2, 1, 1, 5, 1]), m0 = m0, field_width = 3)
#+end_src

#+RESULTS:
: [5, 13]
: 
:      1  5  1  1  2   
:     56 10  6  4  2  0   
:  13 11  2  1  1  0  1  5 
:   1  1  0            

#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  m0 = np.array([[0, 1], [1, 0]], int)
  cd = cf_convergent2(iter([2, 1, 1, 5, 1]), m0 = m0)
  print(list(cd))
  print()
  cf_convergent2_tab(iter([2, 1, 1, 5, 1]), m0 = m0, field_width = 3)
#+end_src

#+RESULTS:
#+begin_example
[0, 2, 1, 1, 5, 1]

     1  5  1  1  2   
              1  0  1   
           3  2  1  0  0 
        2  1  1  0     2 
     6  1  1  0        1 
  6  5  1  0           1 
  1  1  0              5 
  1  0               
#+end_example

* Appendix 1: Calculating the quotient and the reminder of a convergent in matrix form
This is just calculus

#+begin_src python :tangle no :noweb-ref QR_MATRIX
  # Calculate the quotient and reminder of a 2-by-2 matrix

  flip_m = np.array([[0, 1], [1, 0]])

  def qr_matrix(m):
      m2 = m.copy()

      if m2[1][0] !=0 and m2[1][1] !=0:
          d0 = math.floor(m[0][0] / m[1][0])
          d1 = math.floor(m[0][1] / m[1][1])

          # the quotient is between d0 and d1 (inclusive)
          (d0, d1) = sorted([d0, d1])
          if d0 == d1:
              # if d1 and d2 are the same, the coefficient is determined
              # calculate the remain, and flip the matrix
              r = m2[0] - m2[1] * d0
              m2[0] = r
              m2 = np.matmul(flip_m, m2)
              return d1, m2
          elif d1 == d0 + 1:
              # if d1 is d0 + 1, there is a situation where coefficient can be determined
              r = m2[0] - m2[1] * d1
              if r[1] < 0:
                  # this means d1 doesn't work, try d0
                  r = m2[0] - m2[1] * d0
                  if d0 < 0:
                      return None
                  else:
                      m2[0] = r
                      m2 = np.matmul(flip_m, m2)
                      return d0, m2
              else:
                 # cannot rule out d1
                 return None
          else:
              # the range is too big, so the coefficient cannot be determined
              return None
      else:
          # coefficient cannot be determined for unbounded function
          return None
#+end_src

#+begin_src python :noweb no-export :tangle ../src/test_cont_frac.py
  <<TEST_IMPORTS>>

  class TestQRMatrix(object):
      def qr(self, m):
          res = qr_matrix(np.array(m))
          if res is None:
              return None
          else:
              (q, r) = res
              return q, r.tolist()

      def test_basic1(self):
          # (4x+2)/(3x+2) is between 4/2 and 2/2 (1 to 1.33)
          m = [[4, 2], [3, 2]]
          (q, r) = self.qr(m)
          assert q == 1 and r == [[3, 2], [1, 0]]

      def test_basic2(self):
          # (70x + 29)/ (12x + 5) is between 29/5 and 35/6 (5.8 to 5.88)
          m = [[70, 29], [12, 5]]
          (q, r) = self.qr(m)
          assert q == 5 and r == [[12, 5], [10, 4]]

      def test_basic3(self):
          # (12x + 5) / (10 x + 4) is between 6/5 and 5/4 (1.2 to 1.25)
          m = [[12, 5], [10, 4]]
          (q, r) = self.qr(m)
          assert q == 1 and r == [[10, 4], [2, 1]]

      def test_negative1(self):
          # (10x + 4) / (2x + 1) is bounded between 4 and 5
          # the quotient is 4, because it is 5 only at infinity
          m = [[10, 4], [2, 1]]
          (q, r) = self.qr(m)
          assert q == 4 and r == [[2, 1], [2, 0]]

      def test_negative2(self):
          # (8x + 3) / (2x + 1) is bounded between 3 and 4
          # it is only 4 if x is infinity, so the coefficient has to be 3
          m = [[8, 3], [2, 1]]
          (q, r) = self.qr(m)
          assert q == 3 and r == [[2, 1], [2, 0]]

      def test_divergent1(self):
          # 4x + 2 is unbounded
          m = [[4, 2], [0, 1]]
          res = self.qr(m)
          assert res is None

      def test_divergent2(self):
          # (4x + 2) / 3 is unbounded
          m = [[4, 2], [3, 0]]
          res = self.qr(m)
          assert res is None

      def test_zero_coeff(self):
          # (1x + 2) / (2x + 3) is bounded between 1/2 and 2/3 (0.5 to 0.666)
          m = [[1, 2], [2, 3]]
          (q, r) = self.qr(m)
          assert q == 0 and r == [[2, 3], [1, 2]]
#+end_src

* Appendix: Additional tests
#+begin_src python :noweb yes :tangle ../src/test_cont_frac.py
  class TestR2cf(object):
      def test_basic(self):
          res = r2cf(Rational(254, 100))
          assert list(res) == [2, 1, 1, 5, 1, 3]
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_cont_frac.py
  # Apply this test to two functions, because they should be equivalent
  @pytest.mark.parametrize('conv_func', [cf_convergents0, cf_convergents1])
  def test_convergents_basci1(conv_func):
      l = list(conv_func(iter([2, 1, 1, 5, 1, 3])))
      assert l[0] == Rational(2, 1)
      assert l[1] == Rational(3, 1)
      assert l[2] == Rational(5, 2)
      assert l[3] == Rational(28, 11)
      assert l[4] == Rational(33, 13)
      assert l[5] == Rational(127, 50)
      assert len(l) == 6

  # Apply this test to two functions, because they should be equivalent
  @pytest.mark.parametrize('conv_func', [cf_convergents0, cf_convergents1])
  def test_convergents_basic2(conv_func):
      l = list(cf_convergents0(iter([1, 2, 3, 4, 5])))
      assert l[0] == Rational(1, 1)
      assert l[1] == Rational(3, 2)
      assert l[2] == Rational(10, 7)
      assert l[3] == Rational(43, 30)
      assert l[4] == Rational(225, 157)
      assert len(l) == 5
#+end_src

#+begin_src python :noweb yes :tangle ../src/test_cont_frac.py
  # cf2r0 and cf2r1 should be equivalent
  @pytest.mark.parametrize('cf2r_func', [cf2r0, cf2r1])
  def test_cf2r(cf2r_func):
      assert cf2r_func([2, 1, 1, 5, 1, 3]) == Rational(127, 50)
      assert cf2r_func([1, 2, 3, 4, 5]) == Rational(225, 157)
#+end_src

* Appendix: Display utilities
#+begin_src python :noweb no-export :tangle ../src/cont_frac_io.py
  <<IO_IMPORTS>>

  class Chart(object):
      def __init__(self, m = np.identity(2, int), display_top = True, display_right = True, field_width = 4):
          self.display_top = display_top
          self.display_right = display_right
          self.top = [None]
          self.right = [None]
          self.board = [[m[0][0], m[0][1]], [m[1][0], m[1][1]]]
          self.field_width = field_width

      def pp_item(self, item, right = False):
          if item is None:
              return " " * self.field_width
          else:
              if right:
                  return f" {item : < {self.field_width}}"
              else:
                  return f"{item : > {self.field_width}}"

      def pp_row(self, row):
          return reduce(lambda s, item: s + self.pp_item(item), row, "")

      def last_column(self):
          return (self.board[-2][0], self.board[-1][0])

      def push_top(self, i):
          self.top = [i] + self.top

      def push_right(self, i):
          self.right.append(i)

      def push_column(self, m, a):
          self.push_top(a)
          assert self.last_column() == (m[0][1], m[1][1])
          for i in range(len(self.board)):
              self.board[i] = [None] + self.board[i]
          self.board[-2][0] = m[0][0] 
          self.board[-1][0] = m[1][0] 

      def push_row(self, m, q):
          assert self.board[-1][0] == m[0][0]
          assert self.board[-1][1] == m[0][1]
          new_row = [None] * len(self.board[-1])
          new_row[0] = m[1][0]
          new_row[1] = m[1][1]
          self.board.append(new_row)
          self.right.append(q)

      def __repr__(self):
          s = ""
          if self.display_top:
              s = s + self.pp_row([None] + self.top) + "\n"

          for (i, row) in enumerate(self.board):
              s = s + self.pp_row(row)
              try:
                  if self.display_right:
                      r = self.pp_item(self.right[i], right = True)
                  else:
                      r = ""
                  s = s + r + "\n"
              except IndexError:
                  s = s + "\n"
          s = s[:-1] # remove the last "\n"
          return s
#+end_src

* Appendix: Tabulated displays
#+begin_src python :tangle ../src/cont_frac_io.py
  def r2cf_tab(rn: Rational):
      def row(st: str, x: tuple):
          b, q = x
          return st + f"{b : > 5}  {q : < 5}\n"
      str0 = f"{rn.a : > 5}\n"
      return reduce(row, r2cf_(rn), str0) + f"{0 : > 5}\n"
#+end_src

#+begin_src python :noweb yes :tangle ../src/cont_frac_io.py
  def cf_convergents1_tab(cf: Iterator[int]):
      chart = Chart(display_right = False)
      (cf1, cf2) = tee(cf)
      for (mat, a) in zip(cf_convergents1_(cf1), cf2):
          chart.push_column(mat, a)
      print(chart)
#+end_src

#+begin_src python :tangle ../src/cont_frac_io.py
  def euclid_matrix_tab(m):
      chart = Chart(m = m, display_top = True)
      for (q, r) in euclid_matrix_(m):
          chart.push_row(r, q)
      print(chart)
#+end_src

#+begin_src python :noweb yes :tangle ../src/cont_frac_io.py
  def cf_convergent2_tab(cf: Iterator[int], m0 = np.identity(2, int), field_width = 4):
      chart = Chart(m = m0, field_width = field_width)
      (cf1, cf2) = tee(cf)
      for (a, (q, r, m)) in zip(cf1, cf_convergent2_(cf2, m0)):
          chart.push_column(m, a)
          if q is None:
              pass
          else:
              chart.push_row(r, q)
              if r is None:
                  char.push_right(q)
      print(chart)
#+end_src

* Appendix: LaTeX utilities
#+begin_src python :tangle no :noweb-ref LATEX_UTILS
  def latex_cf(lst: list):
      if len(lst) == 1:
          return str(lst[0])
      else:
          x = str(lst[0]) + "+"
          x = x + r"\frac{1}{" + latex_cf(lst[1:]) + "}"
          return x

  def latex_rational(r: Rational):
      return r"\frac{" + str(r.a) + "}{" + str(r.b) + "}"

  def show_cf_expansion(r: Rational):
      print(r"\[")
      print(r"\frac{", r.a, "}{", r.b, "}=")
      nc = list(euclid(r))
      print(latex_cf(nc))
      print(r"\]")

  def show_rational_series(itr: Iterator[int]):
      rLst = list(cf_convergents0(itr))
      s = ""
      for r in rLst:
          s = s + "$" + latex_rational(r) + "$" + ","

      print(s[:-1])
#+end_src

* Appendix: Imports
#+begin_src python :tangle no :noweb-ref IMPORTS
  import math
  import numpy as np
  from typing import NamedTuple, Iterator, Tuple
  from functools import reduce
  from itertools import tee
#+end_src

#+begin_src python :tangle no :noweb-ref DEMO_IMPORTS
  from cont_frac import *
  from cont_frac_io import *
#+end_src

#+begin_src python :tangle no :noweb-ref IO_IMPORTS
  from cont_frac import *
  from functools import reduce
#+end_src

#+begin_src python :tangle no :noweb-ref TEST_IMPORTS
  import numpy as np
  import pytest
  from cont_frac import *
#+end_src
