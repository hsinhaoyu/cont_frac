#+EXPORT_FILE_NAME: ../html/cont_frac.html
#+OPTIONS: broken-links:t
#+HTML_MATHJAX: align: left
#+HTML_MATHJAX: scale: 85
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

#+TITLE: Understanding Bill Gospher's continued fraction arithmetic (implemented in Python)

#+begin_src python :noweb no-export :tangle ../src/cont_frac.py
  <<IMPORTS>>
  <<RATIONAL_NUM>>
  <<R2CF>>
  <<CONVERGENTS0>>
  <<CONVERGENTS1>>
  <<QR_MATRIX>>
  <<CF_TRANSFORM>>
  <<CF_EXAMPLES>>
#+end_src

* Representing rational numbers as continued fractions
Since we'll use rational numbers a lot, let's define a class:
#+begin_src python :tangle no :noweb-ref RATIONAL_NUM
  class Rational(NamedTuple('Rational', [('a', int), ('b', int)])):
      """Rational(a, b) = a/b"""
      def __repr__(self):
          return f'{self.a}/{self.b}'
#+end_src

How to convert a rational number to a continued fraction? Observing that

\[
\frac{254}{100}
= 2 + \frac{54}{100}
= 2 + \frac{1}{\frac{100}{54}}
= 2 + \frac{1}{1 + \frac{46}{54}}
= 2 + \frac{1}{1 + \frac{1}{\frac{46}{54}}}
\]

it should be obvious that the solution is just the [[https://en.wikipedia.org/wiki/Euclidean_algorithm][Euclidean algorithm]] for finding the greatest common divider:
#+begin_src python :tangle no :noweb-ref R2CF
  # Convert a rational number to a continued fraction
  
  def qr(a: int, b: int) -> Tuple[int, int]:
      """a = b * q + r, return (q, r)"""
      q = math.floor(a / b)  # the quotient
      r = a - b * q          # the remainder
      return (q, r)

  def r2cf_(rn: Rational) -> Iterator[Tuple[int, int]]:
      """The Euclidean algorithm for representing a rational number as a continuous fraction.
      Return an iterator of quotients and remainders"""
      a, b = rn    
      while True:
          q, r = qr(a, b)
          yield b, q
          if r == 0:
              break
          a, b = b, r

  def r2cf(rn: Rational) -> Iterator[int]:
      """Represent a rational number as a continued fraction.
      Return an iterator of integers"""
      def second(x: tuple):
          return x[1]
      return map(second, r2cf_(rn))
#+end_src

Now we can use =r2cf= to convert a rational number into a continued fraction. In this article, continued fractions are represented by Python generators, because they can have infinite number of terms. However, the generators returned by =r2cf= are finite iterators because the continued fractions associated with rational numbers always have finite numbers of coefficients.
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  nc = r2cf(Rational(254, 100))
  print(list(nc))
#+end_src

#+RESULTS:
: [2, 1, 1, 5, 1, 3]

This means that
#+begin_src python :exports none :noweb strip-export :results output raw :dir ../src/
  <<DEMO_IMPORTS>>
  show_cf_expansion(Rational(254, 100))
#+end_src

#+RESULTS:
\[
\frac{ 254 }{ 100 }=
2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}
\]

We can display the process in a tabular format. For example:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  r2cf_tab(Rational(254, 100))
#+end_src

#+RESULTS:
:   254
:   100   2   
:    54   1   
:    46   1   
:     8   5   
:     6   1   
:     2   3   
:     0
: 

This table shows that 2 (the penultimate row) is the greatest common divider of 254 and 100. As a byproduct of this process, we also get the coefficients of the corresponding continued fraction, which are the quotients displayed on the right.

Interestingly, the reciprocal of $\frac{254}{100}$ (that is, $\frac{100}{254}$) is represented by the following as a continued fraction:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  nc = r2cf(Rational(100, 254))
  print(list(nc))
#+end_src

#+RESULTS:
: [0, 2, 1, 1, 5, 1, 3]

It's the same sequence with an additional 0 at the beginning! This is our first clue that a continued fraction can be transformed by performing some operations at the beginning of the Euclidean algorithm. We'll come back to this point later.

*  Calculating the convergents of a continued fraction
Given a continued fraction, how do we calculate its value? If the series is finite, we can easily write a recursive function. However, if it's an infinite series, we need a method to incrementally approximate the value as more coefficients are received. Also, we want the evaluation to be accumulative, so that each update is based on the previous one.

This question has an easy solution if we use a series of rational numbers to approximate the continued fraction. Each term in the series is called a convergent. The formula for the convergents can be derived easily with mathematical induction, and it is implemented below. For the moment, we'll use the formula just a convenience to get the job done. We'll get deeper into its meaning in the next section.
#+begin_src python :tangle no :noweb-ref CONVERGENTS0
  # Calculate the convergents of a continued fraction
  
  def cf_convergents0(cf: Iterator[int]) -> Iterator[Rational]:
      """For a continued fraction cf, return an iterator of rational numbers to approximate it""" 
      p1, p0 = 1, 0
      q1, q0 = 0, 1

      for a in cf:
          p = a * p1 + p0
          q = a * q1 + q0
          yield Rational(p, q)

          p0, p1 = p1, p
          q0, q1 = q1, q
#+end_src

For example, for the continued fraction $[2, 1, 1, 5, 1, 3]$, we get
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_convergents0(iter([2, 1, 1, 5, 1, 3]))))
#+end_src

#+RESULTS:
: [2/1, 3/1, 5/2, 28/11, 33/13, 127/50]

In other words, 
#+begin_src python :exports none :noweb strip-export :results output raw :dir ../src/
  <<DEMO_IMPORTS>>
  print("$" + latex_cf([2, 1, 1, 5, 1, 3]) + "$")
#+end_src

#+RESULTS:
$2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}$
can be approximated with
#+begin_src python :exports none :noweb strip-export :results output raw :dir ../src/
  <<DEMO_IMPORTS>>
  show_rational_series(iter([2, 1, 1, 5, 1, 3]))
#+end_src

#+RESULTS:
$\frac{2}{1}$,$\frac{3}{1}$,$\frac{5}{2}$,$\frac{28}{11}$,$\frac{33}{13}$,$\frac{127}{50}$
.

For convenience, we define a specialized version of =cf_convergents0= just for finite-term continued fractions. It returns the rational number corresponding to the continued fraction:
#+begin_src python :tangle no :noweb-ref CONVERGENTS0
  def cf2r0(cf: Iterator[int]) -> Rational:
      """Given a finite-term continued fraction, return its value as a rational number.
      This function will get into an infinite loop if the iterator doesn't stop.
      """
      return list(cf_convergents0(cf))[-1]
#+end_src

#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(cf2r0(iter([2, 1, 1, 5, 1, 3])))
#+end_src

#+RESULTS:
: 127/50

Another example: the irrational number $e$ can be expressed as a continuous fraction by:
#+begin_src python :tangle no :noweb-ref CF_EXAMPLES
  # Examples of continuous fractions
  
  def cf_e() -> Iterator[int]:
      """e as a continuous fraction"""
      yield 2
      k = 0
      while True:
          # a finite generator comprehension
          for i in (j for j in [1, 2 * k + 2, 1]):
              yield i
          k = k + 1
#+end_src

It has infinite number of terms, but the series follows a simple pattern. This is just the first 16 terms:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(islice(cf_e(), 16)))
#+end_src

#+RESULTS:
: [2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, 1, 1, 10, 1]

#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  conv_ = cf_convergents0(cf_e())
  conv = list(islice(conv_, 16)) # the first 16 convergents
  for c in conv:
      print(f'{repr(c):<20} {c[0]/c[1]:.8f}')
#+end_src

#+RESULTS:
#+begin_example
2/1                  2.00000000
3/1                  3.00000000
8/3                  2.66666667
11/4                 2.75000000
19/7                 2.71428571
87/32                2.71875000
106/39               2.71794872
193/71               2.71830986
1264/465             2.71827957
1457/536             2.71828358
2721/1001            2.71828172
23225/8544           2.71828184
25946/9545           2.71828182
49171/18089          2.71828183
517656/190435        2.71828183
566827/208524        2.71828183
#+end_example

* Continued fraction approximation as function compositions
#+INCLUDE: functional_convergents.org

* Calculating convergents using the matrix notation
Now, we are ready to rewrite the formula in =cf_convergents0= as matrix multiplications:
#+begin_src python :tangle no :noweb-ref CONVERGENTS1
  # Calculate the convergents using matrix multiplication
  
  def h(a: int) -> np.ndarray:
      return np.array([[a, 1], [1,0]])

  def cf_convergents1_(cf: Iterator[int]) -> Iterator[np.ndarray]:
      """Given a continuous fraction, return an iterator of 2x2 matrices representing convergents"""
      res = np.array([[1, 0], [0, 1]])
      for a in cf:
          res = np.matmul(res, h(a))
          yield res

  def cf_convergents1(cf: Iterator[int]) -> Iterator[Rational]:
      """Given a continuous fraction, return an iterator of rational numbers representing convergents"""
      mLst = cf_convergents1_(cf)
      for m in mLst:
          yield Rational(m[0, 0], m[1, 0])
#+end_src

Let's try it on the example given in the previous section:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_convergents1(iter([5, 1, 4]))))
#+end_src

#+RESULTS:
: [5/1, 6/1, 29/5]

Here's a longer sequence that we used previously:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_convergents1(iter([2, 1, 1, 5, 1, 3]))))
#+end_src

#+RESULTS:
: [2/1, 3/1, 5/2, 28/11, 33/13, 127/50]

A very charming thing that Gosper did was that he used a compact tabulated format to illustrate the process. It's unnecessary for the computation, but I think it looks pretty cool:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  cf_convergents1_tab(iter([5, 1, 4]))
#+end_src

#+RESULTS:
:        4   1   5    
:   29   6   5   1   0
:    5   1   1   0   1

This table is read from the right to the left. The right-to-left direction takes some getting used to, but it's needed to preserve the normal representation of matrices.

The first row represents the coefficients of the continued fraction. To understand the other numbers, we calculate the matrices for each additional coefficient in the continued fraction:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  itr = cf_convergents1_(iter([5, 1, 4]))
  print(next(itr),"\n")
  print(next(itr),"\n")
  print(next(itr))
#+end_src

#+RESULTS:
: [[5 1]
:  [1 0]] 
: 
: [[6 5]
:  [1 1]] 
: 
: [[29  6]
:  [ 5  1]]

You can see these matrices shift leftwards in the tabular representation, with adjacent matrices sharing a column. To see why, suppose that the current matrix is
$\begin{bmatrix}
    x_{11} & x_{12} \\
    x_{21} & x_{22}
\end{bmatrix}$, and we have to update it with a new term $a$ in the continued fraction. The updated matrix is
\begin{equation*}
    \begin{bmatrix}
        x_{11} & x_{12} \\
        x_{21} & x_{22}
    \end{bmatrix}
    \begin{bmatrix}
        a & 1 \\
        1 & 0
    \end{bmatrix} =
    \begin{bmatrix}
        ax_{11} & x_{11} \\
        ax_{21} & x_{21}
    \end{bmatrix}
\end{equation*}

This explains the shift, and we have recovered the formula in =cf_convergents0=.

Here's a longer series:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  cf_convergents1_tab(iter([2, 1, 1, 5, 1, 3]))
#+end_src

#+RESULTS:
:        3   1   5   1   1   2    
:  127  33  28   5   3   2   1   0
:   50  13  11   2   1   1   0   1

As before, we define a specialized version of =cf_convergents1= just for finite-term continued fractions. 
#+begin_src python :tangle no :noweb-ref CONVERGENTS1
  def cf2r1(cf: Iterator[int]) -> Rational:
      """Given a finite-term continued fraction, return its value as a rational number.
      This function will get into an infinite loop if the iterator doesn't stop.
      """
      return list(cf_convergents1(cf))[-1]
#+end_src

* Turning convergents into continued fractions
In this section, we'll develop code that calculates convergents as in =cf_convergent1=, but as it happens, we'll also turn them into continued fractions. This seems to be a pointless exercise, because a continued fraction is what we start with! Indeed, at the end of this section, we'll see that the code receives a continued fraction, and just returns the same series. However, this code will become useful in the coming sections.

Let's take the continued fraction $[5, 1, 4... ]$ as an example. Since we already know from the last section that the third convergent of $[5, 1, 4]$ is $\frac{29}{5}$, can't we just turn $\frac{29}{5}$ into a continued fraction? It is not as simple as that, because $[5, 1, 4]$ and $[5, 1, 4...]$ are not the same. For the former, the third convergent just a rational number. However, for the latter, the third convergent is
$\begin{bmatrix}
    29 & 6 \\
     5 & 1
\end{bmatrix}$, which represents the function $\frac{29x + 6}{5x + 1}$. To turn it into a continued fraction, we'll need to take the rest of the series, represented by $x$, into account.

How? The answer is still the Euclidean algorithm, but we have to use it symbolically rather than numerically.

The first step is to symbolically represent the function as a quotient and a remainder (see =qr()= in =r2cf_=). I implemented this operation in =qr_matrix= in the Appendix. We can use it on the third convergent:

#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  pp_qr(qr_matrix(np.array([[29, 6], [5, 1]])))
#+end_src

#+RESULTS:
:  5  5  1
:     4  1

This means that $f_3(x) = \frac{29x+6}{5x+1} = 5 + \frac{1}{\frac{5x+1}{4x+1}}$. Why is the quotient 5? Since $\lim_{x \to 0} f_3(x) = 6$ and $\lim_{x \to \infty} f_3(x) = \frac{29}{5} = 5.8$, the function is bounded by $5.8 < f_3(x) < 6$ (note that $0 < x < \infty$). The quotient therefore has to be 5.

Now, we are ready to implement the symbolic form of the Euclidean algorithm by calling =qr_matrix= repeatedly:
#+begin_src python :tangle no :noweb-ref CF_TRANSFORM
  def euclid_matrix_(m: np.ndarray) -> Iterator[Tuple[int, np.ndarray]]:
      """The Euclidean algorithm for the function express by matrix m.
      Returns an iterator of the quotient and the remainder"""
      while True:
          if m[0][0] == 0 and [0][1] == 0:
              # if there is no remain, stop
              break
          else:
              (q, r) = qr_matrix(m)
              if q is not None:
                  yield q, r
                  m = r
              else:
                  # if the quotient cannot be determined, stop
                  break
#+end_src

Let's try it on
$\begin{bmatrix}
    70 & 29 \\
    12 & 5
\end{bmatrix}$

#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  q = euclid_matrix_(np.array([[70, 29], [12, 5]]))
  for (r, m) in q:
      pp_qr((r, m))
      print()
#+end_src

#+RESULTS:
:  5 12  5
:    10  4
: 
:  1 10  4
:     2  1
: 
:  4  2  1
:     2  0
: 

So there is enough information in $\frac{70x+29}{12x+5}$ to precisely determine 3 coefficients (5, 1, 4). We stopped at the last term, because $\frac{2x+1}{2x}$ is an unbounded function, so the quotient cannot be determined.

As before, Gospher stacked the matrices in a compact format to illustrate the process:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  euclid_matrix_tab(np.array([[70, 29], [12, 5]]))
#+end_src

#+RESULTS:
:         
:   70  29    
:   12   5  5  
:   10   4  1  
:    2   1  4  
:    2   0

Now, we can combine convergent calculation with the symbolic Euclidean algorithm:
#+begin_src python :tangle no :noweb-ref CF_TRANSFORM
  def cf_transform_(cf: Iterator[int], m0: np.ndarray = np.identity(2, int)) -> Iterator[Tuple[Optional[int], Optional[np.ndarray], np.ndarray]]:
      """Transform the input continued fraction by matrix m
      returns another continued fraction"""
      m = m0
      for a in cf:
          m = np.matmul(m, h(a))
          q = None
          for (q, r) in euclid_matrix_(m):
              if q is not None:
                  yield q, r, m
                  m = r
          if q is None:
              # Nothing was yielded. That means for this convergent cannot be turned into a continued fraction
              yield (None, None, m)

      # we will only reach this point if the series is finite
      if m[1][0] != 0:
          for s in r2cf(Rational(m[0][0], m[1][0])):
              yield s, None, m

  def cf_transform(cf: Iterator[int], m0: np.ndarray = np.identity(2, int)) -> Iterator[int]:
      for res in cf_transform_(cf, m0):
          (q, r, m) = res
          if q is not None:
              yield q
              # q can be None, indicating that more coefficients are needed
              # to continue. It can be ignored
#+end_src

Run it on a continued fraction, and it just returns the same sequence. It doesn't seems to do any transformation. We'll see why the function is called =cf_transform= in the next section. 
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_transform(iter([2, 1, 1, 5, 1, 3]))))
#+end_src

#+RESULTS:
: [2, 1, 1, 5, 1, 3]

This seems to be anti-climatic for quite a bit of work... but here's something cool. Gospher combined the two stacked matrix representations that we have seen, to illustrate every step in the algorithm:

#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  cf_transform_tab(iter([2, 1, 1, 5, 1, 3]), field_width = 3)
#+end_src

#+RESULTS:
:      3  1  5  1  1  2   
:               3  2  1  0   
:            2  1  1  0  1  2 
:         6  1  1  0        1 
:      6  5  1  0           1 
:   4  1  1  0              5 
:   3  1  0                 1 
:   1  0                    3 


The numbers on the right are the outputs of =cf_transform=.

* Simple transformations of continued fractions
The beauty of representing convergents as matrices is that we can transform it with a function of the form $f(x) = \frac{ax+b}{cx+d}$. All we have to do is to do an additional matrix multiplication on the left side! This can be calculated by giving =cf_transform= an initial matrix.

The continued fraction $[2, 1, 1, 5, 1]$ is $\frac{33}{13}$. Let's double that, and turn it back to a continued fraction:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print("[2, 1, 1, 5, 1] is ", cf2r1(iter([2, 1, 1, 5, 1])))
  print("The continued fraction of 66/13 is ", list(r2cf(Rational(66, 13))), "\n")
  r2cf_tab(Rational(66, 13))
#+end_src

#+RESULTS:
: [2, 1, 1, 5, 1] is  33/13
: The continued fraction of 66/13 is  [5, 13] 
: 
:    66
:    13   5   
:     1   13  
:     0
: 

According to the above, $2 * [2, 1, 1, 5, 1]$ is $[5, 13]$. How do we end up with fewer terms? We can illustrate the process by running =cf_transform_tab= with the initial matrix $\begin{bmatrix} 2 & 0 \\ 0 & 1 \end{bmatrix}$ (which stands for the function $f(x) = 2x$):
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  m0 = np.array([[2, 0], [0, 1]], int)
  cd = cf_transform(iter([2, 1, 1, 5, 1]), m0 = m0)
  print(" 2 * [2, 1, 1, 5, 1] is ", list(cd), "\n")
  cf_transform_tab(iter([2, 1, 1, 5, 1]), m0 = m0, field_width = 3)
#+end_src

#+RESULTS:
:  2 * [2, 1, 1, 5, 1] is  [5, 13] 
: 
:      1  5  1  1  2   
:        10  6  4  2  0   
:  13 11  2  1  1  0  1  5 
:   1  1  0  1           13

Take the term $\begin{bmatrix} 6 & 4 \\ 1 & 1\end{bmatrix}$ for example. The range is too wide (between 4 and 6) for the quotient to be determined. The algorithm therefore has to wait for the next coefficient to resolve it. That's why the transformed continued fraction has a smaller number of terms. 

Previously, we saw that the reciprocal of a continuous fraction has an addition 0 in the beginning. Let's verify that with the initial matrix $\begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}$ (which stands for the function $f(x) = \frac{1}{x}$): 
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  m0 = np.array([[0, 1], [1, 0]], int)
  cf = cf_transform(iter([2, 1, 1, 5, 1]), m0 = m0)
  print("The reciprocal of [2, 1, 1, 5, 1] is ", list(cf), "\n")
  cf_transform_tab(iter([2, 1, 1, 5, 1]), m0 = m0, field_width = 3)
#+end_src

#+RESULTS:
#+begin_example
The reciprocal of [2, 1, 1, 5, 1] is  [0, 2, 1, 1, 5, 1] 

     1  5  1  1  2   
              1  0  1   
           3  2  1  0  0 
        2  1  1  0     2 
     6  1  1  0        1 
  6  5  1  0           1 
  1  1  0              5 
  1  0                 1 
#+end_example

Another example: what is $\frac{2}{3-\sqrt{2}}$ as a continued fraction? First, $\sqrt{2} = [1, 2, 2, 2...]$, so we should define an infinite generator:
#+begin_src python :tangle no :noweb-ref CF_EXAMPLES
  def cf_sqrt2():
      """A generator representing sqrt(2) as a continued fraction"""
      yield 1
      while True:
          yield 2
#+end_src

Then, we just need to run =cf_transform= with $\begin{bmatrix} 0 & 2 \\ -1 & 3 \end{bmatrix}$ (which stands for $\frac{2}{-x + 3}$):
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  m0 = np.array([[0, 2], [-1, 3]], int)
  cf = islice(cf_transform(cf_sqrt2(), m0 = m0), 6)
  print(" 2 / (3 - sqrt(2)) is ", pp_inf_cf(list(cf)), "\n")
  cf_transform_tab(cf_sqrt2(), m0 = m0, n = 6, field_width = 3)
#+end_src

#+RESULTS:
#+begin_example
 2 / (3 - sqrt(2)) is  [1,3,1,4,1,4...] 

     2  2  2  2  2  1   
              4  2  0  2   
           8  3  2 -1  3  1 
        5  2  1  0        3 
    10  4  2  0           1 
  5  2  1  0              4 
  4  2  0                 1 
  1  0                    4 
#+end_example

The answer is a periodic continued fraction $[1, 3, 1, 4, 1, 4...]$.

Another example: what is $\tanh{\frac{1}{2}} = \frac{e-1}{e+1}$? We have already defined the continued fraction for $e$, so it's just a matter of choosing the right initial matrix ($\begin{bmatrix} 1 & -1 \\ 1 & 1 \end{bmatrix}$, representing $\frac{x-1}{x+1}$):
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  m0 = np.array([[1, -1], [1, 1]], int)
  cf = islice(cf_transform(cf_e(), m0 = m0), 6)
  print("(e-1)/(e+1) is ", pp_inf_cf(list(cf)), "\n")
  cf_transform_tab(cf_e(), m0 = m0, n = 12, field_width = 3)
#+end_src

#+RESULTS:
#+begin_example
(e-1)/(e+1) is  [0,2,6,10,14,18...] 

     8  1  1  6  1  1  4  1  1  2  1  2   
                                   1  1 -1   
                                4  3  1  1  0 
                      12  7  5  2  1  1     2 
             20 11  9  2  1  1  0  1        6 
    28 15 13  2  1  1  0  1                 10
 17  2  1  1  0  1                          14
  1  0  1                                   17
#+end_example
The answer is a continued fraction with a simple pattern: after the second term, add 4 to the previous term. 

* Appendix: Calculating the quotient and the remainder of a convergent in matrix form
This is just calculus

#+begin_src python :tangle no :noweb-ref QR_MATRIX
  # Simple transformation of continued fraction
  
  flip_m = np.array([[0, 1], [1, 0]])
  identity_m = np.array([[1, 0], [0, 1]])

  def flip_remain(m: np.ndarray, q: int):
      assert q >= 0
      r = m[0] - m[1] * q
      m[0] = r
      return np.matmul(flip_m, m)

  def qr_matrix(m: np.ndarray) -> Tuple[int, np.ndarray]:
      """Calculate the quotient and the remainder of a 2x2 matrix"""

      assert not(m[1][0] == 0 and m[1][1] == 0)
      # this means that the series has already ended. Nothing further needs to be done
      # The caller should not call qr_matrix in this case

      m2 = m.copy()

      if m2[1][0] == 0 or m2[1][1] == 0:
          # If the function is unbounded, the quotient cannot be determined
          return (None, identity_m)
      elif m2[1][1] < 0:
          # This means that the denominator can be made 0 (i.e., a singularity)
          return (None, identity_m)
      else:
          # If the function is bounded...
          v0: float = m[0][0] / m[1][0]
          v1: float = m[0][1] / m[1][1]
          v0, v1 = sorted([v0, v1])
          d0: int = math.floor(v0)
          d1: int = math.floor(v1)
          if d0 == d1:
              # If d1 and d2 are the same, the quotient is determined
              # Calculate the remain, and flip the matrix
              m2 = flip_remain(m2, d1)
              return d1, m2
          elif d1 == d0 + 1:
              if d1 == v1:
                  # This means that d1 is the upper-bound
                  # it's only reached at 0 or infinity 
                  # So d0 is the quotient
                  m2 = flip_remain(m2, d0)
                  return d0, m2
              else:
                  # The bounds are not tight enough to determine the quotient
                  return (None, identity_m)
          else:
              # The bounds are not tight enough to determine the quotient
              return (None, identity_m)
#+end_src

Here are some example calls:
#+begin_src python :tangle no :noweb-ref TEST_QR_MATRIX
  class TestQRMatrix(object):
      def qr(self, m):
          res = qr_matrix(np.array(m))
          if res is None:
              return None
          else:
              (q, r) = res
              return q, r.tolist()

      def test_basic1(self):
          # (4x+2)/(3x+2) is between 4/2 and 2/2 (1 to 1.33)
          # increasing
          m = [[4, 2], [3, 2]]
          (q, r) = self.qr(m)
          assert q == 1 and r == [[3, 2], [1, 0]]

      def test_basic2(self):
          # (70x + 29)/ (12x + 5) is between 29/5 and 35/6 (5.8 to 5.88)
          # increasing. an example in the paper
          m = [[70, 29], [12, 5]]
          (q, r) = self.qr(m)
          assert q == 5 and r == [[12, 5], [10, 4]]

      def test_basic3(self):
          # (12x + 5) / (10 x + 4) is between 6/5 and 5/4 (1.2 to 1.25)
          # decreasing. an example in the paper
          m = [[12, 5], [10, 4]]
          (q, r) = self.qr(m)
          assert q == 1 and r == [[10, 4], [2, 1]]

      def test_edgecase1(self):
          # (10x + 4) / (2x + 1) is bounded between 4 and 5
          # the quotient is 4, because it is 5 only at infinity
          # increasing. an example in the paper
          m = [[10, 4], [2, 1]]
          (q, r) = self.qr(m)
          assert q == 4 and r == [[2, 1], [2, 0]]

      def test_edgecase2(self):
          # (8x + 3) / (2x + 1) is bounded between 3 and 4
          # it is only 4 if x is infinity, so the quotient has to be 3
          # increasing
          m = [[8, 3], [2, 1]]
          (q, r) = self.qr(m)
          assert q == 3 and r == [[2, 1], [2, 0]]

      def test_edgecase3(self):
          # (29x + 6) / (5x + 1) is bounded between 5.8 and 6
          # it is only 6 if x is 0, so the coefficient has to be 5
          # decreasing
          m = [[29, 6], [5, 1]]
          (q, r) = self.qr(m)
          assert q == 5 and r == [[5, 1], [4, 1]]

      def test_unbounded1(self):
          # 4x + 2 is unbounded
          m = [[4, 2], [0, 1]]
          (q, r) = self.qr(m)
          assert q is None

      def test_unbounded2(self):
          # (4x + 2) / 3 is unbounded
          m = [[4, 2], [3, 0]]
          (q, r) = self.qr(m)
          assert q is None

      def test_unbounded3(self):
          # 2x / (2x - 1) is unbounded, because there is a singularity at x = 1/2
          # This is in the paper
          m = [[2, 0], [2, -1]]
          (q, r) = self.qr(m)
          assert q is None

      def test_zero_coeff(self):
          # (1x + 2) / (2x + 3) is bounded between 1/2 and 2/3 (0.5 to 0.666)
          m = [[1, 2], [2, 3]]
          (q, r) = self.qr(m)
          assert q == 0 and r == [[2, 3], [1, 2]]

      def test_too_wide(self):
          # (7x + 5) / (x + 1) is bounded between 5 and 7. It's too wide to determine tne quotient
          m = [[7, 5], [1, 1]]
          (q, r) = self.qr(m)
          assert q is None
#+end_src

* Appendix: Tests

#+begin_src python :noweb no-export :tangle ../src/test_cont_frac.py
  <<TEST_IMPORTS>>
  <<TEST_R2CF>>
  <<TEST_QR_MATRIX>>
  <<TEST_CONVERGENTS>>
  <<TEST_CF2R>>
  <<TEST_CF_TRANSFORM>>
#+end_src

#+begin_src python :tangle no :noweb-ref TEST_R2CF
  class TestR2cf(object):
      def test_basic(self):
          res = r2cf(Rational(254, 100))
          assert list(res) == [2, 1, 1, 5, 1, 3]
#+end_src

#+begin_src python :tangle no :noweb-ref TEST_CONVERGENTS
  # Apply this test to two functions, because they should be equivalent
  @pytest.mark.parametrize('conv_func', [cf_convergents0, cf_convergents1])
  def test_convergents_basci1(conv_func):
      l = list(conv_func(iter([2, 1, 1, 5, 1, 3])))
      assert l[0] == Rational(2, 1)
      assert l[1] == Rational(3, 1)
      assert l[2] == Rational(5, 2)
      assert l[3] == Rational(28, 11)
      assert l[4] == Rational(33, 13)
      assert l[5] == Rational(127, 50)
      assert len(l) == 6

  # Apply this test to two functions, because they should be equivalent
  @pytest.mark.parametrize('conv_func', [cf_convergents0, cf_convergents1])
  def test_convergents_basic2(conv_func):
      l = list(cf_convergents0(iter([1, 2, 3, 4, 5])))
      assert l[0] == Rational(1, 1)
      assert l[1] == Rational(3, 2)
      assert l[2] == Rational(10, 7)
      assert l[3] == Rational(43, 30)
      assert l[4] == Rational(225, 157)
      assert len(l) == 5
#+end_src

#+begin_src python :tangle no :noweb-ref TEST_CF2R
  # cf2r0 and cf2r1 should be equivalent
  @pytest.mark.parametrize('cf2r_func', [cf2r0, cf2r1])
  def test_cf2r(cf2r_func):
      assert cf2r_func([2, 1, 1, 5, 1, 3]) == Rational(127, 50)
      assert cf2r_func([1, 2, 3, 4, 5]) == Rational(225, 157)
#+end_src

#+begin_src python :tangle no :noweb-ref TEST_CF_TRANSFORM
  class TestCFTransform(object):
      def test_cf_transform_basic1(self):
          """ 2 * [2, 1, 1, 5, 1] == 66/13"""
          m0 = np.array([[2, 0], [0, 1]], int)
          cf1 = list(cf_transform(iter([2, 1, 1, 5, 1]), m0 = m0))
          cf2 = list(r2cf(Rational(66, 13)))
          assert cf1 == cf2

      def test_cf_transform_basic1(self):
          """ 1 / [2, 1, 1, 5, 1] == [0, 2, 1, 1, 5, 1]"""
          m0 = np.array([[0, 1], [1, 0]], int)
          cf1 = list(cf_transform(iter([2, 1, 1, 5, 1]), m0 = m0))
          cf2 = [0, 2, 1, 1, 5, 1]
          assert cf1 == cf2
#+end_src

* Appendix: Display utilities
#+begin_src python :noweb no-export :tangle ../src/cont_frac_io.py
  <<IO_IMPORTS>>
  <<CHART_CLASS>>
  <<TABS>>
  <<LATEX_UTILS>>
  <<MISC>>
#+end_src

#+begin_src python :tangle no :noweb-ref CHART_CLASS
  # A class to facilitate tabular displays
  class Chart(object):
      def __init__(self, m = np.identity(2, int), display_top = True, display_right = True, field_width = 4):
          self.display_top = display_top
          self.display_right = display_right
          self.top = [None]
          self.right = [None]
          self.board = [[m[0][0], m[0][1]], [m[1][0], m[1][1]]]
          self.field_width = field_width

      def pp_item(self, item, right = False):
          if item is None:
              return " " * self.field_width
          else:
              if right:
                  return f" {item : < {self.field_width}}"
              else:
                  return f"{item : > {self.field_width}}"

      def pp_row(self, row):
          return reduce(lambda s, item: s + self.pp_item(item), row, "")

      def last_column(self):
          return (self.board[-2][0], self.board[-1][0])

      def push_top(self, i):
          self.top = [i] + self.top

      def push_right(self, i):
          self.right.append(i)

      def push_column(self, m, a):
          self.push_top(a)
          assert self.last_column() == (m[0][1], m[1][1])
          for i in range(len(self.board)):
              self.board[i] = [None] + self.board[i]
          self.board[-2][0] = m[0][0] 
          self.board[-1][0] = m[1][0] 

      def push_row(self, m, q):
          assert self.board[-1][0] == m[0][0]
          assert self.board[-1][1] == m[0][1]
          new_row = [None] * len(self.board[-1])
          new_row[0] = m[1][0]
          new_row[1] = m[1][1]
          self.board.append(new_row)
          self.right.append(q)

      def __repr__(self):
          s = ""
          if self.display_top:
              s = s + self.pp_row([None] + self.top) + "\n"

          for (i, row) in enumerate(self.board):
              s = s + self.pp_row(row)
              try:
                  if self.display_right:
                      r = self.pp_item(self.right[i], right = True)
                  else:
                      r = ""
                  s = s + r + "\n"
              except IndexError:
                  s = s + "\n"
          s = s[:-1] # remove the last "\n"
          return s
#+end_src

Some miscellaneous pretty printing utilities:
#+begin_src python :tangle no :noweb-ref MISC
  # Pretty printing utilities

  def pp_qr(qr: Tuple[int, np.ndarray]) -> None:
      """Pretty print a tuple of a quotient and a remainder matrix"""
      q, r = qr
      print(f"{q:>2} {r[0][0]:2} {r[0][1]:2}")
      print(f"   {r[1][0]:2} {r[1][1]:2}")
#+end_src

#+begin_src python :tangle no :noweb-ref MISC
  def pp_inf_cf(cf: list) -> None:
      """Pretty print a list representing the first couple terms of a longer continued fraction"""
      res = "["
      res = res + reduce(lambda s, n: s + str(n) + ",", cf, "")
      res = res[:-1] + "...]"
      return res
#+end_src

* Appendix: Tabulated displays
#+begin_src python :tangle no :noweb-ref TABS
  def r2cf_tab(rn: Rational):
      def row(st: str, x: tuple):
          b, q = x
          return st + f"{b : > 5}  {q : < 5}\n"
      str0 = f"{rn.a : > 5}\n"
      print(reduce(row, r2cf_(rn), str0) + f"{0 : > 5}\n")
#+end_src

#+begin_src python :tangle no :noweb-ref TABS
  def cf_convergents1_tab(cf: Iterator[int]):
      chart = Chart(display_right = False)
      (cf1, cf2) = tee(cf)
      for (mat, a) in zip(cf_convergents1_(cf1), cf2):
          chart.push_column(mat, a)
      print(chart)
#+end_src

#+begin_src python :tangle no :noweb-ref TABS
  def euclid_matrix_tab(m):
      chart = Chart(m = m, display_top = True)
      for (q, r) in euclid_matrix_(m):
          chart.push_row(r, q)
      print(chart)
#+end_src

#+begin_src python :tangle no :noweb-ref TABS
  def cf_transform_tab(cf: Iterator[int], m0 = np.identity(2, int), n = None, field_width = 4):
      chart = Chart(m = m0, field_width = field_width)
      if n:
          cf = islice(cf, n)

      (cf1, cf2) = tee(cf)

      res = cf_transform_(cf2, m0)
      # res may be longer than cf1, res might not be empty after this loop
      for (a, (q, r, m)) in zip(cf1, res):
          chart.push_column(m, a)
          if q is None:
              # this means that no euclid step was performed
              # do nothing
              pass
          else:
              chart.push_row(r, q)

      for item in res:
          # at this point, the quotients are quotients for rational numbers rather than matrices
          # so r should be None
          (q, r, m) = item
          assert r is None
          chart.push_right(q)
          pass

      print(chart)
#+end_src

* Appendix: LaTeX utilities
#+begin_src python :tangle no :noweb-ref LATEX_UTILS
  # Utilities functions for LaTeX displays
  def latex_cf(lst: list):
      if len(lst) == 1:
          return str(lst[0])
      else:
          x = str(lst[0]) + "+"
          x = x + r"\frac{1}{" + latex_cf(lst[1:]) + "}"
          return x

  def latex_rational(r: Rational):
      return r"\frac{" + str(r.a) + "}{" + str(r.b) + "}"

  def show_cf_expansion(r: Rational):
      print(r"\[")
      print(r"\frac{", r.a, "}{", r.b, "}=")
      nc = list(r2cf(r))
      print(latex_cf(nc))
      print(r"\]")

  def show_rational_series(itr: Iterator[int]):
      rLst = list(cf_convergents0(itr))
      s = ""
      for r in rLst:
          s = s + "$" + latex_rational(r) + "$" + ","

      print(s[:-1])
#+end_src

* Appendix: Imports
#+begin_src python :tangle no :noweb-ref IMPORTS
  import math
  import numpy as np
  from typing import NamedTuple, Iterator, Tuple, Optional
  from functools import reduce
  from itertools import tee, islice
#+end_src

#+begin_src python :tangle no :noweb-ref DEMO_IMPORTS
  from cont_frac import *
  from cont_frac_io import *
  from itertools import islice
#+end_src

#+begin_src python :tangle no :noweb-ref IO_IMPORTS
  from cont_frac import *
  from functools import reduce
#+end_src

#+begin_src python :tangle no :noweb-ref TEST_IMPORTS
  import numpy as np
  import pytest
  from cont_frac import *
#+end_src
