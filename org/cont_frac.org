#+EXPORT_FILE_NAME: ../html/cont_frac.html
#+OPTIONS: broken-links:t
#+HTML_MATHJAX: align: left
#+HTML_MATHJAX: scale: 85
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup

#+TITLE: Understanding Bill Gospher's continued fraction arithmetic (implemented in Python)

#+begin_src python :noweb no-export :tangle ../src/cont_frac.py
  <<IMPORTS>>
  <<RATIONAL_NUM>>
  <<R2CF>>
  <<CONVERGENTS0>>
  <<CONVERGENTS1>>
  <<QR_MATRIX>>
  <<CF_TRANSFORM>>
  <<BIHOMOGRAPHY>>  
  <<QR_TENSOR>>
  <<CF_EXAMPLES>>
#+end_src

* Representing rational numbers as continued fractions
Since we'll use rational numbers a lot, let's define a class:
#+begin_src python :tangle no :noweb-ref RATIONAL_NUM
  class Rational(NamedTuple('Rational', [('a', int), ('b', int)])):
      """Rational(a, b) = a/b"""
      def __repr__(self):
          return f'{self.a}/{self.b}'
#+end_src

How to convert a rational number to a continued fraction? Observing that

\[
\frac{254}{100}
= 2 + \frac{54}{100}
= 2 + \frac{1}{\frac{100}{54}}
= 2 + \frac{1}{1 + \frac{46}{54}}
= 2 + \frac{1}{1 + \frac{1}{\frac{46}{54}}}
\]

it should be obvious that the solution is just the [[https://en.wikipedia.org/wiki/Euclidean_algorithm][Euclidean algorithm]] for finding the greatest common divider:
#+begin_src python :tangle no :noweb-ref R2CF
  # Convert a rational number to a continued fraction
  
  def qr(a: int, b: int) -> Tuple[int, int]:
      """a = b * q + r, return (q, r)"""
      q = math.floor(a / b)  # the quotient
      r = a - b * q          # the remainder
      return (q, r)

  def r2cf_(rn: Rational) -> Iterator[Tuple[int, int]]:
      """The Euclidean algorithm for representing a rational number as a continuous fraction.
      Return an iterator of quotients and remainders"""
      a, b = rn    
      while True:
          q, r = qr(a, b)
          yield b, q
          if r == 0:
              break
          a, b = b, r

  def r2cf(rn: Rational) -> Iterator[int]:
      """Represent a rational number as a continued fraction.
      Return an iterator of integers"""
      def second(x: tuple):
          return x[1]
      return map(second, r2cf_(rn))
#+end_src

Now we can use =r2cf= to convert a rational number into a continued fraction. In this article, continued fractions are represented by Python generators, because they can have infinite number of terms. However, the generators returned by =r2cf= are finite iterators because the continued fractions associated with rational numbers always have finite numbers of coefficients.
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  nc = r2cf(Rational(254, 100))
  print(list(nc))
#+end_src

#+RESULTS:
: [2, 1, 1, 5, 1, 3]

This means that
#+begin_src python :exports none :noweb strip-export :results output raw :dir ../src/
  <<DEMO_IMPORTS>>
  show_cf_expansion(Rational(254, 100))
#+end_src

#+RESULTS:
\[
\frac{ 254 }{ 100 }=
2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}
\]

We can display the process in a tabular format. For example:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(r2cf_tab(Rational(254, 100)))
#+end_src

#+RESULTS:
:   254
:   100   2   
:    54   1   
:    46   1   
:     8   5   
:     6   1   
:     2   3   
:     0
: 

This table shows that 2 (the penultimate row) is the greatest common divider of 254 and 100. As a byproduct of this process, we also get the coefficients of the corresponding continued fraction, which are the quotients displayed on the right.

Interestingly, the reciprocal of $\frac{254}{100}$ (that is, $\frac{100}{254}$) is represented by the following as a continued fraction:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  nc = r2cf(Rational(100, 254))
  print(list(nc))
#+end_src

#+RESULTS:
: [0, 2, 1, 1, 5, 1, 3]

It's the same sequence with an additional 0 at the beginning! This is our first clue that a continued fraction can be transformed by performing some operations at the beginning of the Euclidean algorithm. We'll come back to this point later.

* Calculating the convergents of a continued fraction
Given a continued fraction, how do we calculate its value? If the series is finite, we can easily write a recursive function. However, if it's an infinite series, we need a method to incrementally approximate the value as more coefficients are received. Also, we want the evaluation to be accumulative, so that each update is based on the previous one.

This question has an easy solution if we use a series of rational numbers to approximate the continued fraction. Each term in the series is called a convergent. The formula for the convergents can be derived easily with mathematical induction, and it is implemented below. For the moment, we'll use the formula just a convenience to get the job done. We'll get deeper into its meaning in the next section.
#+begin_src python :tangle no :noweb-ref CONVERGENTS0
  # Calculate the convergents of a continued fraction
  
  def cf_convergents0(cf: Iterator[int]) -> Iterator[Rational]:
      """For a continued fraction cf, return an iterator of rational numbers to approximate it""" 
      p1, p0 = 1, 0
      q1, q0 = 0, 1

      for a in cf:
          p = a * p1 + p0
          q = a * q1 + q0
          yield Rational(p, q)

          p0, p1 = p1, p
          q0, q1 = q1, q
#+end_src

For example, for the continued fraction $[2, 1, 1, 5, 1, 3]$, we get
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_convergents0(iter([2, 1, 1, 5, 1, 3]))))
#+end_src

#+RESULTS:
: [2/1, 3/1, 5/2, 28/11, 33/13, 127/50]

In other words, 
#+begin_src python :exports none :noweb strip-export :results output raw :dir ../src/
  <<DEMO_IMPORTS>>
  print("$" + latex_cf([2, 1, 1, 5, 1, 3]) + "$")
#+end_src

#+RESULTS:
$2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}$
can be approximated with
#+begin_src python :exports none :noweb strip-export :results output raw :dir ../src/
  <<DEMO_IMPORTS>>
  show_rational_series(iter([2, 1, 1, 5, 1, 3]))
#+end_src

#+RESULTS:
$\frac{2}{1}$,$\frac{3}{1}$,$\frac{5}{2}$,$\frac{28}{11}$,$\frac{33}{13}$,$\frac{127}{50}$
.

For convenience, we define a specialized version of =cf_convergents0= just for finite-term continued fractions. It returns the rational number corresponding to the continued fraction:
#+begin_src python :tangle no :noweb-ref CONVERGENTS0
  def cf2r0(cf: Iterator[int]) -> Rational:
      """Given a finite-term continued fraction, return its value as a rational number.
      This function will get into an infinite loop if the iterator doesn't stop.
      """
      return list(cf_convergents0(cf))[-1]
#+end_src

#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(cf2r0(iter([2, 1, 1, 5, 1, 3])))
#+end_src

#+RESULTS:
: 127/50

Another example: the irrational number $e$ can be expressed as a continuous fraction by:
#+begin_src python :tangle no :noweb-ref CF_EXAMPLES
  # Examples of continuous fractions
  
  def cf_e() -> Iterator[int]:
      """e as a continuous fraction"""
      yield 2
      k = 0
      while True:
          # a finite generator comprehension
          for i in (j for j in [1, 2 * k + 2, 1]):
              yield i
          k = k + 1
#+end_src

It has infinite number of terms, but the series follows a simple pattern. This is just the first 16 terms:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(islice(cf_e(), 16)))
#+end_src

#+RESULTS:
: [2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, 1, 1, 10, 1]

#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  conv_ = cf_convergents0(cf_e())
  conv = list(islice(conv_, 16)) # the first 16 convergents
  for c in conv:
      print(f'{repr(c):<20} {c[0]/c[1]:.8f}')
#+end_src

#+RESULTS:
#+begin_example
2/1                  2.00000000
3/1                  3.00000000
8/3                  2.66666667
11/4                 2.75000000
19/7                 2.71428571
87/32                2.71875000
106/39               2.71794872
193/71               2.71830986
1264/465             2.71827957
1457/536             2.71828358
2721/1001            2.71828172
23225/8544           2.71828184
25946/9545           2.71828182
49171/18089          2.71828183
517656/190435        2.71828183
566827/208524        2.71828183
#+end_example

* Continued fraction approximation as function compositions
#+INCLUDE: functional_convergents.org

* Calculating convergents using the matrix notation
Now, we are ready to rewrite the formula in =cf_convergents0= as matrix multiplications:
#+begin_src python :tangle no :noweb-ref CONVERGENTS1
  # Calculate the convergents using matrix multiplication

  def h(a: int) -> np.ndarray:
      return np.array([[a, 1], [1,0]])

  def cf_convergents1_(cf: Iterator[int]) -> Iterator[np.ndarray]:
      """Given a continuous fraction, return an iterator of 2x2 matrices representing convergents"""
      res = np.array([[1, 0], [0, 1]])
      for a in cf:
          res = np.matmul(res, h(a))
          yield res

  def cf_convergents1(cf: Iterator[int]) -> Iterator[Rational]:
      """Given a continuous fraction, return an iterator of rational numbers representing convergents"""
      mLst = cf_convergents1_(cf)
      for m in mLst:
          yield Rational(m[0, 0], m[1, 0])
#+end_src

Let's try it on the example given in the [[*Continued fraction approximation as function compositions][previous section]]:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_convergents1(iter([5, 1, 4]))))
#+end_src

#+RESULTS:
: [5/1, 6/1, 29/5]

Here's a longer sequence that we used [[*Calculating the convergents of a continued fraction][previously]]:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_convergents1(iter([2, 1, 1, 5, 1, 3]))))
#+end_src

#+RESULTS:
: [2/1, 3/1, 5/2, 28/11, 33/13, 127/50]

A very charming thing that Gosper did was that he used a compact tabulated format to illustrate the process. It's unnecessary for the computation, but I think it looks pretty cool:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(cf_convergents1_tab(iter([5, 1, 4])))
#+end_src

#+RESULTS:
:      4  1  5   
:  29  6  5  1  0
:   5  1  1  0  1
: 

This table is read from the right to the left. The right-to-left direction takes some getting used to, but it's needed to preserve the normal representation of matrices.

The first row represents the coefficients of the continued fraction. To understand the other numbers, we calculate the matrices for each additional coefficient in the continued fraction:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  itr = cf_convergents1_(iter([5, 1, 4]))
  print(next(itr),"\n")
  print(next(itr),"\n")
  print(next(itr))
#+end_src

#+RESULTS:
: [[5 1]
:  [1 0]] 
: 
: [[6 5]
:  [1 1]] 
: 
: [[29  6]
:  [ 5  1]]

You can see these matrices shift leftwards in the tabular representation, with adjacent matrices sharing a column. To see why, suppose that the current matrix is
$\begin{bmatrix}
    p & q \\
    r & s
\end{bmatrix}$, and we have to update it with a new term $a_n$ in the continued fraction. The updated matrix is
\begin{equation*}
    \begin{bmatrix}
        p & q \\
        r & s
    \end{bmatrix}
    \begin{bmatrix}
        a_n & 1 \\
        1 & 0
    \end{bmatrix} =
    \begin{bmatrix}
        a_n p + q & p \\
        a_n r + s & r
    \end{bmatrix}
\end{equation*}

This explains the shift, and we have recovered the formula in =cf_convergents0=.

Here's a longer series:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(cf_convergents1_tab(iter([2, 1, 1, 5, 1, 3])))
#+end_src

#+RESULTS:
:        3   1   5   1   1   2    
:  127  33  28   5   3   2   1   0
:   50  13  11   2   1   1   0   1
: 

As before, we define a specialized version of =cf_convergents1= just for finite-term continued fractions. 
#+begin_src python :tangle no :noweb-ref CONVERGENTS1
  def cf2r1(cf: Iterator[int]) -> Rational:
      """Given a finite-term continued fraction, return its value as a rational number.
      This function will get into an infinite loop if the iterator doesn't stop.
      """
      return list(cf_convergents1(cf))[-1]
#+end_src

* Turning convergents into continued fractions
In this section, we'll develop code that calculates convergents as in =cf_convergent1=, but as it happens, we'll also turn them into continued fractions. This seems to be a pointless exercise, because a continued fraction is what we start with! Indeed, at the end of this section, we'll see that the code receives a continued fraction, and just returns the same series. However, this code will become useful in the coming sections.

Let's take the continued fraction $[5, 1, 4... ]$ as an example. Since we already know from the [[*Calculating convergents using the matrix notation][last section]] that the third convergent of $[5, 1, 4]$ is $\frac{29}{5}$, can't we just turn $\frac{29}{5}$ into a continued fraction? It is not as simple as that, because $[5, 1, 4]$ and $[5, 1, 4...]$ are not the same. For the former, the third convergent just a rational number. However, for the latter, the third convergent is
$\begin{bmatrix}
    29 & 6 \\
     5 & 1
\end{bmatrix}$, which represents the function $\frac{29x + 6}{5x + 1}$. To turn it into a continued fraction, we'll need to take the rest of the series, represented by $x$, into account.

How? The answer is still the Euclidean algorithm, but we have to use it symbolically rather than numerically.

The first step is to symbolically represent the function as a quotient and a remainder (see =qr()= in =r2cf_=). I implemented this operation in =qr_matrix= in the [[*Calculating the quotient and the remainder of a convergent in matrix form][Appendix]]. We can use it on the third convergent:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  pp_qr(qr_matrix(np.array([[29, 6], [5, 1]])))
#+end_src

#+RESULTS:
:  5  5  1
:     4  1

This means that $f_3(x) = \frac{29x+6}{5x+1} = 5 + \frac{1}{\frac{5x+1}{4x+1}}$. Why is the quotient 5? Since $\lim_{x \to 0} f_3(x) = 6$ and $\lim_{x \to \infty} f_3(x) = \frac{29}{5} = 5.8$, the function is bounded by $5.8 < f_3(x) < 6$ (note that $0 < x < \infty$). The quotient therefore has to be 5.

#+ATTR_ORG: :width 400
#+ATTR_HTML: :width 400
[[file:../figs/fig1.png]]

Now, we are ready to implement the symbolic form of the Euclidean algorithm by calling =qr_matrix= repeatedly:
#+begin_src python :tangle no :noweb-ref CF_TRANSFORM
  def euclid_matrix_(m: np.ndarray) -> Iterator[Tuple[int, np.ndarray]]:
      """The Euclidean algorithm for the function express by matrix m.
      Returns an iterator of the quotient and the remainder"""
      while True:
          if m[0][0] == 0 and [0][1] == 0:
              # if there is no remain, stop
              break
          else:
              (q, r) = qr_matrix(m)
              if q is not None:
                  yield q, r
                  m = r
              else:
                  # if the quotient cannot be determined, stop
                  break
#+end_src

Let's try it on
$\begin{bmatrix}
    70 & 29 \\
    12 & 5
\end{bmatrix}$

#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  q = euclid_matrix_(np.array([[70, 29], [12, 5]]))
  for (r, m) in q:
      pp_qr((r, m))
      print()
#+end_src

#+RESULTS:
:  5 12  5
:    10  4
: 
:  1 10  4
:     2  1
: 
:  4  2  1
:     2  0
: 

So there is enough information in $\frac{70x+29}{12x+5}$ to precisely determine 3 coefficients (5, 1, 4). We stopped at the last term, because $\frac{2x+1}{2x}$ is an unbounded function, so the quotient cannot be determined.

As before, Gospher stacked the matrices in a compact format to illustrate the process:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(euclid_matrix_tab(np.array([[70, 29], [12, 5]])))
#+end_src

#+RESULTS:
:          
:  70 29   
:  12  5  5
:  10  4  1
:   2  1  4
:   2  0   
: 

Now, we can combine convergent calculation with the symbolic Euclidean algorithm:
#+begin_src python :tangle no :noweb-ref CF_TRANSFORM
  def cf_transform_(cf: Iterator[int], m0: np.ndarray = np.identity(2, int)) -> Iterator[Tuple[Optional[int], Optional[np.ndarray], np.ndarray, int, bool]]:
      """Transform the input continued fraction by matrix m
      returns another continued fraction"""
      m = m0
      for a in cf:
          m = np.matmul(m, h(a))
          new_a = True
          for (q, r) in euclid_matrix_(m):
              yield q, r, m, a, new_a
              new_a = False
              m = r
          if new_a:
              # Nothing was yielded. That means for this convergent cannot be turned into a continued fraction
              yield (None, None, m, a, new_a)

      # we will only reach this point if the series is finite
      if m[1][0] != 0:
          for s in r2cf(Rational(m[0][0], m[1][0])):
              yield s, None, m, a, False

  def cf_transform(cf: Iterator[int], m0: np.ndarray = np.identity(2, int)) -> Iterator[int]:
      for res in cf_transform_(cf, m0):
          (q, r, m, a, new_a) = res
          if q is not None:
              yield q
              # q can be None, indicating that more coefficients are needed
              # to continue. It can be ignored
#+end_src

Run it on a continued fraction, and it just returns the same sequence. It doesn't seems to do any transformation. We'll see why the function is called =cf_transform= in the next section. 
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_transform(iter([2, 1, 1, 5, 1, 3]))))
#+end_src

#+RESULTS:
: [2, 1, 1, 5, 1, 3]

This seems to be anti-climatic for quite a bit of work... but here's something cool. Gospher combined the two stacked matrix representations that we have seen, to illustrate every step in the algorithm:

#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(cf_transform_tab(iter([2, 1, 1, 5, 1, 3])))
#+end_src

#+RESULTS:
:    3 1 5 1 1 2    
:          3 2 1 0  
:        2 1 1 0 1 2
:      6 1 1 0     1
:    6 5 1 0       1
:  4 1 1 0         5
:  3 1 0           1
:  1 0             3
: 

The numbers on the right are the outputs of =cf_transform=.

* Simple transformations of continued fractions
The beauty of representing convergents as matrices is that we can transform it with a function of the form $f(x) = \frac{px+q}{rx+s}$. All we have to do is to do an additional matrix multiplication on the left side! This can be calculated by giving =cf_transform= an initial matrix.

The continued fraction $[2, 1, 1, 5, 1]$ is $\frac{33}{13}$. Let's double that, and turn it back to a continued fraction:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print("[2, 1, 1, 5, 1] is ", cf2r1(iter([2, 1, 1, 5, 1])))
  print("The continued fraction of 66/13 is ", list(r2cf(Rational(66, 13))), "\n")
  r2cf_tab(Rational(66, 13))
#+end_src

#+RESULTS:
: [2, 1, 1, 5, 1] is  33/13
: The continued fraction of 66/13 is  [5, 13] 
: 
:    66
:    13   5   
:     1   13  
:     0
: 

According to the above, $2 * [2, 1, 1, 5, 1]$ is $[5, 13]$. How do we end up with fewer terms? We can illustrate the process by running =cf_transform_tab= with the initial matrix $\begin{bmatrix} 2 & 0 \\ 0 & 1 \end{bmatrix}$ (which stands for the function $f(x) = 2x$):
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  m0 = np.array([[2, 0], [0, 1]], int)
  cf = cf_transform(iter([2, 1, 1, 5, 1]), m0 = m0)
  print(" 2 * [2, 1, 1, 5, 1] is ", list(cf), "\n")
  print(cf_transform_tab(iter([2, 1, 1, 5, 1]), m0 = m0))
#+end_src

#+RESULTS:
:  2 * [2, 1, 1, 5, 1] is  [5, 13] 
: 
:      1  5  1  1  2      
:        10  6  4  2  0   
:  13 11  2  1  1  0  1  5
:   1  1  0  1          13
: 

Take the term $\begin{bmatrix} 6 & 4 \\ 1 & 1\end{bmatrix}$ for example. The range is too wide (between 4 and 6) for the quotient to be determined. The algorithm therefore has to wait for the next coefficient to resolve it. That's why the transformed continued fraction has a smaller number of terms. 

Previously, we saw that the reciprocal of a continuous fraction has an addition 0 in the beginning. Let's verify that with the initial matrix $\begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}$ (which stands for the function $f(x) = \frac{1}{x}$): 
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  m0 = np.array([[0, 1], [1, 0]], int)
  cf = cf_transform(iter([2, 1, 1, 5, 1]), m0 = m0)
  print("The reciprocal of [2, 1, 1, 5, 1] is ", list(cf), "\n")
  print(cf_transform_tab(iter([2, 1, 1, 5, 1]), m0 = m0))
#+end_src

#+RESULTS:
#+begin_example
The reciprocal of [2, 1, 1, 5, 1] is  [0, 2, 1, 1, 5, 1] 

   1 5 1 1 2    
         1 0 1  
       3 2 1 0 0
     2 1 1 0   2
   6 1 1 0     1
 6 5 1 0       1
 1 1 0         5
 1 0           1

#+end_example

Another example: what is $\frac{2}{3-\sqrt{2}}$ as a continued fraction? First, $\sqrt{2} = [1, 2, 2, 2...]$, so we should define an infinite generator:
#+begin_src python :tangle no :noweb-ref CF_EXAMPLES
  def cf_sqrt2():
      """A generator representing sqrt(2) as a continued fraction"""
      yield 1
      while True:
          yield 2
#+end_src

Then, we just need to run =cf_transform= with $\begin{bmatrix} 0 & 2 \\ -1 & 3 \end{bmatrix}$ (which stands for $\frac{2}{-x + 3}$):
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  m0 = np.array([[0, 2], [-1, 3]], int)
  cf = islice(cf_transform(cf_sqrt2(), m0 = m0), 6)
  print(" 2 / (3 - sqrt(2)) is ", pp_inf_cf(list(cf)), "\n")
  print(cf_transform_tab(cf_sqrt2(), m0 = m0, n = 6))
#+end_src

#+RESULTS:
#+begin_example
 2 / (3 - sqrt(2)) is  [1,3,1,4,1,4...] 

     2  2  2  2  2  1      
              4  2  0  2   
           8  3  2 -1  3  1
        5  2  1  0        3
    10  4  2  0           1
  5  2  1  0              4
  4  2  0                 1
  1  0                    4

#+end_example

The answer is a periodic continued fraction $[1, 3, 1, 4, 1, 4...]$.

Another example: what is $\tanh{\frac{1}{2}} = \frac{e-1}{e+1}$? We have already defined the continued fraction for $e$, so it's just a matter of choosing the right initial matrix ($\begin{bmatrix} 1 & -1 \\ 1 & 1 \end{bmatrix}$, representing $\frac{x-1}{x+1}$):
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  m0 = np.array([[1, -1], [1, 1]], int)
  cf = islice(cf_transform(cf_e(), m0 = m0), 6)
  print("(e-1)/(e+1) is ", pp_inf_cf(list(cf)), "\n")
  print(cf_transform_tab(cf_e(), m0 = m0, n = 12))
#+end_src

#+RESULTS:
#+begin_example
(e-1)/(e+1) is  [0,2,6,10,14,18...] 

     8  1  1  6  1  1  4  1  1  2  1  2      
                                   1  1 -1   
                                4  3  1  1  0
                      12  7  5  2  1  1     2
             20 11  9  2  1  1  0  1        6
    28 15 13  2  1  1  0  1                10
 17  2  1  1  0  1                         14
  1  0  1                                  17

#+end_example

The answer is a continued fraction with a simple pattern: after the second term, add 4 to the previous term.

* Continued fraction arithmetic - bihomographic functions
#+INCLUDE: arithmetic.org

* Bihomographic functions - implementation
Let's represent bihomographic functions with Numpy tensors:
#+begin_src python :noweb no :noweb-ref BIHOMOGRAPHY
  # Tensor representations of bihomographic functions

  def tFrom2x4(m: np.ndarray) -> np.ndarray:
      ((a, b, c, d), (e, f, g, h)) = m.tolist()
      return np.array([[[b, d], [a, c]], [[f, h], [e, g]]])

  def tTo2x4(m: np.ndarray) -> np.ndarray:
      (((b, d), (a, c)), ((f, h), (e, g))) = m.tolist()
      return np.array([[a, b, c, d], [e, f, g, h]])
#+end_src

A utility function for easy accessing elements of the matrices:
#+begin_src python :tangle no :noweb-ref BIHOMOGRAPHY
  def tensor_ref(t: np.ndarray, label: str):
      assert t.shape == (2, 2, 2)
      assert label in ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'xy', 'x', 'y', '1']
      lookup = {}
      lookup['a']  = t[0,1,0]
      lookup['b']  = t[0,0,0]
      lookup['c']  = t[0,1,1]
      lookup['d']  = t[0,0,1]
      lookup['e']  = t[1,1,0]
      lookup['f']  = t[1,0,0]
      lookup['g']  = t[1,1,1]
      lookup['h']  = t[1,0,1]
      lookup['xy'] = lookup['a'], lookup['e']
      lookup['x']  = lookup['b'], lookup['f']
      lookup['y']  = lookup['c'], lookup['g']
      lookup['1']  = lookup['d'], lookup['h']
      return lookup[label]
#+end_src

These are the initial tensors needed for arithmetic:
#+begin_src python :noweb no :noweb-ref BIHOMOGRAPHY
  tForAddition = np.array([[[1, 0], [0, 1]], [[0, 1], [0, 0]]])
  tForSubtraction = np.array([[[1, 0], [0, -1]], [[0, 1], [0, 0]]])
  tForMultiplication = np.array([[[0, 0], [1, 0]], [[0, 1], [0, 0]]])
  tForDivision = np.array([[[1, 0], [0, 0]], [[0, 0], [0, 1]]])
#+end_src

Applying new coefficients is implemented with my favorite Numpy function: =einsum= (Einstein's sum):
#+begin_src python :noweb no :noweb-ref BIHOMOGRAPHY
  def apply_a(t: np.ndarray, a: int):
      ha = h(a)
      return np.einsum('dyx,xz->dyz', t, ha)

  def h_rotated(b: int) -> np.ndarray:
      return np.array([[0, 1], [1, b]])
      
  def apply_b(t: np.ndarray, b: int):
      hb = h_rotated(b)
      return np.einsum('zy,dyx->dzx', hb, t)      
#+end_src

To make sure that it works:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  t = tForAddition
  t = apply_a(t, 2)
  t = apply_b(t, 3)
  t = apply_a(t, 4)
  t = apply_b(t, 5)
  print(tTo2x4(t))
#+end_src

#+RESULTS:
: [[109  21  26   5]
:  [ 20   4   5   1]]

$\begin{bmatrix} 109 & 21 & 26 & 5 \\ 20 & 4 & 5 & 1 \end{bmatrix}$ means $\frac{109xy + 21x + 26y + 5}{20xy + 4x + 5y + 1}$, which equals $(2+\frac{1}{4+\frac{1}{x}}) + (3+\frac{1}{5+\frac{1}{y}})$. That's correct.

#+ATTR_ORG: :width 400
#+ATTR_HTML: :width 400
[[file:../figs/fig2.png]]

Let's try multiplication:
#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  t = tForMultiplication
  t = apply_a(t, 2)
  t = apply_b(t, 3)
  t = apply_a(t, 4)
  print(tTo2x4(t))
#+end_src

#+RESULTS:
: [[27  9  6  2]
:  [ 4  0  1  0]]

$\frac{27xy+9x+6y+2}{4xy+y} = (2 + \frac{1}{4+\frac{1}{x}}) \cdot (3+\frac{1}{y})$. That's also correct.

* Convergents
#+begin_src python :tangle no :noweb-ref BIHOMOGRAPHY
  def arithmetic_convergents_(a: Iterator[int], b: Iterator[int], t0 = tForAddition) -> Iterator[np.ndarray]:
      res = t0.copy()
      while True:
          an = next(a, None)
          bn = next(b, None)

          if an is None and bn is None:
              break

          if an is not None:
              res = apply_a(res, an)
              yield 'a', an, res
          if bn is not None:
              res = apply_b(res, bn)
              yield 'b', bn, res

  def arithmetic_convergents(a: Iterator[int], b: Iterator[int], t0 = tForAddition) -> Iterator[Rational]:
      c = arithmetic_convergents_(a, b, t0)
      next(c) # skip the initial tensor
      for _, _, res in c:
          r = tensor_ref(res, 'xy')
          yield Rational(*r)
#+end_src

#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  a = iter([2, 1, 1, 5, 1])
  b = iter([2, 1, 1, 5, 1])
  print(list(arithmetic_convergents(a, b, tForAddition)))
#+end_src

#+RESULTS:
: [4/1, 5/1, 6/1, 11/2, 20/4, 111/22, 616/121, 727/143, 858/169]

#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  a = iter([2, 1, 1, 5, 1])
  b = iter([2, 1, 1, 5, 1])
  print(list(arithmetic_convergents(a, b, tForSubtraction)))
#+end_src

#+RESULTS:
: [0/1, 1/1, 0/1, -1/2, 0/4, 1/22, 0/121, -1/143, 0/169]

#+begin_src python :exports both :noweb strip-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  a = iter([2, 1, 1, 5, 1])
  b = iter([2, 1, 1, 5, 1])
  print(list(arithmetic_convergents(a, b, tForMultiplication)))
#+end_src

#+RESULTS:
: [4/1, 6/1, 9/1, 15/2, 25/4, 140/22, 784/121, 924/143, 1089/169]

* Appendix: Quotients/remainders for matrices
This is just calculus

#+begin_src python :tangle no :noweb-ref QR_MATRIX
  # Simple transformation of continued fraction
  
  flip_m = np.array([[0, 1], [1, 0]])
  identity_m = np.array([[1, 0], [0, 1]])

  def flip_remain(m: np.ndarray, q: int):
      assert q >= 0
      r = m[0] - m[1] * q
      m[0] = r
      return np.matmul(flip_m, m)

  def qr_matrix(m: np.ndarray) -> Tuple[int, np.ndarray]:
      """Calculate the quotient and the remainder of a 2x2 matrix"""

      assert not(m[1][0] == 0 and m[1][1] == 0)
      # this means that the series has already ended. Nothing further needs to be done
      # The caller should not call qr_matrix in this case

      m2 = m.copy()

      if m2[1][0] == 0 or m2[1][1] == 0:
          # If the function is unbounded, the quotient cannot be determined
          return (None, identity_m)
      elif m2[1][1] < 0:
          # This means that the denominator can be made 0 (i.e., a singularity)
          return (None, identity_m)
      else:
          # If the function is bounded...
          v0: float = m[0][0] / m[1][0]
          v1: float = m[0][1] / m[1][1]
          v0, v1 = sorted([v0, v1])
          d0: int = math.floor(v0)
          d1: int = math.floor(v1)
          if d0 == d1:
              # If d1 and d2 are the same, the quotient is determined
              # Calculate the remain, and flip the matrix
              m2 = flip_remain(m2, d1)
              return d1, m2
          elif d1 == d0 + 1:
              if d1 == v1:
                  # This means that d1 is the upper-bound
                  # it's only reached at 0 or infinity 
                  # So d0 is the quotient
                  m2 = flip_remain(m2, d0)
                  return d0, m2
              else:
                  # The bounds are not tight enough to determine the quotient
                  return (None, identity_m)
          else:
              # The bounds are not tight enough to determine the quotient
              return (None, identity_m)
#+end_src

* Appendix: Quotients/remainders for tensors

#+begin_src python :tangle no :noweb-ref QR_TENSOR
  def tensor_term_ratios(t: np.ndarray) -> list:
      """ return
          [[a/e, floor(a/e), 'xy'],
           [b/f, floor(b/f), 'x'],
           [c/g, floor(c/g), 'y'],
           [d/h, floor(d/h), '1']]"""

      def f(label):
          numerator, denominator = tensor_ref(t, label)
          return numerator/denominator, math.floor(numerator/denominator), label

      return [f('xy'), f('x'), f('y'), f('1')]

  def qr_tensor(t: np.ndarray):
      if (t[1] <= 0).any():
          # if any number in the denominator is smaller or equal to 0, the function is unbounded
          pass
      else:
          r = tensor_term_ratios(t)
          r_sorted = sorted(r, key = lambda terms: terms[1], reverse = True)

          if r_sorted[0, 0] == r_sorted[0, 1]:
              # the max can only be reached at 0 or infinity, so the quotient needed -1 
              r_sorted[0, 1] = r_sorted[0, 1] - 1

          if r_sorted[0, 1] == r_sorted[-1, 1]:
              #  If the floor of the first and the last are the same, the numbers are all the same
              # in this case, the value is the quotient
              pass
          else:
              # the quotient cannot be determined, but suggest which direction to go
              # if one of them is different, go to the dir that is different
              # if all three are different, what to do? compare magnitude?
              pass
#+end_src
* Appendix: Tests
#+INCLUDE: tests.org
* Appendix: Display utilities
#+INCLUDE: display.org
* Appendix: Imports
#+begin_src python :tangle no :noweb-ref IMPORTS
  import math
  import numpy as np
  from typing import NamedTuple, Iterator, Tuple, Optional
  from functools import reduce
  from itertools import tee, islice
#+end_src

#+begin_src python :tangle no :noweb-ref DEMO_IMPORTS
  from cont_frac import *
  from cont_frac_io import *
  from itertools import islice
#+end_src
