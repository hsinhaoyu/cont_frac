#+EXPORT_FILE_NAME: ../html/cont_frac.html
#+OPTIONS: broken-links:t
#+HTML_MATHJAX: align: left
#+OPTIONS: toc:nil 
* Continued fraction representations of rational numbers
Since we'll use rational numbers a lot, let's define a class:
#+begin_src python :noweb no-export :tangle ../src/cont_frac.py
  <<IMPORTS>>
  # Rational(a, b) = a/b
  class Rational(NamedTuple('Rational', [('a', int), ('b', int)])):
      def __repr__(self):
          return f'{self.a}/{self.b}'
#+end_src

How to convert a rational number to a continued fraction? Observing that

\[
\frac{254}{100}
= 2 + \frac{54}{100}
= 2 + \frac{1}{\frac{100}{54}}
= 2 + \frac{1}{1 + \frac{46}{54}}
= 2 + \frac{1}{1 + \frac{1}{\frac{46}{54}}}
\]

it should be obvious that it can be done in a process that is similar to the Euclidean algorithm for finding the greatest common divider:
#+begin_src python :noweb yes :tangle ../src/cont_frac.py
  def euclid(a: int, b: int) -> Tuple[int, int]:
      """a = b * q + r"""
      q = math.floor(a / b)
      r = a - b * q
      return (q, r)

  def r2cf_(rn: Rational) -> Iterator[Tuple[int, int]]:
      a, b = rn    
      r = 1000
      while r != 0:
          q, r = euclid(a, b)
          yield b, q
          a = b
          b = r

  def r2cf(rn: Rational) -> Iterator[int]:
      def second(x: tuple):
          return x[1]
      return map(second, r2cf_(rn))
#+end_src

Now we can use =r2cf= to calculate the coefficients. I use a generator to represent the returned coefficients, because continued fractions can have infinite number of terms. However, the continuous fraction representations of rational numbers are always finite.
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  nc = r2cf(Rational(254, 100))
  print(list(nc))
#+end_src

#+RESULTS:
: [2, 1, 1, 5, 1, 3]

This means that
#+begin_src python :exports none :noweb no-export :results output raw :dir ../src/
  <<DEMO_IMPORTS>>
  <<LATEX_UTILS>>
  show_cf_expansion(Rational(254, 100))
#+end_src

#+RESULTS:
\[
\frac{ 254 }{ 100 }=
2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}
\]

We can display the process in a tabular format. For example:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  <<TAB_UTILS>>
  print(r2cf_tab(Rational(254, 100)))
#+end_src

#+RESULTS:
:   254
:   100   2   
:    54   1   
:    46   1   
:     8   5   
:     6   1   
:     2   3   
:     0
: 

Interestingly, the reciprocal of $\frac{254}{100}$ (that is, $\frac{100}{254}$) is represented by the following as a continued fraction:

#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  nc = r2cf(Rational(100, 254))
  print(list(nc))
#+end_src

#+RESULTS:
: [0, 2, 1, 1, 5, 1, 3]

It's the same sequence with an additional 0 at the beginning! This is our first clue that a continued fraction can be transformed by performing some operations at the beginning of the =r2cf= process.

However, it's not obvious how to perform algebraically meaningful transformations. For example, if we multiple the rational number by two, the continued fraction series appear to be quite different. It's not clear how we get [0, 1, 3, 1, 2, 2, 1, 2] from [0, 2, 1, 1, 5, 1, 3]. We'll come back to this question a little bit later. 
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(r2cf(Rational(200, 254))))
#+end_src

#+RESULTS:
: [0, 1, 3, 1, 2, 2, 1, 2]

*  Convergents
Given the coefficients of a continued fraction, how do we calculate the value? If the series is finite, we can easily write a recursive function. However, if it's an infinite series, we need a method to approximate the value as more coefficients are received. It's not difficult to show that it can be approximated by a series of rational numbers:

#+begin_src python :noweb yes :tangle ../src/cont_frac.py
  def cf_convergent0(cf: Iterator[int]) -> Iterator[Rational]:
      p1, p0 = 1, 0
      q1, q0 = 0, 1
    
      for a in cf:
          p = a * p1 + p0
          q = a * q1 + q0
          yield Rational(p, q)

          p0, p1 = p1, p
          q0, q1 = q1, q
#+end_src

For example, for the sequence $2, 1, 1, 5, 1, 3$, we get
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_convergent0(iter([2, 1, 1, 5, 1, 3]))))
#+end_src

#+RESULTS:
: [2/1, 3/1, 5/2, 28/11, 33/13, 127/50]

In other words, 
#+begin_src python :exports none :noweb no-export :results output raw :dir ../src/
  <<LATEX_UTILS>>
  print("$" + latex_cf([2, 1, 1, 5, 1, 3]) + "$")
#+end_src

#+RESULTS:
$2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}$
can be approximated with
#+begin_src python :exports none :noweb no-export :results output raw :dir ../src/
  <<DEMO_IMPORTS>>
  <<LATEX_UTILS>>
  show_rational_series(iter([2, 1, 1, 5, 1, 3]))
#+end_src

#+RESULTS:
$\frac{2}{1}$,$\frac{3}{1}$,$\frac{5}{2}$,$\frac{28}{11}$,$\frac{33}{13}$,$\frac{127}{50}$
.

* Convergents: matrix formulation
The first step towards Gosper arithmetics is to rewrite the formula in =cf_convergence0= as matrix multiplications. Begin with
$\begin{bmatrix}
1 & 0 \\
0 & 1
\end{bmatrix}$, with each new coefficient $a$ in continued fraction series, we right-multiply the matrix
$\begin{bmatrix}
a & 1 \\
1 & 0
\end{bmatrix}$, and output the first column as the next rational number approximation.

#+begin_src python :noweb yes :tangle ../src/cont_frac.py
  def h(a):
      return np.array([[a, 1], [1,0]])

  def cf_convergent1_(cdf: Iterator[int]) -> Iterator:
      res = np.array([[1, 0], [0, 1]])
      for a in cdf:
          res = np.matmul(res, h(a))
          yield res

  def cf_convergent1(cdf: Iterator[int]) -> Iterator[Rational]:
      mLst = cf_convergent1_(cdf)
      for m in mLst:
          yield Rational(m[0, 0], m[1, 0])
#+end_src

All we have done is expressing the same computation slightly differently. We should get the same series as the previous section.
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_convergent1(iter([2, 1, 1, 5, 1, 3]))))
#+end_src

#+RESULTS:
: [2/1, 3/1, 5/2, 28/11, 33/13, 127/50]

Gosper uses a compact tabulated format to visualize the computation. It's unnecessary, but I think it looks pretty cool:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  <<TAB_UTILS>>
  cf_convergent1_tab(iter([2, 1, 1, 5, 1, 3]))
#+end_src

#+RESULTS:
:        2   1   1   5   1   3
:    0   1   2   3   5  28  33 127
:    1   0   1   1   2  11  13  50

* Appendix: Tabulated displays
#+begin_src python :tangle no :nowev-ref TAB_UTILS
  def r2cf_tab(rn: Rational):
      def row(st: str, x: tuple):
          b, q = x
          return st + f"{b : > 5}  {q : < 5}\n"
      str0 = f"{rn.a : > 5}\n"
      return reduce(row, r2cf_(rn), str0) + f"{0 : > 5}\n"
#+end_src

#+begin_src python :tangle no :noweb-ref TAB_UTILS
  def cf_convergent1_tab(cdf: Iterator[int]):
      def f_(item):
          if item == "":
              return f"{'': >4}"
          else:
              return f"{item: >4}"
      def push_(item1, item2, item3):
          lines[0].append(f_(item1))
          lines[1].append(f_(item2))
          lines[2].append(f_(item3))

      res = np.array([[1, 0], [0, 1]])        
      lines = [[f_("")], [f_(0), f_(1)], [f_(1), f_(0)]]
      for a in cdf:
          res = np.matmul(res, h(a))
          push_(a, res[0][0], res[1][0])

      print(reduce(lambda a, b: a + b, lines[0], ""))
      print(reduce(lambda a, b: a + b, lines[1], ""))
      print(reduce(lambda a, b: a + b, lines[2], ""))
#+end_src

* Appendix: LaTeX utilities
#+begin_src python :tangle no :noweb-ref LATEX_UTILS
  def latex_cf(lst: list):
      if len(lst) == 1:
          return str(lst[0])
      else:
          x = str(lst[0]) + "+"
          x = x + r"\frac{1}{" + latex_cf(lst[1:]) + "}"
          return x

  def latex_rational(r: Rational):
      return r"\frac{" + str(r.a) + "}{" + str(r.b) + "}"

  def show_cf_expansion(r: Rational):
      print(r"\[")
      print(r"\frac{", r.a, "}{", r.b, "}=")
      nc = list(r2cf(r))
      print(latex_cf(nc))
      print(r"\]")

  def show_rational_series(itr: Iterator[int]):
      rLst = list(cf_convergent0(itr))
      s = ""
      for r in rLst:
          s = s + "$" + latex_rational(r) + "$" + ","

      print(s[:-1])
#+end_src

* Appendix: imports
#+begin_src python :tangle no :noweb-ref IMPORTS
  import math
  import numpy as np
  from typing import NamedTuple, Iterator, Tuple
  from functools import reduce
#+end_src

#+begin_src python :tangle no :noweb-ref DEMO_IMPORTS
  from cont_frac import *
#+end_src
