#+EXPORT_FILE_NAME: ../html/cont_frac.html
#+OPTIONS: broken-links:t
#+HTML_MATHJAX: align: left
#+SETUPFILE: https://fniessen.github.io/org-html-themes/org/theme-readtheorg.setup
* Continued fraction representations of rational numbers
Since we'll use rational numbers a lot, let's define a class:
#+begin_src python :noweb no-export :tangle ../src/cont_frac.py
  <<IMPORTS>>
  # Rational(a, b) = a/b
  class Rational(NamedTuple('Rational', [('a', int), ('b', int)])):
      def __repr__(self):
          return f'{self.a}/{self.b}'
#+end_src

How to convert a rational number to a continued fraction? Observe that

\[
\frac{254}{100}
= 2 + \frac{54}{100}
= 2 + \frac{1}{\frac{100}{54}}
= 2 + \frac{1}{1 + \frac{46}{54}}
= 2 + \frac{1}{1 + \frac{1}{\frac{46}{54}}}
\]

It should be obvious that the solution is similar to the Euclidean algorithm for finding the greatest common divider:
#+begin_src python :noweb yes :tangle ../src/cont_frac.py
  def euclid(a: int, b: int) -> Tuple[int, int]:
      """a = b * q + r"""
      q = math.floor(a / b)
      r = a - b * q
      return (q, r)

  def r2cf_(rn: Rational) -> Iterator[Tuple[int, int]]:
      a, b = rn    
      r = 1000
      while r != 0:
          q, r = euclid(a, b)
          yield b, q
          a = b
          b = r

  def r2cf(rn: Rational) -> Iterator[int]:
      def second(x: tuple):
          return x[1]
      return map(second, r2cf_(rn))
#+end_src

Now we can use =r2cf= to calculate the coefficients. I use a generator to represent the returned coefficients, because continued fractions can have infinite number of terms. However, the continuous fraction representations of rational numbers are always finite.
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  nc = r2cf(Rational(254, 100))
  print(list(nc))
#+end_src

#+RESULTS:
: [2, 1, 1, 5, 1, 3]

This means that
#+begin_src python :exports none :noweb no-export :results output raw :dir ../src/
  <<DEMO_IMPORTS>>
  <<LATEX_UTILS>>
  show_cf_expansion(Rational(254, 100))
#+end_src

#+RESULTS:
\[
\frac{ 254 }{ 100 }=
2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}
\]

We can display the process in a tabular format. For example:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(r2cf_tab(Rational(254, 100)))
#+end_src

#+RESULTS:
:   254
:   100   2   
:    54   1   
:    46   1   
:     8   5   
:     6   1   
:     2   3   
:     0
: 

Interestingly, the reciprocal of $\frac{254}{100}$ (that is, $\frac{100}{254}$) is represented by the following as a continued fraction:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  nc = r2cf(Rational(100, 254))
  print(list(nc))
#+end_src

#+RESULTS:
: [0, 2, 1, 1, 5, 1, 3]

It's the same sequence with an additional 0 at the beginning! This is our first clue that a continued fraction can be transformed by performing some operations at the beginning of the =r2cf= process.

However, it's not obvious how to perform algebraically meaningful transformations. For example, if we multiple the rational number by two, the continued fraction series appear to be quite different. It's not clear how we get [0, 1, 3, 1, 2, 2, 1, 2] from [0, 2, 1, 1, 5, 1, 3]. We'll come back to this question a little bit later. 
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(r2cf(Rational(200, 254))))
#+end_src

#+RESULTS:
: [0, 1, 3, 1, 2, 2, 1, 2]

*  Convergents
Given a continued fraction, how do we calculate the value? If the series is finite, we can easily write a recursive function. However, if it's an infinite series, we need a method to incrementally approximate the value as more coefficients are received. Also, we want the evaluation to be accumulative, so that each update is based on the previous one.

This question has an easy solution if we use rational numbers in the approximation. Such a series is called a convergent. The formula can be easily derived with mathematical induction, and it is implemented below. For the moment, we'll see it just a convenience to get the job done. We'll get deeper into its meaning in the next section.
#+begin_src python :noweb yes :tangle ../src/cont_frac.py
  def cf_convergent0(cf: Iterator[int]) -> Iterator[Rational]:
      p1, p0 = 1, 0
      q1, q0 = 0, 1
    
      for a in cf:
          p = a * p1 + p0
          q = a * q1 + q0
          yield Rational(p, q)

          p0, p1 = p1, p
          q0, q1 = q1, q
#+end_src

For example, for the continued fraction $2, 1, 1, 5, 1, 3$, we get
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_convergent0(iter([2, 1, 1, 5, 1, 3]))))
#+end_src

#+RESULTS:
: [2/1, 3/1, 5/2, 28/11, 33/13, 127/50]

In other words, 
#+begin_src python :exports none :noweb no-export :results output raw :dir ../src/
  <<LATEX_UTILS>>
  print("$" + latex_cf([2, 1, 1, 5, 1, 3]) + "$")
#+end_src

#+RESULTS:
$2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}$
can be approximated with
#+begin_src python :exports none :noweb no-export :results output raw :dir ../src/
  <<DEMO_IMPORTS>>
  <<LATEX_UTILS>>
  show_rational_series(iter([2, 1, 1, 5, 1, 3]))
#+end_src

#+RESULTS:
$\frac{2}{1}$,$\frac{3}{1}$,$\frac{5}{2}$,$\frac{28}{11}$,$\frac{33}{13}$,$\frac{127}{50}$
.

* Continued fraction approximation as function compositions
Given the first 3 terms in a continued fraction [5, 1, 4...], let $x$ denote the reciprocal of the value of the remaining series. We can express the convergent as $f_1(x)$, $f_2(x)$, $f_3(x)$..., where

\begin{equation*}
    f_1(x) = 5 + \frac{1}{x}
\end{equation*}

\begin{equation*}
    f_2(x) = 5 + \frac{1}{1 + \frac{1}{x}} = f_1(1 + \frac{1}{x})
\end{equation*}

\begin{equation*}
    f_3(x) = 5 + \frac{1}{1 + \frac{1}{4 + \frac{1}{x}}} = f_1(f_2(4 + \frac{1}{x}))
\end{equation*}

Or more compactly, let
\begin{equation*}
    h(a, x) = a + \frac{1}{x}
\end{equation*}

then
\begin{equation*}
    f_1(x) = h(5, x)
\end{equation*}

\begin{equation*}
    f_2(x) = h(5, h(1, x))
\end{equation*}

\begin{equation*}
    f_3(x) = h(5, h(1, h(4, x))) 
\end{equation*}

This way, we express the approximation as a recursive process. If the continued fraction stops at the third term, its value is $h_3(\infty) = h(5, h(1, h(4, \infty)))$. Infinity might seem odd, but remember that $x$ is the reciprocal of the rest of the sequence. So it just means that the rest of the sequence evaluates to 0.

Before we rush to translate this into code, but let's dig deeper. If we use column vectors to represent rational numbers:

\begin{equation*}
    \begin{bmatrix}
           p \\
           q
    \end{bmatrix} = \frac{p}{q}
\end{equation*}

Then we can turn everything into linear algebra:

\begin{equation*}
    h(a, x) = a + \frac{1}{x} = \frac{ax + 1}{x} =

    \begin{bmatrix}
        ax + 1 \\
        x
    \end{bmatrix}

    =

    \begin{bmatrix}
        a & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix}
\end{equation*}

Furthermore, 

\begin{equation*}
    f_3(x) = h(5, h(1, h(4, x))) =

    \begin{bmatrix}
        5 & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        1 & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        4 & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix}

    = 

    \begin{bmatrix}
        29 & 6 \\
        5 & 1
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix}

\end{equation*}

So, the 2-by-2 matrix

$\begin{bmatrix}
    29 & 6 \\
     5 & 1
\end{bmatrix}$

is a function that represents an approximation of a continued fraction with more terms. Applying this function to the remains of the series gives the exact value of the continued fraction. If continued fractions has only 3 terms, we terminate the process by evaluating

\begin{equation*}
    f_3(
        \begin{bmatrix}
            1 \\
            0
        \end{bmatrix}
    ) = 

    \begin{bmatrix}
        29 & 6 \\
         5 & 1
    \end{bmatrix}

    \begin{bmatrix}
        1 \\
        0 
    \end{bmatrix}

    = 

    \begin{bmatrix}
        29 \\
         5
    \end{bmatrix}

    = \frac{29}{5}
\end{equation*}
.

Applying $f_3(x)$ to
$\begin{bmatrix}
    1 \\
    0 
\end{bmatrix}$ turns the function into a rational value, by taking the first column of the matrix.

* Convergents: matrix formulation
Now, we are ready to rewrite the formula in =cf_convergence0= as matrix multiplications:
#+begin_src python :noweb yes :tangle ../src/cont_frac.py
  def h(a):
      return np.array([[a, 1], [1,0]])

  def cf_convergent1_(cdf: Iterator[int]) -> Iterator:
      res = np.array([[1, 0], [0, 1]])
      for a in cdf:
          res = np.matmul(res, h(a))
          yield res

  def cf_convergent1(cdf: Iterator[int]) -> Iterator[Rational]:
      mLst = cf_convergent1_(cdf)
      for m in mLst:
          yield Rational(m[0, 0], m[1, 0])
#+end_src

Let's try it on the example given in the previous section:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_convergent1(iter([5, 1, 4]))))
#+end_src

#+RESULTS:
: [5/1, 6/1, 29/5]

Here's a longer sequence that we used previously:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  print(list(cf_convergent1(iter([2, 1, 1, 5, 1, 3]))))
#+end_src

#+RESULTS:
: [2/1, 3/1, 5/2, 28/11, 33/13, 127/50]

A very charming thing that Gosper did was that he used a compact tabulated format to illustrate the process. It's unnecessary for the computation, but I think it looks pretty cool:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  cf_convergent1_tab(iter([5, 1, 4]))
#+end_src

#+RESULTS:
:        4   1   5
:   29   6   5   1   0
:    5   1   1   0   1


This table is read from the right to the left. The direction is unnatural, but it's needed to preserve the normal representation of matrices. The first row represents the continued fraction.

We can calculate the matrices for each addition term in the continued fraction:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  itr = cf_convergent1_(iter([5, 1, 4]))
  print(next(itr),"\n")
  print(next(itr),"\n")
  print(next(itr))
#+end_src

#+RESULTS:
: [[5 1]
:  [1 0]] 
: 
: [[6 5]
:  [1 1]] 
: 
: [[29  6]
:  [ 5  1]]

We can see that the matrices shift leftwards in the table above. Interpreting columns as rational numbers, we can read the convergent one by one off the table: $\frac{5}{1}$, $\frac{6}{1}$, and $\frac{29}{5}$.

Here's a longer example:
#+begin_src python :exports both :noweb no-export :results output :dir ../src/
  <<DEMO_IMPORTS>>
  cf_convergent1_tab(iter([2, 1, 1, 5, 1, 3]))
#+end_src

#+RESULTS:
:        3   1   5   1   1   2
:  127  33  28   5   3   2   1   0
:   50  13  11   2   1   1   0   1

* Simple transformations of continued fractions
Recall that we started this article by describing a recursive algorithm for converting a rational number into a continued fraction. Then we developed a recursive algorithm for approximating a continued fraction by a series of rational numbers. Now, we'll combine these two ideas.

Recall that in a previous example, we express the third term in the convergent of [5, 1, 4...] as

\begin{equation*}
    f_3(x) =
    \begin{bmatrix}
        29 & 6 \\
        5 & 1
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix} =
    \frac{29x + 6}{5x + 1}
\end{equation*}

Observe that
\begin{equation*}
    f_3(x) =
    \begin{bmatrix}
        29 & 6 \\
        5 & 1
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix} =
    \frac{29x + 6}{5x + 1}
\end{equation*}




In the previous section, we start with a continued fraction $a$ represented as $[a_1, a_2, ...]$, and use matrix multiplication to calculate an rational series to approximate it. What if $a$ is embedded in another expression? Let $b=2a$. 

* Appendix: Tabulated displays
#+begin_src python :tangle ../src/cont_frac.py
  def r2cf_tab(rn: Rational):
      def row(st: str, x: tuple):
          b, q = x
          return st + f"{b : > 5}  {q : < 5}\n"
      str0 = f"{rn.a : > 5}\n"
      return reduce(row, r2cf_(rn), str0) + f"{0 : > 5}\n"
#+end_src

#+begin_src python :noweb yes :tangle ../src/cont_frac.py
  def cf_convergent1_tab_pp(row1, row2, row3):
      def f_(item):
          if item is None:
              return f"{'': >4}"
          else:
              return f"{item: >4}"

      print(reduce(lambda a, b: a + b, map(f_, row1), ""))
      print(reduce(lambda a, b: a + b, map(f_, row2), ""))
      print(reduce(lambda a, b: a + b, map(f_, row3), ""))    

  def cf_convergent1_tab(cf: Iterator[int]):
      row1, row2, row3 = [], [], []
      row2 = [0, 1]
      row3 = [1, 0]

      (cf1, cf2) = tee(cf)
      for (mat, a) in zip(cf_convergent1_(cf1), cf2):
          row1.append(a)
          row2.append(mat[0][0])
          row3.append(mat[1][0])

      row1.reverse()
      row2.reverse()
      row3.reverse()

      row1 = [None] + row1
      cf_convergent1_tab_pp(row1, row2, row3)
#+end_src

* Appendix: LaTeX utilities
#+begin_src python :tangle no :noweb-ref LATEX_UTILS
  def latex_cf(lst: list):
      if len(lst) == 1:
          return str(lst[0])
      else:
          x = str(lst[0]) + "+"
          x = x + r"\frac{1}{" + latex_cf(lst[1:]) + "}"
          return x

  def latex_rational(r: Rational):
      return r"\frac{" + str(r.a) + "}{" + str(r.b) + "}"

  def show_cf_expansion(r: Rational):
      print(r"\[")
      print(r"\frac{", r.a, "}{", r.b, "}=")
      nc = list(r2cf(r))
      print(latex_cf(nc))
      print(r"\]")

  def show_rational_series(itr: Iterator[int]):
      rLst = list(cf_convergent0(itr))
      s = ""
      for r in rLst:
          s = s + "$" + latex_rational(r) + "$" + ","

      print(s[:-1])
#+end_src

* Appendix: imports
#+begin_src python :tangle no :noweb-ref IMPORTS
  import math
  import numpy as np
  from typing import NamedTuple, Iterator, Tuple
  from functools import reduce
  from itertools import tee
#+end_src

#+begin_src python :tangle no :noweb-ref DEMO_IMPORTS
  from cont_frac import *
#+end_src
