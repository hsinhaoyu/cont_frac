We have been dealing with one continued fraction at a time. In those situations, all operations involve functions of the form $f(x) = \frac{px+q}{rx+s}$. They are known as /homographic functions/, and they can be represented by the matrix $\begin{bmatrix} p & q \\ r & s \end{bmatrix}$. How do we generalize it to operations involving two continued fractions?

The problem is solved with /bihomographic functions/ of the form $f(x, y) = \frac{axy + bx + cy + d}{exy + fx + gy + h}$, where $x$ and $y$ are the unknown terms for the two continued fractions $a$ and $b$ respectively. We can write it in matrix form as:

\begin{equation*}
f(x, y) = \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} b & d \\ a & c \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} \bigg/
          \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} f & h \\ e & g \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix}
\end{equation*}


Since we are working with two matrices as a single entity, it's natural to use tensors to represent bihomographic functions:
#+begin_src python :noweb no :noweb-ref BIHOMOGRAPHY
  # Tensor representations of bihomographic functions

  def tFrom2x4(m: np.ndarray) -> np.ndarray:
      ((a, b, c, d), (e, f, g, h)) = m.tolist()
      return np.array([[[b, d], [a, c]], [[f, h], [e, g]]])

  def tTo2x4(m: np.ndarray) -> np.ndarray:
      (((b, d), (a, c)), ((f, h), (e, g))) = m.tolist()
      return np.array([[a, b, c, d], [e, f, g, h]])
#+end_src

I need a utility function to make it easy to access so many numbers in the tensors:
#+begin_src python :tangle no :noweb-ref BIHOMOGRAPHY
  def tensor_ref(t: np.ndarray, label: str) -> Union[int, Tuple[int, int]]:
      assert t.shape == (2, 2, 2)
      assert label in ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'xy', 'x', 'y', '1']
      lookup = {}
      lookup['a']  = t[0,1,0]
      lookup['b']  = t[0,0,0]
      lookup['c']  = t[0,1,1]
      lookup['d']  = t[0,0,1]
      lookup['e']  = t[1,1,0]
      lookup['f']  = t[1,0,0]
      lookup['g']  = t[1,1,1]
      lookup['h']  = t[1,0,1]
      lookup['xy'] = lookup['a'], lookup['e']
      lookup['x']  = lookup['b'], lookup['f']
      lookup['y']  = lookup['c'], lookup['g']
      lookup['1']  = lookup['d'], lookup['h']
      return lookup[label]
#+end_src

What happens to $f(x, y)$, with the addition of a new term $a_n$ of $a$?

\begin{equation*}
f(a_n + \frac{1}{x}, y) = \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} a_n b  + d & b \\ a_n a + c & a \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} \bigg /
                          \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} a_n f  + h & f \\ a_n e + g & e \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} 
\end{equation*}

This is familiar, isn't it? It's exactly the same update rule that we use for updating the convergents! All we need to do is to right-multiply $\begin{bmatrix} a_n & 1 \\ 1 & 0\end{bmatrix}$ the two matrices.

We can do the same with a new term $b_n$ for $b$:

\begin{equation*}
f(x, b_n + \frac{1}{y}) = \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} a & c \\ b_n a + b & b_n c + d \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} \bigg /
                          \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} e & g \\ b_n e + f & b_n g + h \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} 
\end{equation*}

This is basically the same thing, except that the direction is different. This corresponds to left-multiplying $\begin{bmatrix} 0 & 1 \\ 1 & b_n\end{bmatrix}$.

The above suggests an elegant way to visualize continued fraction arithmetic: if we imagine that two matrices form a 2x2x2 cube, this cube moves leftwards upon receiving a new term of $a$, and it moves downwards upon receiving a new term of $b$. As before, we'll also use the Euclidean algorithm to convert the bihomographic function into continued fractions. When we get to perform the Euclidean step, the 2x2x2 cube moves in the third dimension. The following figure illustrates that continued fraction arithmetic is a direct generalization of the 2D case:

#+attr_html: :width 500px
[[../figs/cf_space.png]]

To implement the cube movements in Python, I use my favorite Numpy function: =einsum= (Einstein's sum; see [[https://ajcr.net/Basic-guide-to-einsum/][this tutorial]]):
#+begin_src python :noweb no :noweb-ref BIHOMOGRAPHY
  def apply_a(t: np.ndarray, a: int) -> np.ndarray:
      ha = h(a)
      return np.einsum('dyx,xz->dyz', t, ha)

  def h_rotated(b: int) -> np.ndarray:
      return np.array([[0, 1], [1, b]])

  def apply_b(t: np.ndarray, b: int) -> np.ndarray:
      hb = h_rotated(b)
      return np.einsum('zy,dyx->dzx', hb, t)

  def apply_ab(t: np.ndarray, term: int, label: str) -> np.ndarray:
      assert label in ['a', 'b']
      if label == 'a':
          return apply_a(t, term)
      else:
          return apply_b(t, term)
#+end_src

