<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-04-09 Sat 23:11 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Understanding Bill Gospher's continued fraction arithmetic (implemented in Python)</title>
<meta name="author" content="Hsin-Hao Yu" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "left",
        displayIndent: "0em",

        "HTML-CSS": { scale: 85,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 85,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 85},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Understanding Bill Gospher's continued fraction arithmetic (implemented in Python)</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org742a100">1. Continued fraction representations of rational numbers</a></li>
<li><a href="#org4665702">2. Convergents</a></li>
<li><a href="#org9a9cf26">3. Continued fraction approximation as function compositions</a></li>
<li><a href="#orgd5ec462">4. Calculating convergents using the matrix notation</a></li>
<li><a href="#orgc531dfd">5. Turning convergents into continued fractions</a></li>
<li><a href="#org8fa6f25">6. Simple transformations of continued fractions</a></li>
<li><a href="#orgcd776aa">7. Appendix 1: Calculating the quotient and the reminder of a convergent in matrix form</a></li>
<li><a href="#org452f10c">8. Appendix: Additional tests</a></li>
<li><a href="#org142c555">9. Appendix: Display utilities</a></li>
<li><a href="#orgf1eb552">10. Appendix: Tabulated displays</a></li>
<li><a href="#org1f86786">11. Appendix: LaTeX utilities</a></li>
<li><a href="#org0f88bcd">12. Appendix: Imports</a></li>
</ul>
</div>
</div>
<div id="outline-container-org742a100" class="outline-2">
<h2 id="org742a100"><span class="section-number-2">1.</span> Continued fraction representations of rational numbers</h2>
<div class="outline-text-2" id="text-1">
<p>
Since we'll use rational numbers a lot, let's define a class:
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;IMPORTS&gt;&gt;
<span class="org-comment-delimiter"># </span><span class="org-comment">Rational(a, b) = a/b</span>
<span class="org-keyword">class</span> <span class="org-type">Rational</span>(NamedTuple(<span class="org-string">'Rational'</span>, [(<span class="org-string">'a'</span>, <span class="org-builtin">int</span>), (<span class="org-string">'b'</span>, <span class="org-builtin">int</span>)])):
    <span class="org-keyword">def</span> <span class="org-function-name">__repr__</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> f<span class="org-string">'{self.a}/{self.b}'</span>
</pre>
</div>

<p>
How to convert a rational number to a continued fraction? Observing that
</p>

<p>
\[
\frac{254}{100}
= 2 + \frac{54}{100}
= 2 + \frac{1}{\frac{100}{54}}
= 2 + \frac{1}{1 + \frac{46}{54}}
= 2 + \frac{1}{1 + \frac{1}{\frac{46}{54}}}
\]
</p>

<p>
it should be obvious that the solution is just the <a href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Euclidean algorithm</a> for finding the greatest common divider:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">qr</span>(a: <span class="org-builtin">int</span>, b: <span class="org-builtin">int</span>) -&gt; Tuple[<span class="org-builtin">int</span>, <span class="org-builtin">int</span>]:
    <span class="org-doc">"""a = b * q + r"""</span>
    <span class="org-variable-name">q</span> = math.floor(a / b)  <span class="org-comment-delimiter"># </span><span class="org-comment">the quotient</span>
    <span class="org-variable-name">r</span> = a - b * q          <span class="org-comment-delimiter"># </span><span class="org-comment">the reminder</span>
    <span class="org-keyword">return</span> (q, r)

<span class="org-keyword">def</span> <span class="org-function-name">euclid_</span>(rn: Rational) -&gt; Iterator[Tuple[<span class="org-builtin">int</span>, <span class="org-builtin">int</span>]]:
    <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span> = rn    
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-variable-name">q</span>, <span class="org-variable-name">r</span> = qr(a, b)
        <span class="org-keyword">yield</span> b, q
        <span class="org-keyword">if</span> r == 0:
            <span class="org-keyword">break</span>
        <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span> = b, r

<span class="org-keyword">def</span> <span class="org-function-name">euclid</span>(rn: Rational) -&gt; Iterator[<span class="org-builtin">int</span>]:
    <span class="org-keyword">def</span> <span class="org-function-name">second</span>(x: <span class="org-builtin">tuple</span>):
        <span class="org-keyword">return</span> x[1]
    <span class="org-keyword">return</span> <span class="org-builtin">map</span>(second, euclid_(rn))
</pre>
</div>

<p>
Now we can use <code>euclid</code> to calculate the coefficients. I use a Python generator to represent the returned coefficients, because continued fractions can have infinite number of coefficients. However, the continuous fraction representations of rational numbers are always finite.
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;
<span class="org-variable-name">nc</span> = euclid(Rational(254, 100))
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(nc))
</pre>
</div>

<pre class="example">
[2, 1, 1, 5, 1, 3]
</pre>


<p>
This means that
\[
\frac{ 254 }{ 100 }=
2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}
\]
</p>

<p>
We can display the process in a tabular format. For example:
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;
<span class="org-keyword">print</span>(euclid_tab(Rational(254, 100)))
</pre>
</div>

<pre class="example">
254
100   2   
 54   1   
 46   1   
  8   5   
  6   1   
  2   3   
  0

</pre>


<p>
This table shows that 2 (the penultimate row) is the greatest common divider of 254 and 100. The byproduct of this process, the quotients displayed on the right, are the coefficients.
</p>

<p>
Interestingly, the reciprocal of \(\frac{254}{100}\) (that is, \(\frac{100}{254}\)) is represented by the following as a continued fraction:
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;
<span class="org-variable-name">nc</span> = euclid(Rational(100, 254))
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(nc))
</pre>
</div>

<pre class="example">
[0, 2, 1, 1, 5, 1, 3]
</pre>


<p>
It's the same sequence with an additional 0 at the beginning! This is our first clue that a continued fraction can be transformed by performing some operations at the beginning of the <code>euclid</code> process.
</p>

<p>
However, it's not obvious how to perform algebraically meaningful transformations. For example, if we multiple the rational number by 2, the continued fraction series appear to be quite different.
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(euclid(Rational(200, 254))))
</pre>
</div>

<pre class="example">
[0, 1, 3, 1, 2, 2, 1, 2]
</pre>


<p>
It's not clear how we get \([0, 1, 3, 1, 2, 2, 1, 2]\) from \([0, 2, 1, 1, 5, 1, 3]\). We'll come back to this question a little bit later. 
</p>
</div>
</div>

<div id="outline-container-org4665702" class="outline-2">
<h2 id="org4665702"><span class="section-number-2">2.</span> Convergents</h2>
<div class="outline-text-2" id="text-2">
<p>
Given a continued fraction, how do we calculate the value? If the series is finite, we can easily write a recursive function. However, if it's an infinite series, we need a method to incrementally approximate the value as more coefficients are received. Also, we want the evaluation to be accumulative, so that each update is based on the previous one.
</p>

<p>
This question has an easy solution if we use rational numbers in the approximation. Each approximation in the series is called a convergent. The formula for the convergents can be derived easily with mathematical induction, and it is implemented below. For the moment, we'll see it just a convenience to get the job done. We'll get deeper into its meaning in the next section.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_convergent0</span>(cf: Iterator[<span class="org-builtin">int</span>]) -&gt; Iterator[Rational]:
    <span class="org-variable-name">p1</span>, <span class="org-variable-name">p0</span> = 1, 0
    <span class="org-variable-name">q1</span>, <span class="org-variable-name">q0</span> = 0, 1

    <span class="org-keyword">for</span> a <span class="org-keyword">in</span> cf:
        <span class="org-variable-name">p</span> = a * p1 + p0
        <span class="org-variable-name">q</span> = a * q1 + q0
        <span class="org-keyword">yield</span> Rational(p, q)

        <span class="org-variable-name">p0</span>, <span class="org-variable-name">p1</span> = p1, p
        <span class="org-variable-name">q0</span>, <span class="org-variable-name">q1</span> = q1, q
</pre>
</div>

<p>
For example, for the continued fraction \([2, 1, 1, 5, 1, 3]\), we get
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_convergent0(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3]))))
</pre>
</div>

<pre class="example">
[2/1, 3/1, 5/2, 28/11, 33/13, 127/50]
</pre>


<p>
In other words, 
\(2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}\)
can be approximated with
\(\frac{2}{1}\),\(\frac{3}{1}\),\(\frac{5}{2}\),\(\frac{28}{11}\),\(\frac{33}{13}\),\(\frac{127}{50}\)
.
</p>
</div>
</div>

<div id="outline-container-org9a9cf26" class="outline-2">
<h2 id="org9a9cf26"><span class="section-number-2">3.</span> Continued fraction approximation as function compositions</h2>
<div class="outline-text-2" id="text-3">
<p>
Given the first 3 terms in a continued fraction \([5, 1, 4...]\), let \(x\) denote the reciprocal of the value of the remaining series. We can express the convergent as \(f_1(x)\), \(f_2(x)\), \(f_3(x)\)&#x2026;, where
</p>

\begin{equation*}
    f_1(x) = 5 + \frac{1}{x}
\end{equation*}

\begin{equation*}
    f_2(x) = 5 + \frac{1}{1 + \frac{1}{x}} = f_1(1 + \frac{1}{x})
\end{equation*}

\begin{equation*}
    f_3(x) = 5 + \frac{1}{1 + \frac{1}{4 + \frac{1}{x}}} = f_1(f_2(4 + \frac{1}{x}))
\end{equation*}

<p>
Or more compactly, let
</p>
\begin{equation*}
    h(a, x) = a + \frac{1}{x}
\end{equation*}

<p>
then
</p>
\begin{equation*}
    f_1(x) = h(5, x)
\end{equation*}

\begin{equation*}
    f_2(x) = h(5, h(1, x))
\end{equation*}

\begin{equation*}
    f_3(x) = h(5, h(1, h(4, x))) 
\end{equation*}

<p>
This way, we express the approximation as a recursive process. If the continued fraction stops at the third term, its value is \(h_3(\infty) = h(5, h(1, h(4, \infty)))\). Infinity might seem odd here, but remember that \(x\) is the reciprocal of the rest of the sequence. So it just means that the rest of the sequence evaluates to 0.
</p>

<p>
Before we rush to translate this into code, let's dig deeper. If we use column vectors to represent rational numbers:
</p>

\begin{equation*}
    \begin{bmatrix}
           p \\
           q
    \end{bmatrix} = \frac{p}{q}
\end{equation*}

<p>
Then we can turn everything into linear algebra:
</p>

\begin{equation*}
    h(a, x) = a + \frac{1}{x} = \frac{ax + 1}{x}
\end{equation*}

<p>
can be written in our matrix notation as
</p>

\begin{equation*}

    \begin{bmatrix}
        ax + 1 \\
        x
    \end{bmatrix}

    =

    \begin{bmatrix}
        a & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix}
\end{equation*}

<p>
Furthermore, 
</p>

\begin{equation*}
    f_3(x) = h(5, h(1, h(4, x)))
\end{equation*}

<p>
can be written as
</p>

\begin{equation*}

    \begin{bmatrix}
        5 & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        1 & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        4 & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix}

    = 

    \begin{bmatrix}
        29 & 6 \\
        5 & 1
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix}

\end{equation*}

<p>
So, the 2-by-2 matrix
</p>

<p>
\(\begin{bmatrix}
    29 & 6 \\
     5 & 1
\end{bmatrix}\)
</p>

<p>
represents a function that approximates a continued fraction with more terms. Applying this function to the remains of the series gives the exact value of the continued fraction. If the continued fractions has only 3 terms, we terminate the process by evaluating
</p>

\begin{equation*}

    \begin{bmatrix}
        29 & 6 \\
         5 & 1
    \end{bmatrix}

    \begin{bmatrix}
        1 \\
        0 
    \end{bmatrix}

    = 

    \begin{bmatrix}
        29 \\
         5
    \end{bmatrix}

    = \frac{29}{5}
\end{equation*}

<p>
Multiplying the matrix with
\(\begin{bmatrix}
    1 \\
    0 
\end{bmatrix}\) turns the function into a rational value, which is the first column of the matrix.
</p>
</div>
</div>

<div id="outline-container-orgd5ec462" class="outline-2">
<h2 id="orgd5ec462"><span class="section-number-2">4.</span> Calculating convergents using the matrix notation</h2>
<div class="outline-text-2" id="text-4">
<p>
Now, we are ready to rewrite the formula in <code>cf_convergence0</code> as matrix multiplications:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">h</span>(a):
    <span class="org-keyword">return</span> np.array([[a, 1], [1,0]])

<span class="org-keyword">def</span> <span class="org-function-name">cf_convergent1_</span>(cf: Iterator[<span class="org-builtin">int</span>]) -&gt; Iterator:
    <span class="org-variable-name">res</span> = np.array([[1, 0], [0, 1]])
    <span class="org-keyword">for</span> a <span class="org-keyword">in</span> cf:
        <span class="org-variable-name">res</span> = np.matmul(res, h(a))
        <span class="org-keyword">yield</span> res

<span class="org-keyword">def</span> <span class="org-function-name">cf_convergent1</span>(cf: Iterator[<span class="org-builtin">int</span>]) -&gt; Iterator[Rational]:
    <span class="org-variable-name">mLst</span> = cf_convergent1_(cf)
    <span class="org-keyword">for</span> m <span class="org-keyword">in</span> mLst:
        <span class="org-keyword">yield</span> Rational(m[0, 0], m[1, 0])
</pre>
</div>

<p>
Let's try it on the example given in the previous section:
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_convergent1(<span class="org-builtin">iter</span>([5, 1, 4]))))
</pre>
</div>

<pre class="example">
[5/1, 6/1, 29/5]
</pre>


<p>
Here's a longer sequence that we used previously:
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_convergent1(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3]))))
</pre>
</div>

<pre class="example">
[2/1, 3/1, 5/2, 28/11, 33/13, 127/50]
</pre>


<p>
A very charming thing that Gosper did was that he used a compact tabulated format to illustrate the process. It's unnecessary for the computation, but I think it looks pretty cool:
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;
cf_convergent1_tab(<span class="org-builtin">iter</span>([5, 1, 4]))
</pre>
</div>

<pre class="example">
     4   1   5    
29   6   5   1   0
 5   1   1   0   1
</pre>


<p>
This table is read from the right to the left. The right-to-left direction takes some getting used to, but it's needed to preserve the normal representation of matrices.
</p>

<p>
The first row represents the coefficients of the continued fraction. To understand the other numbers, we calculate the matrices for each additional coefficient in the continued fraction:
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;
<span class="org-variable-name">itr</span> = cf_convergent1_(<span class="org-builtin">iter</span>([5, 1, 4]))
<span class="org-keyword">print</span>(<span class="org-builtin">next</span>(itr),<span class="org-string">"\n"</span>)
<span class="org-keyword">print</span>(<span class="org-builtin">next</span>(itr),<span class="org-string">"\n"</span>)
<span class="org-keyword">print</span>(<span class="org-builtin">next</span>(itr))
</pre>
</div>

<pre class="example">
[[5 1]
 [1 0]] 

[[6 5]
 [1 1]] 

[[29  6]
 [ 5  1]]
</pre>


<p>
You can see these matrices shift leftwards in the tabular representation, with adjacent matrices sharing a column. To see why, suppose that the current matrix is
\(\begin{bmatrix}
    x_{11} & x_{12} \\
    x_{21} & x_{22}
\end{bmatrix}\), and we have to update it with a new term \(a\) in the continued fraction. The updated matrix is
</p>
\begin{equation*}
    \begin{bmatrix}
        x_{11} & x_{12} \\
        x_{21} & x_{22}
    \end{bmatrix}
    \begin{bmatrix}
        a & 1 \\
        1 & 0
    \end{bmatrix} =
    \begin{bmatrix}
        ax_{11} & x_{11} \\
        ax_{21} & x_{21}
    \end{bmatrix}
\end{equation*}

<p>
This explains the shift, and we have recovered the formula in <code>cf_convergent0</code>.
</p>

<p>
Here's a longer series:
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;
cf_convergent1_tab(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3]))
</pre>
</div>

<pre class="example">
      3   1   5   1   1   2    
127  33  28   5   3   2   1   0
 50  13  11   2   1   1   0   1
</pre>
</div>
</div>

<div id="outline-container-orgc531dfd" class="outline-2">
<h2 id="orgc531dfd"><span class="section-number-2">5.</span> Turning convergents into continued fractions</h2>
<div class="outline-text-2" id="text-5">
<p>
What if we want to calculate the convergents using the same process in <code>cf_convergent1</code>, but we want the output to be in the form of a continued fraction? At this point, this seems to be a pointless exercise, because a continued fraction is what we start with! But it will become useful in the coming sections.
</p>

<p>
Let's take the continued fraction \([5, 1, 4... ]\) as an example. Since we already know that the third convergent of \([5, 1, 4]\) is \(\frac{29}{5}\), can't we just turn \(\frac{29}{5}\) into a continued fraction? Remember that the third convergent of the infinite series \([5, 1, 4... ]\) is
\(\begin{bmatrix}
    29 & 6 \\
     5 & 1
\end{bmatrix}\), which represents the function \(\frac{29x + 6}{5x + 1}\). This is not the same as the third convergent of the finite series \([5, 1, 4]\), which is the rational number \(\frac{29}{5}\).
</p>

<p>
So what do we do? It's still the Euclidean algorithm, but have to use it symbolically rather than numerically.
</p>

<p>
The most important step in the Euclidean algorithm is to express a number in terms of the quotient and the reminder of another number (see <code>qr()</code> in <code>euclid_</code>). I implemented the symbolic version of this operation in a function called <code>qr_matrix</code> in the Appendix. Consider the second convergent of \([5, 1, 4...]\), we use <code>qr_matrix</code> to calculate the quotient and the reminder:
</p>

<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;
<span class="org-keyword">print</span>(qr_matrix(np.array([[6, 5], [1, 1]])))
</pre>
</div>

<pre class="example">
(5, array([[1, 1],
       [1, 0]]))
</pre>


<p>
This means that \(f_2(x) = \frac{6x+5}{1x+1} = 5 + \frac{1}{\frac{1x + 1}{x}}\). Sine \(\lim_{x \to 0} f_2(x) = 5\) and \(\lim_{x \to \infty} f_2(x) = 6\), the function is bounded by \(5 \leq f_2(x) < 6\). The quotient has to be 5, because the function is 6 only at infinity. 
</p>

<p>
Let's try another example: The 3rd convergent of the series is
\(\begin{bmatrix}
    29 & 6 \\
     5 & 1
\end{bmatrix}\).
</p>

<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;
<span class="org-keyword">print</span>(qr_matrix(np.array([[29, 6], [5, 1]])))
</pre>
</div>

<pre class="example">
None
</pre>


<p>
Why does <code>qr_matrix</code> returns None? Calculus shows that the function is bounded \(5.8 < f_3(x) \leq 6\). It's similar to the previous example, but in this case, the bounds are not tight enough to decide if the quotient is 5 or 6. That's why <code>qr_matrix</code> returns <code>None</code>, indicating that we have to wait for further information to resolve the quotient.
</p>

<p>
Note that we can't pick the smaller number 5, and pass the error to the next term. This is because for any rational number, the coefficients of the corresponding continued fraction is unique. We therefore have to get the coefficient 100% right before we move on to the next one.
</p>

<p>
Now we are ready to implement the symbolic form of the Euclidean algorithm:
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;QR_MATRIX&gt;&gt;

<span class="org-keyword">def</span> <span class="org-function-name">euclid_matrix_</span>(m):
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-variable-name">res</span> = qr_matrix(m)
        <span class="org-keyword">if</span> res:
            <span class="org-variable-name">q</span>, <span class="org-variable-name">r</span> = res
            <span class="org-keyword">yield</span> q, r
            <span class="org-variable-name">m</span> = r
        <span class="org-keyword">else</span>:
            <span class="org-keyword">break</span>
</pre>
</div>

<p>
Let's try it on
\(\begin{bmatrix}
    70 & 29 \\
    12 & 5
\end{bmatrix}\)
</p>

<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;
<span class="org-variable-name">q</span> = euclid_matrix_(np.array([[70, 29], [12, 5]]))
<span class="org-keyword">for</span> (r, m) <span class="org-keyword">in</span> q:
    <span class="org-keyword">print</span>(r, m)
</pre>
</div>

<pre class="example">
5 [[12  5]
 [10  4]]
1 [[10  4]
 [ 2  1]]
4 [[2 1]
 [2 0]]
</pre>


<p>
So there is enough information in \(\frac{70x+29}{12x+5}\) to precisely determine 3 coefficients. 
</p>

<p>
As before, Gospher stacked the matrices in a compact format to illustrate the process:
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;
<span class="org-variable-name">q</span> = euclid_matrix_tab(np.array([[70, 29], [12, 5]]))
<span class="org-keyword">print</span>(q)
</pre>
</div>

<pre class="example">
        
  70  29    
  12   5  5  
  10   4  1  
   2   1  4  
   2   0
None
</pre>


<p>
Now, we can combine convergent calculation with the symbolic Euclidean algorithm:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_convergent2_</span>(cf: Iterator[<span class="org-builtin">int</span>], m0 = np.identity(2, <span class="org-builtin">int</span>)) -&gt; Iterator:
    <span class="org-variable-name">m</span> = m0
    <span class="org-keyword">for</span> a <span class="org-keyword">in</span> cf:
        <span class="org-variable-name">m</span> = np.matmul(m, h(a))
        <span class="org-variable-name">q</span> = -1
        <span class="org-keyword">for</span> (q, r) <span class="org-keyword">in</span> euclid_matrix_(m):
            <span class="org-keyword">yield</span> q, r, m
            <span class="org-variable-name">m</span> = r
        <span class="org-keyword">if</span> q == -1:
            <span class="org-comment-delimiter"># </span><span class="org-comment">for this coefficient a, the convergent cannot be turned into a continued fraction</span>
            <span class="org-keyword">yield</span> (<span class="org-constant">None</span>, <span class="org-constant">None</span>, m)

    <span class="org-comment-delimiter"># </span><span class="org-comment">we will only reach this point if the series is finite</span>
    <span class="org-keyword">for</span> s <span class="org-keyword">in</span> euclid(Rational(m[0][0], m[0][1])):
        <span class="org-keyword">yield</span> s, <span class="org-constant">None</span>, m

<span class="org-keyword">def</span> <span class="org-function-name">cf_convergent2</span>(cf: Iterator[<span class="org-builtin">int</span>], m0 = np.identity(2, <span class="org-builtin">int</span>)) -&gt; Iterator:
    <span class="org-keyword">for</span> res <span class="org-keyword">in</span> cf_convergent2_(cf, m0):
        <span class="org-keyword">if</span> res:
            (q, r, m) = res
            <span class="org-keyword">if</span> q:
                <span class="org-comment-delimiter"># </span><span class="org-comment">cf_convergent2_ can return None to indicate that it needs more coefficients</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">to continue. It can be ignored</span>
                <span class="org-keyword">yield</span> q
</pre>
</div>

<p>
Run it on a sequence, and it just returns the same sequence. 
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_convergent2(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3]))))
</pre>
</div>

<pre class="example">
[2, 1, 1, 5, 1, 3]
</pre>


<p>
That seems to be anti-climatic for quite a bit of work&#x2026; but here's something cool. Gospher combined the two stacked matrix representations that we have seen already, to illustrate every step in the algorithm:
</p>

<div class="org-src-container">
<pre class="src src-python">&lt;&lt;DEMO_IMPORTS&gt;&gt;
cf_convergent2_tab(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3]), field_width = 2)
</pre>
</div>

<pre class="example">
  3 1 5 1 1 2  
        3 2 1 0  
      2 1 1 0 1  2
    6 1 1 0      1
  6 5 1 0        1
4 1 1 0          5
3 1 0            1
1 0            
</pre>
</div>
</div>

<div id="outline-container-org8fa6f25" class="outline-2">
<h2 id="org8fa6f25"><span class="section-number-2">6.</span> Simple transformations of continued fractions</h2>
<div class="outline-text-2" id="text-6">
<p>
In the previous section, we start with a continued fraction \(a\) represented as \([a_1, a_2, ...]\), and use matrix multiplication to calculate an rational series to approximate it. What if \(a\) is embedded in another expression? Let \(b=2a\). 
</p>
</div>
</div>

<div id="outline-container-orgcd776aa" class="outline-2">
<h2 id="orgcd776aa"><span class="section-number-2">7.</span> Appendix 1: Calculating the quotient and the reminder of a convergent in matrix form</h2>
<div class="outline-text-2" id="text-7">
<p>
This is just calculus
</p>


<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">flip_m</span> = np.array([[0, 1], [1, 0]])

<span class="org-keyword">def</span> <span class="org-function-name">qr_matrix</span>(m):
    <span class="org-variable-name">m2</span> = m.copy()

    <span class="org-keyword">if</span> m2[1][0] !=0 <span class="org-keyword">and</span> m2[1][1] !=0:
        <span class="org-variable-name">d0</span> = math.floor(m[0][0] / m[1][0])
        <span class="org-variable-name">d1</span> = math.floor(m[0][1] / m[1][1])

        <span class="org-comment-delimiter"># </span><span class="org-comment">the quotient is between d0 and d1 (inclusive)</span>
        (d0, d1) = <span class="org-builtin">sorted</span>([d0, d1])
        <span class="org-keyword">if</span> d0 == d1:
            <span class="org-comment-delimiter"># </span><span class="org-comment">if d1 and d2 are the same, the coefficient is determined</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">calculate the remain, and flip the matrix</span>
            <span class="org-variable-name">r</span> = m2[0] - m2[1] * d0
            <span class="org-variable-name">m2</span>[0] = r
            <span class="org-variable-name">m2</span> = np.matmul(flip_m, m2)
            <span class="org-keyword">return</span> d1, m2
        <span class="org-keyword">elif</span> d1 == d0 + 1:
            <span class="org-comment-delimiter"># </span><span class="org-comment">if d1 is d0 + 1, there is a situation where coefficient can be determined</span>
            <span class="org-variable-name">r</span> = m2[0] - m2[1] * d1
            <span class="org-keyword">if</span> r[1] &lt; 0:
                <span class="org-comment-delimiter"># </span><span class="org-comment">this means d1 doesn't work, try d0</span>
                <span class="org-variable-name">r</span> = m2[0] - m2[1] * d0
                <span class="org-keyword">if</span> r[1] &lt; 0:
                    <span class="org-comment-delimiter"># </span><span class="org-comment">d0 also does'nt work</span>
                    <span class="org-keyword">return</span> <span class="org-constant">None</span>
                <span class="org-keyword">else</span>:
                    <span class="org-variable-name">m2</span>[0] = r
                    <span class="org-variable-name">m2</span> = np.matmul(flip_m, m2)
                    <span class="org-keyword">return</span> d0, m2
            <span class="org-keyword">else</span>:
               <span class="org-comment-delimiter"># </span><span class="org-comment">cannot rule out d1</span>
               <span class="org-keyword">return</span> <span class="org-constant">None</span>
        <span class="org-keyword">else</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">the range is too big, so the coefficient cannot be determined</span>
            <span class="org-keyword">return</span> <span class="org-constant">None</span>
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">coefficient cannot be determined for unbounded function</span>
        <span class="org-keyword">return</span> <span class="org-constant">None</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> cont_frac <span class="org-keyword">import</span> *
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np

<span class="org-keyword">class</span> <span class="org-type">TestQRMatrix</span>(<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">qr</span>(<span class="org-keyword">self</span>, m):
        <span class="org-variable-name">res</span> = qr_matrix(np.array(m))
        <span class="org-keyword">if</span> res <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-keyword">return</span> <span class="org-constant">None</span>
        <span class="org-keyword">else</span>:
            (q, r) = res
            <span class="org-keyword">return</span> q, r.tolist()

    <span class="org-keyword">def</span> <span class="org-function-name">test_basic1</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(4x+2)/(3x+2) is between 4/2 and 2/2 (1 to 1.33)</span>
        <span class="org-variable-name">m</span> = [[4, 2], [3, 2]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 1 <span class="org-keyword">and</span> r == [[3, 2], [1, 0]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_basic2</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(70x + 29)/ (12x + 5) is between 29/5 and 35/6 (5.8 to 5.88)</span>
        <span class="org-variable-name">m</span> = [[70, 29], [12, 5]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 5 <span class="org-keyword">and</span> r == [[12, 5], [10, 4]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_basic3</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(12x + 5) / (10 x + 4) is between 6/5 and 5/4 (1.2 to 1.25)</span>
        <span class="org-variable-name">m</span> = [[12, 5], [10, 4]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 1 <span class="org-keyword">and</span> r == [[10, 4], [2, 1]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_negative1</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(10x + 4) / (2x + 1) is bounded between 4 and 5</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">the quotient is 4, because it is 5 only at infinity</span>
        <span class="org-variable-name">m</span> = [[10, 4], [2, 1]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 4 <span class="org-keyword">and</span> r == [[2, 1], [2, 0]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_negative2</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(8x + 3) / (2x + 1) is bounded between 3 and 4</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">it is only 4 if x is infinity, so the coefficient has to be 3</span>
        <span class="org-variable-name">m</span> = [[8, 3], [2, 1]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 3 <span class="org-keyword">and</span> r == [[2, 1], [2, 0]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_divergent1</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">4x + 2 is unbounded</span>
        <span class="org-variable-name">m</span> = [[4, 2], [0, 1]]
        <span class="org-variable-name">res</span> = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> res <span class="org-keyword">is</span> <span class="org-constant">None</span>

    <span class="org-keyword">def</span> <span class="org-function-name">test_divergent2</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(4x + 2) / 3 is unbounded</span>
        <span class="org-variable-name">m</span> = [[4, 2], [3, 0]]
        <span class="org-variable-name">res</span> = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> res <span class="org-keyword">is</span> <span class="org-constant">None</span>

    <span class="org-keyword">def</span> <span class="org-function-name">test_zero_coeff</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(1x + 2) / (2x + 3) is bounded between 1/2 and 2/3 (0.5 to 0.666)</span>
        <span class="org-variable-name">m</span> = [[1, 2], [2, 3]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 0 <span class="org-keyword">and</span> r == [[2, 3], [1, 2]]
</pre>
</div>
</div>
</div>

<div id="outline-container-org452f10c" class="outline-2">
<h2 id="org452f10c"><span class="section-number-2">8.</span> Appendix: Additional tests</h2>
<div class="outline-text-2" id="text-8">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">TestEuclid</span>(<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">test_basic</span>(<span class="org-keyword">self</span>):
        <span class="org-variable-name">res</span> = euclid(Rational(254, 100))
        <span class="org-keyword">assert</span> <span class="org-builtin">list</span>(res) == [2, 1, 1, 5, 1, 3]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">TestConvergent0</span>(<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">test_basic</span>(<span class="org-keyword">self</span>):
        <span class="org-variable-name">l</span> = <span class="org-builtin">list</span>(cf_convergent0(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3])))
        <span class="org-keyword">assert</span> l[0] == Rational(2, 1)
        <span class="org-keyword">assert</span> l[1] == Rational(3, 1)
        <span class="org-keyword">assert</span> l[2] == Rational(5, 2)
        <span class="org-keyword">assert</span> l[3] == Rational(28, 11)
        <span class="org-keyword">assert</span> l[4] == Rational(33, 13)
        <span class="org-keyword">assert</span> l[5] == Rational(127, 50)
        <span class="org-keyword">assert</span> <span class="org-builtin">len</span>(l) == 6
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">TestConvergent1</span>(<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">test_basic</span>(<span class="org-keyword">self</span>):
        <span class="org-variable-name">l</span> = <span class="org-builtin">list</span>(cf_convergent1(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3])))
        <span class="org-keyword">assert</span> l[0] == Rational(2, 1)
        <span class="org-keyword">assert</span> l[1] == Rational(3, 1)
        <span class="org-keyword">assert</span> l[2] == Rational(5, 2)
        <span class="org-keyword">assert</span> l[3] == Rational(28, 11)
        <span class="org-keyword">assert</span> l[4] == Rational(33, 13)
        <span class="org-keyword">assert</span> l[5] == Rational(127, 50)
        <span class="org-keyword">assert</span> <span class="org-builtin">len</span>(l) == 6
</pre>
</div>
</div>
</div>

<div id="outline-container-org142c555" class="outline-2">
<h2 id="org142c555"><span class="section-number-2">9.</span> Appendix: Display utilities</h2>
<div class="outline-text-2" id="text-9">
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;IO_IMPORTS&gt;&gt;

<span class="org-keyword">class</span> <span class="org-type">Chart</span>(<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, m = np.identity(2, <span class="org-builtin">int</span>), display_top = <span class="org-constant">True</span>, display_right = <span class="org-constant">True</span>, field_width = 4):
        <span class="org-keyword">self</span>.display_top = display_top
        <span class="org-keyword">self</span>.display_right = display_right
        <span class="org-keyword">self</span>.top = [<span class="org-constant">None</span>]
        <span class="org-keyword">self</span>.right = [<span class="org-constant">None</span>]
        <span class="org-keyword">self</span>.board = [[m[0][0], m[0][1]], [m[1][0], m[1][1]]]
        <span class="org-keyword">self</span>.field_width = field_width

    <span class="org-keyword">def</span> <span class="org-function-name">pp_item</span>(<span class="org-keyword">self</span>, item, right = <span class="org-constant">False</span>):
        <span class="org-keyword">if</span> item <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-keyword">return</span> <span class="org-string">" "</span> * <span class="org-keyword">self</span>.field_width
        <span class="org-keyword">else</span>:
            <span class="org-keyword">if</span> right:
                <span class="org-keyword">return</span> f<span class="org-string">" {item : &lt; {self.field_width}}"</span>
            <span class="org-keyword">else</span>:
                <span class="org-keyword">return</span> f<span class="org-string">"{item : &gt; {self.field_width}}"</span>

    <span class="org-keyword">def</span> <span class="org-function-name">pp_row</span>(<span class="org-keyword">self</span>, row):
        <span class="org-keyword">return</span> <span class="org-builtin">reduce</span>(<span class="org-keyword">lambda</span> s, item: s + <span class="org-keyword">self</span>.pp_item(item), row, <span class="org-string">""</span>)

    <span class="org-keyword">def</span> <span class="org-function-name">last_column</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> (<span class="org-keyword">self</span>.board[-2][0], <span class="org-keyword">self</span>.board[-1][0])

    <span class="org-keyword">def</span> <span class="org-function-name">push_top</span>(<span class="org-keyword">self</span>, i):
        <span class="org-keyword">self</span>.top = [i] + <span class="org-keyword">self</span>.top

    <span class="org-keyword">def</span> <span class="org-function-name">push_right</span>(<span class="org-keyword">self</span>, i):
        <span class="org-keyword">self</span>.right.append(i)

    <span class="org-keyword">def</span> <span class="org-function-name">push_column</span>(<span class="org-keyword">self</span>, m, a):
        <span class="org-keyword">self</span>.push_top(a)
        <span class="org-keyword">assert</span> <span class="org-keyword">self</span>.last_column() == (m[0][1], m[1][1])
        <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-builtin">len</span>(<span class="org-keyword">self</span>.board)):
            <span class="org-keyword">self</span>.board[i] = [<span class="org-constant">None</span>] + <span class="org-keyword">self</span>.board[i]
        <span class="org-keyword">self</span>.board[-2][0] = m[0][0] 
        <span class="org-keyword">self</span>.board[-1][0] = m[1][0] 

    <span class="org-keyword">def</span> <span class="org-function-name">push_row</span>(<span class="org-keyword">self</span>, m, q):
        <span class="org-keyword">assert</span> <span class="org-keyword">self</span>.board[-1][0] == m[0][0]
        <span class="org-keyword">assert</span> <span class="org-keyword">self</span>.board[-1][1] == m[0][1]
        <span class="org-variable-name">new_row</span> = [<span class="org-constant">None</span>] * <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.board[-1])
        <span class="org-variable-name">new_row</span>[0] = m[1][0]
        <span class="org-variable-name">new_row</span>[1] = m[1][1]
        <span class="org-keyword">self</span>.board.append(new_row)
        <span class="org-keyword">self</span>.right.append(q)

    <span class="org-keyword">def</span> <span class="org-function-name">__repr__</span>(<span class="org-keyword">self</span>):
        <span class="org-variable-name">s</span> = <span class="org-string">""</span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.display_top:
            <span class="org-variable-name">s</span> = s + <span class="org-keyword">self</span>.pp_row([<span class="org-constant">None</span>] + <span class="org-keyword">self</span>.top) + <span class="org-string">"\n"</span>

        <span class="org-keyword">for</span> (i, row) <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(<span class="org-keyword">self</span>.board):
            <span class="org-variable-name">s</span> = s + <span class="org-keyword">self</span>.pp_row(row)
            <span class="org-keyword">try</span>:
                <span class="org-keyword">if</span> <span class="org-keyword">self</span>.display_right:
                    <span class="org-variable-name">r</span> = <span class="org-keyword">self</span>.pp_item(<span class="org-keyword">self</span>.right[i], right = <span class="org-constant">True</span>)
                <span class="org-keyword">else</span>:
                    <span class="org-variable-name">r</span> = <span class="org-string">""</span>
                <span class="org-variable-name">s</span> = s + r + <span class="org-string">"\n"</span>
            <span class="org-keyword">except</span> <span class="org-type">IndexError</span>:
                <span class="org-variable-name">s</span> = s + <span class="org-string">"\n"</span>
        <span class="org-variable-name">s</span> = s[:-1] <span class="org-comment-delimiter"># </span><span class="org-comment">remove the last "\n"</span>
        <span class="org-keyword">return</span> s
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf1eb552" class="outline-2">
<h2 id="orgf1eb552"><span class="section-number-2">10.</span> Appendix: Tabulated displays</h2>
<div class="outline-text-2" id="text-10">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">euclid_tab</span>(rn: Rational):
    <span class="org-keyword">def</span> <span class="org-function-name">row</span>(st: <span class="org-builtin">str</span>, x: <span class="org-builtin">tuple</span>):
        <span class="org-variable-name">b</span>, <span class="org-variable-name">q</span> = x
        <span class="org-keyword">return</span> st + f<span class="org-string">"{b : &gt; 5}  {q : &lt; 5}\n"</span>
    <span class="org-variable-name">str0</span> = f<span class="org-string">"{rn.a : &gt; 5}\n"</span>
    <span class="org-keyword">return</span> <span class="org-builtin">reduce</span>(row, euclid_(rn), str0) + f<span class="org-string">"{0 : &gt; 5}\n"</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_convergent1_tab</span>(cf: Iterator[<span class="org-builtin">int</span>]):
    <span class="org-variable-name">chart</span> = Chart(display_right = <span class="org-constant">False</span>)
    (cf1, cf2) = tee(cf)
    <span class="org-keyword">for</span> (mat, a) <span class="org-keyword">in</span> <span class="org-builtin">zip</span>(cf_convergent1_(cf1), cf2):
        chart.push_column(mat, a)
    <span class="org-keyword">print</span>(chart)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">euclid_matrix_tab</span>(m):
    <span class="org-variable-name">chart</span> = Chart(m = m, display_top = <span class="org-constant">True</span>)
    <span class="org-keyword">for</span> (q, r) <span class="org-keyword">in</span> euclid_matrix_(m):
        chart.push_row(r, q)
    <span class="org-keyword">print</span>(chart)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_convergent2_tab</span>(cf: Iterator[<span class="org-builtin">int</span>], m0 = np.identity(2, <span class="org-builtin">int</span>), field_width = 4):
    <span class="org-variable-name">chart</span> = Chart(m = m0, field_width = field_width)
    (cf1, cf2) = tee(cf)
    <span class="org-keyword">for</span> (a, (q, r, m)) <span class="org-keyword">in</span> <span class="org-builtin">zip</span>(cf1, cf_convergent2_(cf2, m0)):
        chart.push_column(m, a)
        <span class="org-keyword">if</span> q <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-keyword">pass</span>
        <span class="org-keyword">else</span>:
            chart.push_row(r, q)
    <span class="org-keyword">print</span>(chart)
</pre>
</div>
</div>
</div>

<div id="outline-container-org1f86786" class="outline-2">
<h2 id="org1f86786"><span class="section-number-2">11.</span> Appendix: LaTeX utilities</h2>
<div class="outline-text-2" id="text-11">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">latex_cf</span>(lst: <span class="org-builtin">list</span>):
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(lst) == 1:
        <span class="org-keyword">return</span> <span class="org-builtin">str</span>(lst[0])
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">x</span> = <span class="org-builtin">str</span>(lst[0]) + <span class="org-string">"+"</span>
        <span class="org-variable-name">x</span> = x + r<span class="org-string">"\frac{1}{"</span> + latex_cf(lst[1:]) + <span class="org-string">"}"</span>
        <span class="org-keyword">return</span> x

<span class="org-keyword">def</span> <span class="org-function-name">latex_rational</span>(r: Rational):
    <span class="org-keyword">return</span> r<span class="org-string">"\frac{"</span> + <span class="org-builtin">str</span>(r.a) + <span class="org-string">"}{"</span> + <span class="org-builtin">str</span>(r.b) + <span class="org-string">"}"</span>

<span class="org-keyword">def</span> <span class="org-function-name">show_cf_expansion</span>(r: Rational):
    <span class="org-keyword">print</span>(r<span class="org-string">"\["</span>)
    <span class="org-keyword">print</span>(r<span class="org-string">"\frac{"</span>, r.a, <span class="org-string">"}{"</span>, r.b, <span class="org-string">"}="</span>)
    <span class="org-variable-name">nc</span> = <span class="org-builtin">list</span>(euclid(r))
    <span class="org-keyword">print</span>(latex_cf(nc))
    <span class="org-keyword">print</span>(r<span class="org-string">"\]"</span>)

<span class="org-keyword">def</span> <span class="org-function-name">show_rational_series</span>(itr: Iterator[<span class="org-builtin">int</span>]):
    <span class="org-variable-name">rLst</span> = <span class="org-builtin">list</span>(cf_convergent0(itr))
    <span class="org-variable-name">s</span> = <span class="org-string">""</span>
    <span class="org-keyword">for</span> r <span class="org-keyword">in</span> rLst:
        <span class="org-variable-name">s</span> = s + <span class="org-string">"$"</span> + latex_rational(r) + <span class="org-string">"$"</span> + <span class="org-string">","</span>

    <span class="org-keyword">print</span>(s[:-1])
</pre>
</div>
</div>
</div>

<div id="outline-container-org0f88bcd" class="outline-2">
<h2 id="org0f88bcd"><span class="section-number-2">12.</span> Appendix: Imports</h2>
<div class="outline-text-2" id="text-12">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> math
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> typing <span class="org-keyword">import</span> NamedTuple, Iterator, Tuple
<span class="org-keyword">from</span> functools <span class="org-keyword">import</span> <span class="org-builtin">reduce</span>
<span class="org-keyword">from</span> itertools <span class="org-keyword">import</span> tee
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> cont_frac <span class="org-keyword">import</span> *
<span class="org-keyword">from</span> cont_frac_io <span class="org-keyword">import</span> *
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> cont_frac <span class="org-keyword">import</span> *
<span class="org-keyword">from</span> functools <span class="org-keyword">import</span> <span class="org-builtin">reduce</span>
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hsin-Hao Yu</p>
<p class="date">Created: 2022-04-09 Sat 23:11</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
