<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-04-25 Mon 22:43 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Understanding Bill Gospher's continued fraction arithmetic (implemented in Python)</title>
<meta name="author" content="Hsin-Hao Yu" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "left",
        displayIndent: "0em",

        "HTML-CSS": { scale: 85,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 85,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 85},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Understanding Bill Gospher's continued fraction arithmetic (implemented in Python)</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org1eea58f">1. Representing rational numbers as continued fractions</a></li>
<li><a href="#org22903ee">2. Calculating the convergents of a continued fraction</a></li>
<li><a href="#org7766eb4">3. Continued fraction approximation as function compositions</a></li>
<li><a href="#org2c594cb">4. Calculating convergents using the matrix notation</a></li>
<li><a href="#orgf400a8b">5. Turning convergents into continued fractions</a></li>
<li><a href="#org82b71d3">6. Simple transformations of continued fractions</a></li>
<li><a href="#org6c11d78">7. Continued fraction arithmetic - bihomographic functions</a></li>
<li><a href="#org93caf55">8. Bihomographic functions - implementation</a></li>
<li><a href="#org0914d42">9. Convergents for continued fraction arithmetic</a></li>
<li><a href="#org5ee5836">10. Appendix: Quotients/remainders for matrices</a></li>
<li><a href="#org67e6c64">11. Appendix: Quotients/remainders for tensors</a></li>
<li><a href="#orgd8fc993">12. Appendix: Tests</a>
<ul>
<li><a href="#orgaadb017">12.1. Using continued fractions to represent rational numbers</a></li>
<li><a href="#orge599942">12.2. Convergents</a></li>
<li><a href="#org74bc420">12.3. Symbolic Euclidean algorithm</a></li>
<li><a href="#org21e9378">12.4. Transformations of continued fractions</a></li>
<li><a href="#orgedb599a">12.5. Bihomography</a></li>
<li><a href="#org18c9af7">12.6. Imports</a></li>
</ul>
</li>
<li><a href="#orgd86cc16">13. Appendix: Display utilities</a>
<ul>
<li><a href="#org1affac8">13.1. Tabulated display utilities</a></li>
<li><a href="#org2859e75">13.2. Tabulated displays: 2D</a></li>
<li><a href="#orgc77bf00">13.3. Tabulated displays: 3D</a></li>
<li><a href="#org47c5dd5">13.4. Pretty printing utilities</a></li>
<li><a href="#org0af09ba">13.5. LaTeX utilities</a></li>
<li><a href="#org171b263">13.6. Imports</a></li>
</ul>
</li>
<li><a href="#org5799451">14. Appendix: Imports</a></li>
</ul>
</div>
</div>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;IMPORTS&gt;&gt;
&lt;&lt;RATIONAL_NUM&gt;&gt;
&lt;&lt;R2CF&gt;&gt;
&lt;&lt;CONVERGENTS0&gt;&gt;
&lt;&lt;CONVERGENTS1&gt;&gt;
&lt;&lt;QR_MATRIX&gt;&gt;
&lt;&lt;CF_TRANSFORM&gt;&gt;
&lt;&lt;BIHOMOGRAPHY&gt;&gt;  
&lt;&lt;QR_TENSOR&gt;&gt;
&lt;&lt;CF_EXAMPLES&gt;&gt;
</pre>
</div>

<div id="outline-container-org1eea58f" class="outline-2">
<h2 id="org1eea58f"><span class="section-number-2">1.</span> Representing rational numbers as continued fractions</h2>
<div class="outline-text-2" id="text-1">
<p>
Since we'll use rational numbers a lot, let's define a class:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">Rational</span>(NamedTuple(<span class="org-string">'Rational'</span>, [(<span class="org-string">'a'</span>, <span class="org-builtin">int</span>), (<span class="org-string">'b'</span>, <span class="org-builtin">int</span>)])):
    <span class="org-doc">"""Rational(a, b) = a/b"""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__repr__</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> f<span class="org-string">'{self.a}/{self.b}'</span>
</pre>
</div>

<p>
How to convert a rational number to a continued fraction? Observing that
</p>

<p>
\[
\frac{254}{100}
= 2 + \frac{54}{100}
= 2 + \frac{1}{\frac{100}{54}}
= 2 + \frac{1}{1 + \frac{46}{54}}
= 2 + \frac{1}{1 + \frac{1}{\frac{46}{54}}}
\]
</p>

<p>
it should be obvious that the solution is just the <a href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Euclidean algorithm</a> for finding the greatest common divider:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Convert a rational number to a continued fraction</span>

<span class="org-keyword">def</span> <span class="org-function-name">qr</span>(a: <span class="org-builtin">int</span>, b: <span class="org-builtin">int</span>) -&gt; Tuple[<span class="org-builtin">int</span>, <span class="org-builtin">int</span>]:
    <span class="org-doc">"""a = b * q + r, return (q, r)"""</span>
    <span class="org-variable-name">q</span> = math.floor(a / b)  <span class="org-comment-delimiter"># </span><span class="org-comment">the quotient</span>
    <span class="org-variable-name">r</span> = a - b * q          <span class="org-comment-delimiter"># </span><span class="org-comment">the remainder</span>
    <span class="org-keyword">return</span> (q, r)

<span class="org-keyword">def</span> <span class="org-function-name">r2cf_</span>(rn: Rational) -&gt; Iterator[Tuple[<span class="org-builtin">int</span>, <span class="org-builtin">int</span>]]:
    <span class="org-doc">"""The Euclidean algorithm for representing a rational number as a continuous fraction.</span>
<span class="org-doc">    Return an iterator of quotients and remainders"""</span>
    <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span> = rn    
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-variable-name">q</span>, <span class="org-variable-name">r</span> = qr(a, b)
        <span class="org-keyword">yield</span> b, q
        <span class="org-keyword">if</span> r == 0:
            <span class="org-keyword">break</span>
        <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span> = b, r

<span class="org-keyword">def</span> <span class="org-function-name">r2cf</span>(rn: Rational) -&gt; Iterator[<span class="org-builtin">int</span>]:
    <span class="org-doc">"""Represent a rational number as a continued fraction.</span>
<span class="org-doc">    Return an iterator of integers"""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">second</span>(x: <span class="org-builtin">tuple</span>):
        <span class="org-keyword">return</span> x[1]
    <span class="org-keyword">return</span> <span class="org-builtin">map</span>(second, r2cf_(rn))
</pre>
</div>

<p>
Now we can use <code>r2cf</code> to convert a rational number into a continued fraction. In this article, continued fractions are represented by Python generators, because they can have infinite number of terms. However, the generators returned by <code>r2cf</code> are finite iterators because the continued fractions associated with rational numbers always have finite numbers of coefficients.
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">nc</span> = r2cf(Rational(254, 100))
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(nc))
</pre>
</div>

<pre class="example">
[2, 1, 1, 5, 1, 3]
</pre>


<p>
This means that
\[
\frac{ 254 }{ 100 }=
2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}
\]
</p>

<p>
We can display the process in a tabular format. For example:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(r2cf_tab(Rational(254, 100)))
</pre>
</div>

<pre class="example">
254
100   2   
 54   1   
 46   1   
  8   5   
  6   1   
  2   3   
  0

</pre>


<p>
This table shows that 2 (the penultimate row) is the greatest common divider of 254 and 100. As a byproduct of this process, we also get the coefficients of the corresponding continued fraction, which are the quotients displayed on the right.
</p>

<p>
Interestingly, the reciprocal of \(\frac{254}{100}\) (that is, \(\frac{100}{254}\)) is represented by the following as a continued fraction:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">nc</span> = r2cf(Rational(100, 254))
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(nc))
</pre>
</div>

<pre class="example">
[0, 2, 1, 1, 5, 1, 3]
</pre>


<p>
It's the same sequence with an additional 0 at the beginning! This is our first clue that a continued fraction can be transformed by performing some operations at the beginning of the Euclidean algorithm. We'll come back to this point later.
</p>
</div>
</div>

<div id="outline-container-org22903ee" class="outline-2">
<h2 id="org22903ee"><span class="section-number-2">2.</span> Calculating the convergents of a continued fraction</h2>
<div class="outline-text-2" id="text-2">
<p>
Given a continued fraction, how do we calculate its value? If the series is finite, we can easily write a recursive function. However, if it's an infinite series, we need a method to incrementally approximate the value as more coefficients are received. Also, we want the evaluation to be accumulative, so that each update is based on the previous one.
</p>

<p>
This question has an easy solution if we use a series of rational numbers to approximate the continued fraction. Each term in the series is called a convergent. The formula for the convergents can be derived easily with mathematical induction, and it is implemented below. For the moment, we'll use the formula just a convenience to get the job done. We'll get deeper into its meaning in the next section.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the convergents of a continued fraction</span>

<span class="org-keyword">def</span> <span class="org-function-name">cf_convergents0</span>(cf: Iterator[<span class="org-builtin">int</span>]) -&gt; Iterator[Rational]:
    <span class="org-doc">"""For a continued fraction cf, return an iterator of rational numbers to approximate it"""</span> 
    <span class="org-variable-name">p1</span>, <span class="org-variable-name">p0</span> = 1, 0
    <span class="org-variable-name">q1</span>, <span class="org-variable-name">q0</span> = 0, 1

    <span class="org-keyword">for</span> a <span class="org-keyword">in</span> cf:
        <span class="org-variable-name">p</span> = a * p1 + p0
        <span class="org-variable-name">q</span> = a * q1 + q0
        <span class="org-keyword">yield</span> Rational(p, q)

        <span class="org-variable-name">p0</span>, <span class="org-variable-name">p1</span> = p1, p
        <span class="org-variable-name">q0</span>, <span class="org-variable-name">q1</span> = q1, q
</pre>
</div>

<p>
For example, for the continued fraction \([2, 1, 1, 5, 1, 3]\), we get
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_convergents0(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3]))))
</pre>
</div>

<pre class="example">
[2/1, 3/1, 5/2, 28/11, 33/13, 127/50]
</pre>


<p>
In other words, 
\(2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}\)
can be approximated with
\(\frac{2}{1}\),\(\frac{3}{1}\),\(\frac{5}{2}\),\(\frac{28}{11}\),\(\frac{33}{13}\),\(\frac{127}{50}\)
.
</p>

<p>
For convenience, we define a specialized version of <code>cf_convergents0</code> just for finite-term continued fractions. It returns the rational number corresponding to the continued fraction:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf2r0</span>(cf: Iterator[<span class="org-builtin">int</span>]) -&gt; Rational:
    <span class="org-doc">"""Given a finite-term continued fraction, return its value as a rational number.</span>
<span class="org-doc">    This function will get into an infinite loop if the iterator doesn't stop.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> <span class="org-builtin">list</span>(cf_convergents0(cf))[-1]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(cf2r0(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3])))
</pre>
</div>

<pre class="example">
127/50
</pre>


<p>
Another example: the irrational number \(e\) can be expressed as a continuous fraction by:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Examples of continuous fractions</span>

<span class="org-keyword">def</span> <span class="org-function-name">cf_e</span>() -&gt; Iterator[<span class="org-builtin">int</span>]:
    <span class="org-doc">"""e as a continuous fraction"""</span>
    <span class="org-keyword">yield</span> 2
    <span class="org-variable-name">k</span> = 0
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">a finite generator comprehension</span>
        <span class="org-keyword">for</span> i <span class="org-keyword">in</span> (j <span class="org-keyword">for</span> j <span class="org-keyword">in</span> [1, 2 * k + 2, 1]):
            <span class="org-keyword">yield</span> i
        <span class="org-variable-name">k</span> = k + 1
</pre>
</div>

<p>
It has infinite number of terms, but the series follows a simple pattern. This is just the first 16 terms:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(islice(cf_e(), 16)))
</pre>
</div>

<pre class="example">
[2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, 1, 1, 10, 1]
</pre>


<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">conv_</span> = cf_convergents0(cf_e())
<span class="org-variable-name">conv</span> = <span class="org-builtin">list</span>(islice(conv_, 16)) <span class="org-comment-delimiter"># </span><span class="org-comment">the first 16 convergents</span>
<span class="org-keyword">for</span> c <span class="org-keyword">in</span> conv:
    <span class="org-keyword">print</span>(f<span class="org-string">'{repr(c):&lt;20} {c[0]/c[1]:.8f}'</span>)
</pre>
</div>

<pre class="example" id="orga1d3737">
2/1                  2.00000000
3/1                  3.00000000
8/3                  2.66666667
11/4                 2.75000000
19/7                 2.71428571
87/32                2.71875000
106/39               2.71794872
193/71               2.71830986
1264/465             2.71827957
1457/536             2.71828358
2721/1001            2.71828172
23225/8544           2.71828184
25946/9545           2.71828182
49171/18089          2.71828183
517656/190435        2.71828183
566827/208524        2.71828183
</pre>
</div>
</div>

<div id="outline-container-org7766eb4" class="outline-2">
<h2 id="org7766eb4"><span class="section-number-2">3.</span> Continued fraction approximation as function compositions</h2>
<div class="outline-text-2" id="text-3">
<p>
Given the first 3 terms in a continued fraction \([5, 1, 4...]\), let \(x\) denote the reciprocal of the value of the remaining series. We can express the convergent as \(f_1(x)\), \(f_2(x)\), \(f_3(x)\)&#x2026;, where
</p>

\begin{equation*}
    f_1(x) = 5 + \frac{1}{x}
\end{equation*}

\begin{equation*}
    f_2(x) = 5 + \frac{1}{1 + \frac{1}{x}} = f_1(1 + \frac{1}{x})
\end{equation*}

\begin{equation*}
    f_3(x) = 5 + \frac{1}{1 + \frac{1}{4 + \frac{1}{x}}} = f_1(f_2(4 + \frac{1}{x}))
\end{equation*}

<p>
Or more compactly, let
</p>
\begin{equation*}
    h(a, x) = a + \frac{1}{x}
\end{equation*}

<p>
then
</p>
\begin{equation*}
    f_1(x) = h(5, x)
\end{equation*}

\begin{equation*}
    f_2(x) = h(5, h(1, x))
\end{equation*}

\begin{equation*}
    f_3(x) = h(5, h(1, h(4, x))) 
\end{equation*}

<p>
This way, we express the approximation as a recursive process. If the continued fraction stops at the third term, its value is \(h_3(\infty) = h(5, h(1, h(4, \infty)))\). Infinity might seem odd here, but remember that \(x\) is the reciprocal of the rest of the sequence. So it just means that the rest of the sequence evaluates to 0.
</p>

<p>
Before we rush to translate this into code, let's dig deeper. If we use column vectors to represent rational numbers:
</p>

\begin{equation*}
    \begin{bmatrix}
           p \\
           q
    \end{bmatrix} = \frac{p}{q}
\end{equation*}

<p>
Then we can turn everything into linear algebra:
</p>

\begin{equation*}
    h(a, x) = a + \frac{1}{x} = \frac{ax + 1}{x}
\end{equation*}

<p>
can be written in our matrix notation as
</p>

\begin{equation*}

    \begin{bmatrix}
        ax + 1 \\
        x
    \end{bmatrix}

    =

    \begin{bmatrix}
        a & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix}
\end{equation*}

<p>
Furthermore, 
</p>

\begin{equation*}
    f_3(x) = h(5, h(1, h(4, x)))
\end{equation*}

<p>
can be written as
</p>

\begin{equation*}

    \begin{bmatrix}
        5 & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        1 & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        4 & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix}

    = 

    \begin{bmatrix}
        29 & 6 \\
        5 & 1
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix}

\end{equation*}

<p>
So, the 2-by-2 matrix
</p>

<p>
\(\begin{bmatrix}
    29 & 6 \\
     5 & 1
\end{bmatrix}\)
</p>

<p>
represents a function that approximates a continued fraction with more terms. If the continued fractions has only 3 terms, we terminate the process by evaluating
</p>

\begin{equation*}

    \begin{bmatrix}
        29 & 6 \\
         5 & 1
    \end{bmatrix}

    \begin{bmatrix}
        1 \\
        0 
    \end{bmatrix}

    = 

    \begin{bmatrix}
        29 \\
         5
    \end{bmatrix}

    = \frac{29}{5}
\end{equation*}

<p>
Multiplying the matrix with
\(\begin{bmatrix}
    1 \\
    0 
\end{bmatrix}\) turns the function into a rational value, which is the first column of the matrix.
</p>
</div>
</div>

<div id="outline-container-org2c594cb" class="outline-2">
<h2 id="org2c594cb"><span class="section-number-2">4.</span> Calculating convergents using the matrix notation</h2>
<div class="outline-text-2" id="text-4">
<p>
Now, we are ready to rewrite the formula in <code>cf_convergents0</code> as matrix multiplications:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the convergents using matrix multiplication</span>

<span class="org-keyword">def</span> <span class="org-function-name">h</span>(a: <span class="org-builtin">int</span>) -&gt; np.ndarray:
    <span class="org-keyword">return</span> np.array([[a, 1], [1,0]])

<span class="org-keyword">def</span> <span class="org-function-name">cf_convergents1_</span>(cf: Iterator[<span class="org-builtin">int</span>]) -&gt; Iterator[np.ndarray]:
    <span class="org-doc">"""Given a continuous fraction, return an iterator of 2x2 matrices representing convergents"""</span>
    <span class="org-variable-name">res</span> = np.array([[1, 0], [0, 1]])
    <span class="org-keyword">for</span> a <span class="org-keyword">in</span> cf:
        <span class="org-variable-name">res</span> = np.matmul(res, h(a))
        <span class="org-keyword">yield</span> res

<span class="org-keyword">def</span> <span class="org-function-name">cf_convergents1</span>(cf: Iterator[<span class="org-builtin">int</span>]) -&gt; Iterator[Rational]:
    <span class="org-doc">"""Given a continuous fraction, return an iterator of rational numbers representing convergents"""</span>
    <span class="org-variable-name">mLst</span> = cf_convergents1_(cf)
    <span class="org-keyword">for</span> m <span class="org-keyword">in</span> mLst:
        <span class="org-keyword">yield</span> Rational(m[0, 0], m[1, 0])
</pre>
</div>

<p>
Let's try it on the example given in the <a href="#org7766eb4">previous section</a>:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_convergents1(<span class="org-builtin">iter</span>([5, 1, 4]))))
</pre>
</div>

<pre class="example">
[5/1, 6/1, 29/5]
</pre>


<p>
Here's a longer sequence that we used <a href="#org22903ee">previously</a>:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_convergents1(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3]))))
</pre>
</div>

<pre class="example">
[2/1, 3/1, 5/2, 28/11, 33/13, 127/50]
</pre>


<p>
A very charming thing that Gosper did was that he used a compact tabulated format to illustrate the process. It's unnecessary for the computation, but I think it looks pretty cool:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(cf_convergents1_tab(<span class="org-builtin">iter</span>([5, 1, 4])))
</pre>
</div>

<pre class="example">
    4  1  5   
29  6  5  1  0
 5  1  1  0  1

</pre>


<p>
This table is read from the right to the left. The right-to-left direction takes some getting used to, but it's needed to preserve the normal representation of matrices.
</p>

<p>
The first row represents the coefficients of the continued fraction. To understand the other numbers, we calculate the matrices for each additional coefficient in the continued fraction:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">itr</span> = cf_convergents1_(<span class="org-builtin">iter</span>([5, 1, 4]))
<span class="org-keyword">print</span>(<span class="org-builtin">next</span>(itr),<span class="org-string">"\n"</span>)
<span class="org-keyword">print</span>(<span class="org-builtin">next</span>(itr),<span class="org-string">"\n"</span>)
<span class="org-keyword">print</span>(<span class="org-builtin">next</span>(itr))
</pre>
</div>

<pre class="example">
[[5 1]
 [1 0]] 

[[6 5]
 [1 1]] 

[[29  6]
 [ 5  1]]
</pre>


<p>
You can see these matrices shift leftwards in the tabular representation, with adjacent matrices sharing a column. To see why, suppose that the current matrix is
\(\begin{bmatrix}
    p & q \\
    r & s
\end{bmatrix}\), and we have to update it with a new term \(a_n\) in the continued fraction. The updated matrix is
</p>
\begin{equation*}
    \begin{bmatrix}
        p & q \\
        r & s
    \end{bmatrix}
    \begin{bmatrix}
        a_n & 1 \\
        1 & 0
    \end{bmatrix} =
    \begin{bmatrix}
        a_n p + q & p \\
        a_n r + s & r
    \end{bmatrix}
\end{equation*}

<p>
This explains the shift, and we have recovered the formula in <code>cf_convergents0</code>.
</p>

<p>
Here's a longer series:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(cf_convergents1_tab(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3])))
</pre>
</div>

<pre class="example">
      3   1   5   1   1   2    
127  33  28   5   3   2   1   0
 50  13  11   2   1   1   0   1

</pre>


<p>
As before, we define a specialized version of <code>cf_convergents1</code> just for finite-term continued fractions. 
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf2r1</span>(cf: Iterator[<span class="org-builtin">int</span>]) -&gt; Rational:
    <span class="org-doc">"""Given a finite-term continued fraction, return its value as a rational number.</span>
<span class="org-doc">    This function will get into an infinite loop if the iterator doesn't stop.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> <span class="org-builtin">list</span>(cf_convergents1(cf))[-1]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf400a8b" class="outline-2">
<h2 id="orgf400a8b"><span class="section-number-2">5.</span> Turning convergents into continued fractions</h2>
<div class="outline-text-2" id="text-5">
<p>
In this section, we'll develop code that calculates convergents as in <code>cf_convergent1</code>, but as it happens, we'll also turn them into continued fractions. This seems to be a pointless exercise, because a continued fraction is what we start with! Indeed, at the end of this section, we'll see that the code receives a continued fraction, and just returns the same series. However, this code will become useful in the coming sections.
</p>

<p>
Let's take the continued fraction \([5, 1, 4... ]\) as an example. Since we already know from the <a href="#org2c594cb">last section</a> that the third convergent of \([5, 1, 4]\) is \(\frac{29}{5}\), can't we just turn \(\frac{29}{5}\) into a continued fraction? It is not as simple as that, because \([5, 1, 4]\) and \([5, 1, 4...]\) are not the same. For the former, the third convergent just a rational number. However, for the latter, the third convergent is
\(\begin{bmatrix}
    29 & 6 \\
     5 & 1
\end{bmatrix}\), which represents the function \(\frac{29x + 6}{5x + 1}\). To turn it into a continued fraction, we'll need to take the rest of the series, represented by \(x\), into account.
</p>

<p>
How? The answer is still the Euclidean algorithm, but we have to use it symbolically rather than numerically.
</p>

<p>
The first step is to symbolically represent the function as a quotient and a remainder (see <code>qr()</code> in <code>r2cf_</code>). I implemented this operation in <code>qr_matrix</code> in the . We can use it on the third convergent:
</p>
<div class="org-src-container">
<pre class="src src-python">
pp_qr(qr_matrix(np.array([[29, 6], [5, 1]])))
</pre>
</div>

<pre class="example">
5  5  1
   4  1
</pre>


<p>
This means that \(f_3(x) = \frac{29x+6}{5x+1} = 5 + \frac{1}{\frac{5x+1}{4x+1}}\). Why is the quotient 5? Since \(\lim_{x \to 0} f_3(x) = 6\) and \(\lim_{x \to \infty} f_3(x) = \frac{29}{5} = 5.8\), the function is bounded by \(5.8 < f_3(x) < 6\) (note that \(0 < x < \infty\)). The quotient therefore has to be 5.
</p>


<div id="org3ee2499" class="figure">
<p><img src="../figs/fig1.png" alt="fig1.png" width="400" />
</p>
</div>

<p>
Now, we are ready to implement the symbolic form of the Euclidean algorithm by calling <code>qr_matrix</code> repeatedly:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">euclid_matrix_</span>(m: np.ndarray) -&gt; Iterator[Tuple[<span class="org-builtin">int</span>, np.ndarray]]:
    <span class="org-doc">"""The Euclidean algorithm for the function express by matrix m.</span>
<span class="org-doc">    Returns an iterator of the quotient and the remainder"""</span>
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-keyword">if</span> m[0][0] == 0 <span class="org-keyword">and</span> [0][1] == 0:
            <span class="org-comment-delimiter"># </span><span class="org-comment">if there is no remain, stop</span>
            <span class="org-keyword">break</span>
        <span class="org-keyword">else</span>:
            (q, r) = qr_matrix(m)
            <span class="org-keyword">if</span> q <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
                <span class="org-keyword">yield</span> q, r
                <span class="org-variable-name">m</span> = r
            <span class="org-keyword">else</span>:
                <span class="org-comment-delimiter"># </span><span class="org-comment">if the quotient cannot be determined, stop</span>
                <span class="org-keyword">break</span>
</pre>
</div>

<p>
Let's try it on
\(\begin{bmatrix}
    70 & 29 \\
    12 & 5
\end{bmatrix}\)
</p>

<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">q</span> = euclid_matrix_(np.array([[70, 29], [12, 5]]))
<span class="org-keyword">for</span> (r, m) <span class="org-keyword">in</span> q:
    pp_qr((r, m))
    <span class="org-keyword">print</span>()
</pre>
</div>

<pre class="example">
5 12  5
  10  4

1 10  4
   2  1

4  2  1
   2  0

</pre>


<p>
So there is enough information in \(\frac{70x+29}{12x+5}\) to precisely determine 3 coefficients (5, 1, 4). We stopped at the last term, because \(\frac{2x+1}{2x}\) is an unbounded function, so the quotient cannot be determined.
</p>

<p>
As before, Gospher stacked the matrices in a compact format to illustrate the process:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(euclid_matrix_tab(np.array([[70, 29], [12, 5]])))
</pre>
</div>

<pre class="example">

70 29   
12  5  5
10  4  1
 2  1  4
 2  0   

</pre>


<p>
Now, we can combine convergent calculation with the symbolic Euclidean algorithm:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_transform_</span>(cf: Iterator[<span class="org-builtin">int</span>], m0: np.ndarray = np.identity(2, <span class="org-builtin">int</span>)) -&gt; Iterator[Tuple[Optional[<span class="org-builtin">int</span>], Optional[np.ndarray], np.ndarray, <span class="org-builtin">int</span>, <span class="org-builtin">bool</span>]]:
    <span class="org-doc">"""Transform the input continued fraction by matrix m</span>
<span class="org-doc">    returns another continued fraction"""</span>
    <span class="org-variable-name">m</span> = m0
    <span class="org-keyword">for</span> a <span class="org-keyword">in</span> cf:
        <span class="org-variable-name">m</span> = np.matmul(m, h(a))
        <span class="org-variable-name">new_a</span> = <span class="org-constant">True</span>
        <span class="org-keyword">for</span> (q, r) <span class="org-keyword">in</span> euclid_matrix_(m):
            <span class="org-keyword">yield</span> q, r, m, a, new_a
            <span class="org-variable-name">new_a</span> = <span class="org-constant">False</span>
            <span class="org-variable-name">m</span> = r
        <span class="org-keyword">if</span> new_a:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Nothing was yielded. That means for this convergent cannot be turned into a continued fraction</span>
            <span class="org-keyword">yield</span> (<span class="org-constant">None</span>, <span class="org-constant">None</span>, m, a, new_a)

    <span class="org-comment-delimiter"># </span><span class="org-comment">we will only reach this point if the series is finite</span>
    <span class="org-keyword">if</span> m[1][0] != 0:
        <span class="org-keyword">for</span> s <span class="org-keyword">in</span> r2cf(Rational(m[0][0], m[1][0])):
            <span class="org-keyword">yield</span> s, <span class="org-constant">None</span>, m, a, <span class="org-constant">False</span>

<span class="org-keyword">def</span> <span class="org-function-name">cf_transform</span>(cf: Iterator[<span class="org-builtin">int</span>], m0: np.ndarray = np.identity(2, <span class="org-builtin">int</span>)) -&gt; Iterator[<span class="org-builtin">int</span>]:
    <span class="org-keyword">for</span> res <span class="org-keyword">in</span> cf_transform_(cf, m0):
        (q, r, m, a, new_a) = res
        <span class="org-keyword">if</span> q <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
            <span class="org-keyword">yield</span> q
            <span class="org-comment-delimiter"># </span><span class="org-comment">q can be None, indicating that more coefficients are needed</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">to continue. It can be ignored</span>
</pre>
</div>

<p>
Run it on a continued fraction, and it just returns the same sequence. It doesn't seems to do any transformation. We'll see why the function is called <code>cf_transform</code> in the next section. 
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_transform(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3]))))
</pre>
</div>

<pre class="example">
[2, 1, 1, 5, 1, 3]
</pre>


<p>
This seems to be anti-climatic for quite a bit of work&#x2026; but here's something cool. Gospher combined the two stacked matrix representations that we have seen, to illustrate every step in the algorithm:
</p>

<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(cf_transform_tab(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3])))
</pre>
</div>

<pre class="example">
  3 1 5 1 1 2    
        3 2 1 0  
      2 1 1 0 1 2
    6 1 1 0     1
  6 5 1 0       1
4 1 1 0         5
3 1 0           1
1 0             3

</pre>


<p>
The numbers on the right are the outputs of <code>cf_transform</code>.
</p>
</div>
</div>

<div id="outline-container-org82b71d3" class="outline-2">
<h2 id="org82b71d3"><span class="section-number-2">6.</span> Simple transformations of continued fractions</h2>
<div class="outline-text-2" id="text-6">
<p>
The beauty of representing convergents as matrices is that we can transform it with a function of the form \(f(x) = \frac{px+q}{rx+s}\). All we have to do is to do an additional matrix multiplication on the left side! This can be calculated by giving <code>cf_transform</code> an initial matrix.
</p>

<p>
The continued fraction \([2, 1, 1, 5, 1]\) is \(\frac{33}{13}\). Let's double that, and turn it back to a continued fraction:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(<span class="org-string">"[2, 1, 1, 5, 1] is "</span>, cf2r1(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1])))
<span class="org-keyword">print</span>(<span class="org-string">"The continued fraction of 66/13 is "</span>, <span class="org-builtin">list</span>(r2cf(Rational(66, 13))), <span class="org-string">"\n"</span>)
r2cf_tab(Rational(66, 13))
</pre>
</div>

<pre class="example">
[2, 1, 1, 5, 1] is  33/13
The continued fraction of 66/13 is  [5, 13] 

</pre>


<p>
According to the above, \(2 * [2, 1, 1, 5, 1]\) is \([5, 13]\). How do we end up with fewer terms? We can illustrate the process by running <code>cf_transform_tab</code> with the initial matrix \(\begin{bmatrix} 2 & 0 \\ 0 & 1 \end{bmatrix}\) (which stands for the function \(f(x) = 2x\)):
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">m0</span> = np.array([[2, 0], [0, 1]], <span class="org-builtin">int</span>)
<span class="org-variable-name">cf</span> = cf_transform(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1]), m0 = m0)
<span class="org-keyword">print</span>(<span class="org-string">" 2 * [2, 1, 1, 5, 1] is "</span>, <span class="org-builtin">list</span>(cf), <span class="org-string">"\n"</span>)
<span class="org-keyword">print</span>(cf_transform_tab(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1]), m0 = m0))
</pre>
</div>

<pre class="example">
2 * [2, 1, 1, 5, 1] is  [5, 13] 

    1  5  1  1  2      
      10  6  4  2  0   
13 11  2  1  1  0  1  5
 1  1  0  1          13

</pre>


<p>
Take the term \(\begin{bmatrix} 6 & 4 \\ 1 & 1\end{bmatrix}\) for example. The range is too wide (between 4 and 6) for the quotient to be determined. The algorithm therefore has to wait for the next coefficient to resolve it. That's why the transformed continued fraction has a smaller number of terms. 
</p>

<p>
Previously, we saw that the reciprocal of a continuous fraction has an addition 0 in the beginning. Let's verify that with the initial matrix \(\begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}\) (which stands for the function \(f(x) = \frac{1}{x}\)): 
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">m0</span> = np.array([[0, 1], [1, 0]], <span class="org-builtin">int</span>)
<span class="org-variable-name">cf</span> = cf_transform(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1]), m0 = m0)
<span class="org-keyword">print</span>(<span class="org-string">"The reciprocal of [2, 1, 1, 5, 1] is "</span>, <span class="org-builtin">list</span>(cf), <span class="org-string">"\n"</span>)
<span class="org-keyword">print</span>(cf_transform_tab(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1]), m0 = m0))
</pre>
</div>

<pre class="example" id="org360063b">
The reciprocal of [2, 1, 1, 5, 1] is  [0, 2, 1, 1, 5, 1] 

   1 5 1 1 2    
         1 0 1  
       3 2 1 0 0
     2 1 1 0   2
   6 1 1 0     1
 6 5 1 0       1
 1 1 0         5
 1 0           1

</pre>

<p>
Another example: what is \(\frac{2}{3-\sqrt{2}}\) as a continued fraction? First, \(\sqrt{2} = [1, 2, 2, 2...]\), so we should define an infinite generator:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_sqrt2</span>():
    <span class="org-doc">"""A generator representing sqrt(2) as a continued fraction"""</span>
    <span class="org-keyword">yield</span> 1
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-keyword">yield</span> 2
</pre>
</div>

<p>
Then, we just need to run <code>cf_transform</code> with \(\begin{bmatrix} 0 & 2 \\ -1 & 3 \end{bmatrix}\) (which stands for \(\frac{2}{-x + 3}\)):
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">m0</span> = np.array([[0, 2], [-1, 3]], <span class="org-builtin">int</span>)
<span class="org-variable-name">cf</span> = islice(cf_transform(cf_sqrt2(), m0 = m0), 6)
<span class="org-keyword">print</span>(<span class="org-string">" 2 / (3 - sqrt(2)) is "</span>, pp_inf_cf(<span class="org-builtin">list</span>(cf)), <span class="org-string">"\n"</span>)
<span class="org-keyword">print</span>(cf_transform_tab(islice(cf_sqrt2(), 6), m0 = m0))
</pre>
</div>

<pre class="example" id="org891de41">
2 / (3 - sqrt(2)) is  [1,3,1,4,1,4...] 

    2  2  2  2  2  1      
             4  2  0  2   
          8  3  2 -1  3  1
       5  2  1  0        3
   10  4  2  0           1
 5  2  1  0              4
 4  2  0                 1
 1  0                    4

</pre>
<p>
The answer is a periodic continued fraction \([1, 3, 1, 4, 1, 4...]\).
</p>

<p>
Another example: what is \(\tanh{\frac{1}{2}} = \frac{e-1}{e+1}\)? We have already defined the continued fraction for \(e\), so it's just a matter of choosing the right initial matrix (\(\begin{bmatrix} 1 & -1 \\ 1 & 1 \end{bmatrix}\), representing \(\frac{x-1}{x+1}\)):
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">m0</span> = np.array([[1, -1], [1, 1]], <span class="org-builtin">int</span>)
<span class="org-variable-name">cf</span> = islice(cf_transform(cf_e(), m0 = m0), 6)
<span class="org-keyword">print</span>(<span class="org-string">"(e-1)/(e+1) is "</span>, pp_inf_cf(<span class="org-builtin">list</span>(cf)), <span class="org-string">"\n"</span>)
<span class="org-keyword">print</span>(cf_transform_tab(islice(cf_e(), 12), m0 = m0))
</pre>
</div>

<pre class="example" id="org73fe850">
(e-1)/(e+1) is  [0,2,6,10,14,18...] 

     8  1  1  6  1  1  4  1  1  2  1  2      
                                   1  1 -1   
                                4  3  1  1  0
                      12  7  5  2  1  1     2
             20 11  9  2  1  1  0  1        6
    28 15 13  2  1  1  0  1                10
 17  2  1  1  0  1                         14
  1  0  1                                  17

</pre>
<p>
The answer is a continued fraction with a simple pattern: after the second term, add 4 to the previous term.
</p>
</div>
</div>

<div id="outline-container-org6c11d78" class="outline-2">
<h2 id="org6c11d78"><span class="section-number-2">7.</span> Continued fraction arithmetic - bihomographic functions</h2>
<div class="outline-text-2" id="text-7">
<p>
We have been dealing with one continued fraction at a time. In those situations, all operations involve functions of the form \(f(x) = \frac{px+q}{rx+s}\). They are known as homographic functions, and they can be represented by the matrix \(\begin{bmatrix} p & q \\ r & s \end{bmatrix}\). How do we generalize it to operations involving two continued fractions?
</p>

<p>
The problem is solved with bihomographic functions of the form \(f(x, y) = \frac{axy + bx + cy + d}{exy + fx + gy + h}\), where \(x\) and \(y\) are the unknown terms for the two continued fractions \(a\) and \(b\) respectively. We can write it in matrix form as:
</p>

\begin{equation*}
f(x, y) = \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} b & d \\ a & c \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} \bigg/
          \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} f & h \\ e & g \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix}
\end{equation*}

<p>
What happens when a new term \(a_n\) of \(a\) is received?
</p>

\begin{equation*}
f(a_n + \frac{1}{x}, y) = \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} a_n b  + d & b \\ a_n a + c & a \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} \bigg /
                          \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} a_n f  + h & f \\ a_n e + g & e \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} 
\end{equation*}

<p>
This is familiar, isn't it? It's exactly the same update rule that we use for updating the convergents! All we need to do is to right-multiply \(\begin{bmatrix} a_n & 1 \\ 1 & 0\end{bmatrix}\) the two matrices.
</p>

<p>
We can do the same with a new term \(b_n\) for \(b\):
</p>

\begin{equation*}
f(x, b_n + \frac{1}{y}) = \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} a & c \\ b_n a + b & b_n c + d \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} \bigg /
                          \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} e & g \\ b_n e + f & b_n g + h \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} 
\end{equation*}

<p>
This is basically the same thing, except that the direction is different. This corresponds to left-multiplying \(\begin{bmatrix} 0 & 1 \\ 1 & b_n\end{bmatrix}\).
</p>

<p>
The above suggests an elegant way to visualize continued fraction arithmetic: if we imagine that two matrices form a 2x2x2 cube, this cube moves leftwards upon receiving a new term of \(a\), and it moves downwards upon receiving a new term of \(b\). As before, we'll also use the Euclidean algorithm to convert the bihomographic function into continued fractions. When we get to perform the Euclidean step, the 2x2x2 cube moves in the third dimension. The following figure illustrates that continued fraction arithmetic is a direct generalization of the 2D case:
</p>


<div id="org593b925" class="figure">
<p><img src="../figs/cf_space.png" alt="cf_space.png" width="500px" />
</p>
</div>

<p>
Something is curious about the discussion so far. We have a generic method for ingest two continued fractions, but how do we actually do any computation on them? It's not hard to see that it all depends on the initial matrices. With appropriated chosen initial matrices, we can do multiplication, addition, division, subtraction, and their combinations. I think it's quite a remarkable result, because when we are dealing with numbers with multiple terms, multiplication is usually harder than addition. With continued fraction, the computational steps are exactly the same!
</p>

<p>
I made the following two figures to explain how addition and multiplication are done. Here's \(a+b\). We begin with just the initial matrices (first row), add the first term of \(a\), and then add the first term of \(b\). 
</p>


<div id="org2677fd5" class="figure">
<p><img src="../figs/addition.png" alt="addition.png" width="500px" />
</p>
</div>

<p>
Here's the same process for multiplication:
</p>


<div id="orgd789622" class="figure">
<p><img src="../figs/multiplication.png" alt="multiplication.png" width="500px" />
</p>
</div>
</div>
</div>

<div id="outline-container-org93caf55" class="outline-2">
<h2 id="org93caf55"><span class="section-number-2">8.</span> Bihomographic functions - implementation</h2>
<div class="outline-text-2" id="text-8">
<p>
Let's represent bihomographic functions with Numpy tensors:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Tensor representations of bihomographic functions</span>

<span class="org-keyword">def</span> <span class="org-function-name">tFrom2x4</span>(m: np.ndarray) -&gt; np.ndarray:
    ((a, b, c, d), (e, f, g, h)) = m.tolist()
    <span class="org-keyword">return</span> np.array([[[b, d], [a, c]], [[f, h], [e, g]]])

<span class="org-keyword">def</span> <span class="org-function-name">tTo2x4</span>(m: np.ndarray) -&gt; np.ndarray:
    (((b, d), (a, c)), ((f, h), (e, g))) = m.tolist()
    <span class="org-keyword">return</span> np.array([[a, b, c, d], [e, f, g, h]])
</pre>
</div>

<p>
A utility function for easy accessing elements of the matrices:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">tensor_ref</span>(t: np.ndarray, label: <span class="org-builtin">str</span>):
    <span class="org-keyword">assert</span> t.shape == (2, 2, 2)
    <span class="org-keyword">assert</span> label <span class="org-keyword">in</span> [<span class="org-string">'a'</span>, <span class="org-string">'b'</span>, <span class="org-string">'c'</span>, <span class="org-string">'d'</span>, <span class="org-string">'e'</span>, <span class="org-string">'f'</span>, <span class="org-string">'g'</span>, <span class="org-string">'h'</span>, <span class="org-string">'xy'</span>, <span class="org-string">'x'</span>, <span class="org-string">'y'</span>, <span class="org-string">'1'</span>]
    <span class="org-variable-name">lookup</span> = {}
    <span class="org-variable-name">lookup</span>[<span class="org-string">'a'</span>]  = t[0,1,0]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'b'</span>]  = t[0,0,0]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'c'</span>]  = t[0,1,1]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'d'</span>]  = t[0,0,1]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'e'</span>]  = t[1,1,0]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'f'</span>]  = t[1,0,0]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'g'</span>]  = t[1,1,1]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'h'</span>]  = t[1,0,1]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'xy'</span>] = lookup[<span class="org-string">'a'</span>], lookup[<span class="org-string">'e'</span>]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'x'</span>]  = lookup[<span class="org-string">'b'</span>], lookup[<span class="org-string">'f'</span>]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'y'</span>]  = lookup[<span class="org-string">'c'</span>], lookup[<span class="org-string">'g'</span>]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'1'</span>]  = lookup[<span class="org-string">'d'</span>], lookup[<span class="org-string">'h'</span>]
    <span class="org-keyword">return</span> lookup[label]
</pre>
</div>

<p>
These are the initial tensors needed for arithmetic:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-variable-name">tForAddition</span> = np.array([[[1, 0], [0, 1]], [[0, 1], [0, 0]]])
<span class="org-variable-name">tForSubtraction</span> = np.array([[[1, 0], [0, -1]], [[0, 1], [0, 0]]])
<span class="org-variable-name">tForMultiplication</span> = np.array([[[0, 0], [1, 0]], [[0, 1], [0, 0]]])
<span class="org-variable-name">tForDivision</span> = np.array([[[1, 0], [0, 0]], [[0, 0], [0, 1]]])
</pre>
</div>

<p>
Applying new coefficients is implemented with my favorite Numpy function: <code>einsum</code> (Einstein's sum):
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">apply_a</span>(t: np.ndarray, a: <span class="org-builtin">int</span>):
    <span class="org-variable-name">ha</span> = h(a)
    <span class="org-keyword">return</span> np.einsum(<span class="org-string">'dyx,xz-&gt;dyz'</span>, t, ha)

<span class="org-keyword">def</span> <span class="org-function-name">h_rotated</span>(b: <span class="org-builtin">int</span>) -&gt; np.ndarray:
    <span class="org-keyword">return</span> np.array([[0, 1], [1, b]])

<span class="org-keyword">def</span> <span class="org-function-name">apply_b</span>(t: np.ndarray, b: <span class="org-builtin">int</span>):
    <span class="org-variable-name">hb</span> = h_rotated(b)
    <span class="org-keyword">return</span> np.einsum(<span class="org-string">'zy,dyx-&gt;dzx'</span>, hb, t)      
</pre>
</div>

<p>
To make sure that it works:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">t</span> = tForAddition
<span class="org-variable-name">t</span> = apply_a(t, 2)
<span class="org-variable-name">t</span> = apply_b(t, 3)
<span class="org-variable-name">t</span> = apply_a(t, 4)
<span class="org-variable-name">t</span> = apply_b(t, 5)
<span class="org-keyword">print</span>(tTo2x4(t))
</pre>
</div>

<pre class="example">
[[109  21  26   5]
 [ 20   4   5   1]]
</pre>


<p>
\(\begin{bmatrix} 109 & 21 & 26 & 5 \\ 20 & 4 & 5 & 1 \end{bmatrix}\) means \(\frac{109xy + 21x + 26y + 5}{20xy + 4x + 5y + 1}\), which equals \((2+\frac{1}{4+\frac{1}{x}}) + (3+\frac{1}{5+\frac{1}{y}})\). That's correct.
</p>


<div id="org4bbe69a" class="figure">
<p><img src="../figs/fig2.png" alt="fig2.png" width="400" />
</p>
</div>

<p>
Let's try multiplication:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">t</span> = tForMultiplication
<span class="org-variable-name">t</span> = apply_a(t, 2)
<span class="org-variable-name">t</span> = apply_b(t, 3)
<span class="org-variable-name">t</span> = apply_a(t, 4)
<span class="org-keyword">print</span>(tTo2x4(t))
</pre>
</div>

<pre class="example">
[[27  9  6  2]
 [ 4  0  1  0]]
</pre>


<p>
\(\frac{27xy+9x+6y+2}{4xy+y} = (2 + \frac{1}{4+\frac{1}{x}}) \cdot (3+\frac{1}{y})\). That's also correct.
</p>
</div>
</div>

<div id="outline-container-org0914d42" class="outline-2">
<h2 id="org0914d42"><span class="section-number-2">9.</span> Convergents for continued fraction arithmetic</h2>
<div class="outline-text-2" id="text-9">
<p>
We have already developed sufficient machinery for doing continued fraction arithmetic. By updating the bihomographic function with new terms of \(a\) and \(b\), we can generate a series of rational numbers that converge to the result. The following code applies new terms of \(a\) and \(b\) alternately, but there are many ways of doing it. As long as the terms of the two continued fractions are applied in sequence, it doesn't matter how you do it. You can, for example, update with two terms of \(a\), and then two terms of \(b\).
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">arithmetic_convergents_</span>(a: Iterator[<span class="org-builtin">int</span>], b: Iterator[<span class="org-builtin">int</span>], t0 = tForAddition) -&gt; Iterator[np.ndarray]:
    <span class="org-variable-name">res</span> = t0.copy()
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-variable-name">an</span> = <span class="org-builtin">next</span>(a, <span class="org-constant">None</span>)
        <span class="org-variable-name">bn</span> = <span class="org-builtin">next</span>(b, <span class="org-constant">None</span>)

        <span class="org-keyword">if</span> an <span class="org-keyword">is</span> <span class="org-constant">None</span> <span class="org-keyword">and</span> bn <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-keyword">break</span>

        <span class="org-keyword">if</span> an <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
            <span class="org-variable-name">res</span> = apply_a(res, an)
            <span class="org-keyword">yield</span> <span class="org-string">'a'</span>, an, res
        <span class="org-keyword">if</span> bn <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
            <span class="org-variable-name">res</span> = apply_b(res, bn)
            <span class="org-keyword">yield</span> <span class="org-string">'b'</span>, bn, res

<span class="org-keyword">def</span> <span class="org-function-name">arithmetic_convergents</span>(a: Iterator[<span class="org-builtin">int</span>], b: Iterator[<span class="org-builtin">int</span>], t0 = tForAddition) -&gt; Iterator[Rational]:
    <span class="org-variable-name">c</span> = arithmetic_convergents_(a, b, t0)
    <span class="org-keyword">for</span> _, _, res <span class="org-keyword">in</span> c:
        <span class="org-variable-name">r</span> = tensor_ref(res, <span class="org-string">'xy'</span>)
        <span class="org-keyword">yield</span> Rational(*r)
</pre>
</div>

<p>
We have calculated <a href="#org82b71d3">previously</a> that \(2*[2, 1, 1, 5, 1] = \frac{66}{13}\). Let's verify it by adding the continued fraction to itself:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-variable-name">b</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(arithmetic_convergents(a, b, tForAddition)))
</pre>
</div>

<pre class="example">
[1/0, 4/1, 5/1, 6/1, 11/2, 20/4, 111/22, 616/121, 727/143, 858/169]
</pre>


<p>
Yup. \(\frac{858}{169}\) equals to \(\frac{66}{13}\).
</p>

<p>
Again, Gospher developed an ingenious method for visualizing the computational process, representing 2x2x2 tensors with a pseudo-3D effect. I decided not to implement his method because I find it hard to read. Instead, I will display the numerator and the denominator matrices separately. In the figure below, the upper "band" is the evolution of the numerator matrix, and the lower band does the same for the denominator matrix. Note that for a 2x2 matrix in either band, you should read off the number in the lower-left corner, because \(\lim_{\substack{x\to \infty \\ y\to \infty}} \frac{axy + bx + cy + d}{exy + fx + gy + h} = \frac{a}{e}\).
</p>

<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-variable-name">b</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])  
<span class="org-keyword">print</span>(arithmetic_convergents_tab(a, b, tForAddition))  
</pre>
</div>

<pre class="example" id="org29de554">
      1   5   1   1   2            
                  2   1   0        
              1   1   0   1   2    
          9   5   4   1       1    
     61  11   6   5           1    
131 111  20  11               5    
727 616 111                   1    
858 727                            
                  1   0   1        
              0   0   0   0        
          2   1   1   0            
     11   2   1   1                
 26  22   4   2                    
143 121  22                        
169 143                            

</pre>

<p>
\([2, 1, 1, 5, 1] - [2, 1, 1, 5, 1]\) does become 0:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-variable-name">b</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(arithmetic_convergents(a, b, tForSubtraction)), <span class="org-string">"\n"</span>)
<span class="org-variable-name">a</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-variable-name">b</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-keyword">print</span>(arithmetic_convergents_tab(a, b, tForSubtraction))
</pre>
</div>

<pre class="example" id="org7f81351">
[-1/0, 0/1, 1/1, 0/1, -1/2, 0/4, 1/22, 0/121, -1/143, 0/169] 

       1   5   1   1   2            
                   2   1   0        
              -1  -1   0  -1   2    
           1   1   0   1       1    
      -5  -1   0  -1           1    
   1   1   0   1               5    
  -1   0  -1                   1    
   0   1                            
                   1   0   1        
               0   0   0   0        
           2   1   1   0            
      11   2   1   1                
  26  22   4   2                    
 143 121  22                        
 169 143                            

</pre>

<p>
How about division?
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-variable-name">b</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(arithmetic_convergents(a, b, tForDivision)), <span class="org-string">"\n"</span>)
<span class="org-variable-name">a</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-variable-name">b</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-keyword">print</span>(arithmetic_convergents_tab(a, b, tForDivision))
</pre>
</div>

<pre class="example" id="orgefb225c">
[0/1, 2/2, 3/2, 3/3, 5/6, 10/10, 56/55, 308/308, 363/364, 429/429] 

       1   5   1   1   2            
                   2   1   0        
               0   0   0   0   2    
           5   3   2   1       1    
      28   5   3   2           1    
  66  56  10   6               5    
 363 308  55                   1    
 429 364                            
                   0   0   0        
               1   1   0   1        
           4   2   2   0            
      33   6   3   3                
  65  55  10   5                    
 364 308  56                        
 429 363                            

</pre>


<p>
Finally, let's try \(\sqrt{2}*\sqrt{2}\). With infinite number of terms, the answer should be 2. With finite number of terms, however, we get an approximation of 2 (\(\frac{9801}{4900}=2.0002\)).
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = islice(cf_sqrt2(), 6)
<span class="org-variable-name">b</span> = islice(cf_sqrt2(), 6)  
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(arithmetic_convergents(a, b, tForMultiplication)), <span class="org-string">"\n"</span>)
<span class="org-variable-name">a</span> = islice(cf_sqrt2(), 6)
<span class="org-variable-name">b</span> = islice(cf_sqrt2(), 6)  
<span class="org-keyword">print</span>(arithmetic_convergents_tab(a, b, tForMultiplication))
</pre>
</div>

<pre class="example" id="org437c991">
[1/0, 1/1, 3/2, 9/4, 21/10, 49/25, 119/60, 289/144, 697/348, 1681/841, 4059/2030, 9801/4900] 

         2    2    2    2    2    1               
                             0    0    0          
                        3    1    1    0    1     
                   7    3    1    1         2     
             51   21    9    3              2     
       287  119   49   21                   2     
 1683  697  289  119                        2     
 4059 1681  697                             2     
 9801 4059                                        
                             1    0    1          
                        0    0    0    0          
                   5    2    1    0               
             24   10    4    2                    
       145   60   25   10                         
  840  348  144   60                              
 2030  841  348                                   
 4900 2030                                        

</pre>

<p>
These results are not very satisfying, because the numbers tend to grow bigger and bigger. That's because we haven't performed any Euclidean step. That's for the next section.
</p>
</div>
</div>
<div id="outline-container-org5ee5836" class="outline-2">
<h2 id="org5ee5836"><span class="section-number-2">10.</span> Appendix: Quotients/remainders for matrices</h2>
<div class="outline-text-2" id="text-10">
<p>
This is just calculus
</p>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Simple transformation of continued fraction</span>

<span class="org-variable-name">flip_m</span> = np.array([[0, 1], [1, 0]])
<span class="org-variable-name">identity_m</span> = np.array([[1, 0], [0, 1]])

<span class="org-keyword">def</span> <span class="org-function-name">flip_remain</span>(m: np.ndarray, q: <span class="org-builtin">int</span>):
    <span class="org-keyword">assert</span> q &gt;= 0
    <span class="org-variable-name">r</span> = m[0] - m[1] * q
    <span class="org-variable-name">m</span>[0] = r
    <span class="org-keyword">return</span> np.matmul(flip_m, m)

<span class="org-keyword">def</span> <span class="org-function-name">qr_matrix</span>(m: np.ndarray) -&gt; Tuple[<span class="org-builtin">int</span>, np.ndarray]:
    <span class="org-doc">"""Calculate the quotient and the remainder of a 2x2 matrix"""</span>

    <span class="org-keyword">assert</span> <span class="org-keyword">not</span>(m[1][0] == 0 <span class="org-keyword">and</span> m[1][1] == 0)
    <span class="org-comment-delimiter"># </span><span class="org-comment">this means that the series has already ended. Nothing further needs to be done</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">The caller should not call qr_matrix in this case</span>

    <span class="org-variable-name">m2</span> = m.copy()

    <span class="org-keyword">if</span> m2[1][0] == 0 <span class="org-keyword">or</span> m2[1][1] == 0:
        <span class="org-comment-delimiter"># </span><span class="org-comment">If the function is unbounded, the quotient cannot be determined</span>
        <span class="org-keyword">return</span> (<span class="org-constant">None</span>, identity_m)
    <span class="org-keyword">elif</span> m2[1][1] &lt; 0:
        <span class="org-comment-delimiter"># </span><span class="org-comment">This means that the denominator can be made 0 (i.e., a singularity)</span>
        <span class="org-keyword">return</span> (<span class="org-constant">None</span>, identity_m)
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">If the function is bounded...</span>
        v0: <span class="org-builtin">float</span> = m[0][0] / m[1][0]
        v1: <span class="org-builtin">float</span> = m[0][1] / m[1][1]
        <span class="org-variable-name">v0</span>, <span class="org-variable-name">v1</span> = <span class="org-builtin">sorted</span>([v0, v1])
        d0: <span class="org-builtin">int</span> = math.floor(v0)
        d1: <span class="org-builtin">int</span> = math.floor(v1)
        <span class="org-keyword">if</span> d0 == d1:
            <span class="org-comment-delimiter"># </span><span class="org-comment">If d1 and d2 are the same, the quotient is determined</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the remain, and flip the matrix</span>
            <span class="org-variable-name">m2</span> = flip_remain(m2, d1)
            <span class="org-keyword">return</span> d1, m2
        <span class="org-keyword">elif</span> d1 == d0 + 1:
            <span class="org-keyword">if</span> d1 == v1:
                <span class="org-comment-delimiter"># </span><span class="org-comment">This means that d1 is the upper-bound</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">it's only reached at 0 or infinity </span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">So d0 is the quotient</span>
                <span class="org-variable-name">m2</span> = flip_remain(m2, d0)
                <span class="org-keyword">return</span> d0, m2
            <span class="org-keyword">else</span>:
                <span class="org-comment-delimiter"># </span><span class="org-comment">The bounds are not tight enough to determine the quotient</span>
                <span class="org-keyword">return</span> (<span class="org-constant">None</span>, identity_m)
        <span class="org-keyword">else</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">The bounds are not tight enough to determine the quotient</span>
            <span class="org-keyword">return</span> (<span class="org-constant">None</span>, identity_m)
</pre>
</div>
</div>
</div>

<div id="outline-container-org67e6c64" class="outline-2">
<h2 id="org67e6c64"><span class="section-number-2">11.</span> Appendix: Quotients/remainders for tensors</h2>
<div class="outline-text-2" id="text-11">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">tensor_term_ratios</span>(t: np.ndarray) -&gt; <span class="org-builtin">list</span>:
    <span class="org-doc">""" return</span>
<span class="org-doc">        [[a/e, floor(a/e), 'xy'],</span>
<span class="org-doc">         [b/f, floor(b/f), 'x'],</span>
<span class="org-doc">         [c/g, floor(c/g), 'y'],</span>
<span class="org-doc">         [d/h, floor(d/h), '1']]"""</span>

    <span class="org-keyword">def</span> <span class="org-function-name">f</span>(label):
        <span class="org-variable-name">numerator</span>, <span class="org-variable-name">denominator</span> = tensor_ref(t, label)
        <span class="org-keyword">return</span> numerator/denominator, math.floor(numerator/denominator), label

    <span class="org-keyword">return</span> [f(<span class="org-string">'xy'</span>), f(<span class="org-string">'x'</span>), f(<span class="org-string">'y'</span>), f(<span class="org-string">'1'</span>)]

<span class="org-keyword">def</span> <span class="org-function-name">qr_tensor</span>(t: np.ndarray):
    <span class="org-keyword">if</span> (t[1] &lt;= 0).<span class="org-builtin">any</span>():
        <span class="org-comment-delimiter"># </span><span class="org-comment">if any number in the denominator is smaller or equal to 0, the function is unbounded</span>
        <span class="org-keyword">pass</span>
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">r</span> = tensor_term_ratios(t)
        <span class="org-variable-name">r_sorted</span> = <span class="org-builtin">sorted</span>(r, key = <span class="org-keyword">lambda</span> terms: terms[1], reverse = <span class="org-constant">True</span>)

        <span class="org-keyword">if</span> r_sorted[0, 0] == r_sorted[0, 1]:
            <span class="org-comment-delimiter"># </span><span class="org-comment">the max can only be reached at 0 or infinity, so the quotient needed -1 </span>
            <span class="org-variable-name">r_sorted</span>[0, 1] = r_sorted[0, 1] - 1

        <span class="org-keyword">if</span> r_sorted[0, 1] == r_sorted[-1, 1]:
            <span class="org-comment-delimiter">#  </span><span class="org-comment">If the floor of the first and the last are the same, the numbers are all the same</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">in this case, the value is the quotient</span>
            <span class="org-keyword">pass</span>
        <span class="org-keyword">else</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">the quotient cannot be determined, but suggest which direction to go</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">if one of them is different, go to the dir that is different</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">if all three are different, what to do? compare magnitude?</span>
            <span class="org-keyword">pass</span>
</pre>
</div>
</div>
</div>
<div id="outline-container-orgd8fc993" class="outline-2">
<h2 id="orgd8fc993"><span class="section-number-2">12.</span> Appendix: Tests</h2>
<div class="outline-text-2" id="text-12">
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;TEST_IMPORTS&gt;&gt;
&lt;&lt;TEST_R2CF&gt;&gt;
&lt;&lt;TEST_QR_MATRIX&gt;&gt;
&lt;&lt;TEST_CONVERGENTS&gt;&gt;
&lt;&lt;TEST_CF2R&gt;&gt;
&lt;&lt;TEST_CF_TRANSFORM&gt;&gt;
&lt;&lt;TEST_BIHO&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-orgaadb017" class="outline-3">
<h3 id="orgaadb017"><span class="section-number-3">12.1.</span> Using continued fractions to represent rational numbers</h3>
<div class="outline-text-3" id="text-12-1">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">TestR2cf</span>(<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">test_basic</span>(<span class="org-keyword">self</span>):
        <span class="org-variable-name">res</span> = r2cf(Rational(254, 100))
        <span class="org-keyword">assert</span> <span class="org-builtin">list</span>(res) == [2, 1, 1, 5, 1, 3]
</pre>
</div>
</div>
</div>

<div id="outline-container-orge599942" class="outline-3">
<h3 id="orge599942"><span class="section-number-3">12.2.</span> Convergents</h3>
<div class="outline-text-3" id="text-12-2">
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Apply this test to two functions, because they should be equivalent</span>
<span class="org-type">@pytest.mark.parametrize</span>(<span class="org-string">'conv_func'</span>, [cf_convergents0, cf_convergents1])
<span class="org-keyword">def</span> <span class="org-function-name">test_convergents_basci1</span>(conv_func):
    <span class="org-variable-name">l</span> = <span class="org-builtin">list</span>(conv_func(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3])))
    <span class="org-keyword">assert</span> l[0] == Rational(2, 1)
    <span class="org-keyword">assert</span> l[1] == Rational(3, 1)
    <span class="org-keyword">assert</span> l[2] == Rational(5, 2)
    <span class="org-keyword">assert</span> l[3] == Rational(28, 11)
    <span class="org-keyword">assert</span> l[4] == Rational(33, 13)
    <span class="org-keyword">assert</span> l[5] == Rational(127, 50)
    <span class="org-keyword">assert</span> <span class="org-builtin">len</span>(l) == 6

<span class="org-comment-delimiter"># </span><span class="org-comment">Apply this test to two functions, because they should be equivalent</span>
<span class="org-type">@pytest.mark.parametrize</span>(<span class="org-string">'conv_func'</span>, [cf_convergents0, cf_convergents1])
<span class="org-keyword">def</span> <span class="org-function-name">test_convergents_basic2</span>(conv_func):
    <span class="org-variable-name">l</span> = <span class="org-builtin">list</span>(cf_convergents0(<span class="org-builtin">iter</span>([1, 2, 3, 4, 5])))
    <span class="org-keyword">assert</span> l[0] == Rational(1, 1)
    <span class="org-keyword">assert</span> l[1] == Rational(3, 2)
    <span class="org-keyword">assert</span> l[2] == Rational(10, 7)
    <span class="org-keyword">assert</span> l[3] == Rational(43, 30)
    <span class="org-keyword">assert</span> l[4] == Rational(225, 157)
    <span class="org-keyword">assert</span> <span class="org-builtin">len</span>(l) == 5
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">cf2r0 and cf2r1 should be equivalent</span>
<span class="org-type">@pytest.mark.parametrize</span>(<span class="org-string">'cf2r_func'</span>, [cf2r0, cf2r1])
<span class="org-keyword">def</span> <span class="org-function-name">test_cf2r</span>(cf2r_func):
    <span class="org-keyword">assert</span> cf2r_func([2, 1, 1, 5, 1, 3]) == Rational(127, 50)
    <span class="org-keyword">assert</span> cf2r_func([1, 2, 3, 4, 5]) == Rational(225, 157)
</pre>
</div>
</div>
</div>

<div id="outline-container-org74bc420" class="outline-3">
<h3 id="org74bc420"><span class="section-number-3">12.3.</span> Symbolic Euclidean algorithm</h3>
<div class="outline-text-3" id="text-12-3">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">TestQRMatrix</span>(<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">qr</span>(<span class="org-keyword">self</span>, m):
        <span class="org-variable-name">res</span> = qr_matrix(np.array(m))
        <span class="org-keyword">if</span> res <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-keyword">return</span> <span class="org-constant">None</span>
        <span class="org-keyword">else</span>:
            (q, r) = res
            <span class="org-keyword">return</span> q, r.tolist()

    <span class="org-keyword">def</span> <span class="org-function-name">test_basic1</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(4x+2)/(3x+2) is between 4/2 and 2/2 (1 to 1.33)</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">increasing</span>
        <span class="org-variable-name">m</span> = [[4, 2], [3, 2]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 1 <span class="org-keyword">and</span> r == [[3, 2], [1, 0]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_basic2</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(70x + 29)/ (12x + 5) is between 29/5 and 35/6 (5.8 to 5.88)</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">increasing. an example in the paper</span>
        <span class="org-variable-name">m</span> = [[70, 29], [12, 5]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 5 <span class="org-keyword">and</span> r == [[12, 5], [10, 4]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_basic3</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(12x + 5) / (10 x + 4) is between 6/5 and 5/4 (1.2 to 1.25)</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">decreasing. an example in the paper</span>
        <span class="org-variable-name">m</span> = [[12, 5], [10, 4]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 1 <span class="org-keyword">and</span> r == [[10, 4], [2, 1]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_edgecase1</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(10x + 4) / (2x + 1) is bounded between 4 and 5</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">the quotient is 4, because it is 5 only at infinity</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">increasing. an example in the paper</span>
        <span class="org-variable-name">m</span> = [[10, 4], [2, 1]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 4 <span class="org-keyword">and</span> r == [[2, 1], [2, 0]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_edgecase2</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(8x + 3) / (2x + 1) is bounded between 3 and 4</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">it is only 4 if x is infinity, so the quotient has to be 3</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">increasing</span>
        <span class="org-variable-name">m</span> = [[8, 3], [2, 1]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 3 <span class="org-keyword">and</span> r == [[2, 1], [2, 0]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_edgecase3</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(29x + 6) / (5x + 1) is bounded between 5.8 and 6</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">it is only 6 if x is 0, so the coefficient has to be 5</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">decreasing</span>
        <span class="org-variable-name">m</span> = [[29, 6], [5, 1]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 5 <span class="org-keyword">and</span> r == [[5, 1], [4, 1]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_unbounded1</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">4x + 2 is unbounded</span>
        <span class="org-variable-name">m</span> = [[4, 2], [0, 1]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q <span class="org-keyword">is</span> <span class="org-constant">None</span>

    <span class="org-keyword">def</span> <span class="org-function-name">test_unbounded2</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(4x + 2) / 3 is unbounded</span>
        <span class="org-variable-name">m</span> = [[4, 2], [3, 0]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q <span class="org-keyword">is</span> <span class="org-constant">None</span>

    <span class="org-keyword">def</span> <span class="org-function-name">test_unbounded3</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">2x / (2x - 1) is unbounded, because there is a singularity at x = 1/2</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">This is in the paper</span>
        <span class="org-variable-name">m</span> = [[2, 0], [2, -1]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q <span class="org-keyword">is</span> <span class="org-constant">None</span>

    <span class="org-keyword">def</span> <span class="org-function-name">test_zero_coeff</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(1x + 2) / (2x + 3) is bounded between 1/2 and 2/3 (0.5 to 0.666)</span>
        <span class="org-variable-name">m</span> = [[1, 2], [2, 3]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 0 <span class="org-keyword">and</span> r == [[2, 3], [1, 2]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_too_wide</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(7x + 5) / (x + 1) is bounded between 5 and 7. It's too wide to determine tne quotient</span>
        <span class="org-variable-name">m</span> = [[7, 5], [1, 1]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q <span class="org-keyword">is</span> <span class="org-constant">None</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org21e9378" class="outline-3">
<h3 id="org21e9378"><span class="section-number-3">12.4.</span> Transformations of continued fractions</h3>
<div class="outline-text-3" id="text-12-4">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">TestCFTransform</span>(<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">test_cf_transform_basic1</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">""" 2 * [2, 1, 1, 5, 1] == 66/13"""</span>
        <span class="org-variable-name">m0</span> = np.array([[2, 0], [0, 1]], <span class="org-builtin">int</span>)
        <span class="org-variable-name">cf1</span> = <span class="org-builtin">list</span>(cf_transform(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1]), m0 = m0))
        <span class="org-variable-name">cf2</span> = <span class="org-builtin">list</span>(r2cf(Rational(66, 13)))
        <span class="org-keyword">assert</span> cf1 == cf2

    <span class="org-keyword">def</span> <span class="org-function-name">test_cf_transform_basic1</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">""" 1 / [2, 1, 1, 5, 1] == [0, 2, 1, 1, 5, 1]"""</span>
        <span class="org-variable-name">m0</span> = np.array([[0, 1], [1, 0]], <span class="org-builtin">int</span>)
        <span class="org-variable-name">cf1</span> = <span class="org-builtin">list</span>(cf_transform(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1]), m0 = m0))
        <span class="org-variable-name">cf2</span> = [0, 2, 1, 1, 5, 1]
        <span class="org-keyword">assert</span> cf1 == cf2
</pre>
</div>
</div>
</div>

<div id="outline-container-orgedb599a" class="outline-3">
<h3 id="orgedb599a"><span class="section-number-3">12.5.</span> Bihomography</h3>
<div class="outline-text-3" id="text-12-5">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">TestBiho</span>(<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">test_biho_basic1</span>(<span class="org-keyword">self</span>):
        (a, b, c, d, e, f, g, h) = (1, 2, 3, 4, 5, 6, 7, 8)
        <span class="org-variable-name">m</span> = np.array([[a, b, c, d], [e, f, g, h]])
        <span class="org-variable-name">t</span> = tFrom2x4(m)
        <span class="org-keyword">assert</span> np.array_equal(t, np.array([[[b, d], [a, c]], [[f, h], [e, g]]]))

    <span class="org-keyword">def</span> <span class="org-function-name">test_biho_basic2</span>(<span class="org-keyword">self</span>):
        (a, b, c, d, e, f, g, h) = (1, 2, 3, 4, 5, 6, 7, 8)
        <span class="org-variable-name">m</span> = np.array([[a, b, c, d], [e, f, g, h]])
        <span class="org-variable-name">t</span> = np.array([[[b, d], [a, c]], [[f, h], [e, g]]])
        <span class="org-keyword">assert</span> np.array_equal(tTo2x4(t), m)
</pre>
</div>
</div>
</div>
<div id="outline-container-org18c9af7" class="outline-3">
<h3 id="org18c9af7"><span class="section-number-3">12.6.</span> Imports</h3>
<div class="outline-text-3" id="text-12-6">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pytest
<span class="org-keyword">from</span> cont_frac <span class="org-keyword">import</span> *
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgd86cc16" class="outline-2">
<h2 id="orgd86cc16"><span class="section-number-2">13.</span> Appendix: Display utilities</h2>
<div class="outline-text-2" id="text-13">
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;IO_IMPORTS&gt;&gt;
&lt;&lt;TAB_UTILS&gt;&gt;
&lt;&lt;TABS&gt;&gt;
&lt;&lt;TABS3D&gt;&gt;
&lt;&lt;MISC&gt;&gt;  
&lt;&lt;LATEX_UTILS&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-org1affac8" class="outline-3">
<h3 id="org1affac8"><span class="section-number-3">13.1.</span> Tabulated display utilities</h3>
<div class="outline-text-3" id="text-13-1">
<p>
<code>Chart</code> is a class for constructing and exporting tabulated displays. It can be used for 2D (i.e., operations involving one continued fraction) or 3D (operations involving two continued fractions) displays. For 2D displayed, the homographic matrices are converted into bihomographic tensors.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Utilities for tabulated displays</span>

<span class="org-keyword">class</span> <span class="org-type">Chart</span>(<span class="org-builtin">object</span>):
    <span class="org-doc">"""Construction and export tabulated displays"""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, m: np.ndarray = tForAddition):
        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(m.shape) == 2:
            <span class="org-comment-delimiter"># </span><span class="org-comment">if initialized with a matrix intead of a tensor</span>
            <span class="org-keyword">self</span>.include_b = <span class="org-constant">False</span>
            <span class="org-keyword">self</span>.mode2D = <span class="org-constant">True</span>
            <span class="org-keyword">self</span>.current_tensor = Chart.m2t(m)
            <span class="org-keyword">self</span>.boards = <span class="org-keyword">self</span>.current_tensor.tolist()
        <span class="org-keyword">else</span>:
            <span class="org-keyword">self</span>.boards = m.tolist()
            <span class="org-keyword">self</span>.include_b = <span class="org-constant">True</span>
            <span class="org-keyword">self</span>.mode2D = <span class="org-constant">False</span>
            <span class="org-keyword">self</span>.current_tensor = m.copy()

        <span class="org-keyword">self</span>.output = [<span class="org-constant">None</span>]
        <span class="org-keyword">self</span>.a = []
        <span class="org-keyword">self</span>.b = [[]]
        <span class="org-keyword">self</span>.include_a = <span class="org-constant">True</span>
        <span class="org-keyword">self</span>.include_out = <span class="org-constant">True</span>

    @<span class="org-builtin">staticmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">m2t</span>(m: np.ndarray) -&gt; np.ndarray:
        <span class="org-doc">"""Convert a homographic matrix into a bihomographic tensor"""</span>
        <span class="org-keyword">return</span> np.array([[[m[0,0], m[0,1]], [0, 0]], [[m[1,0], m[1,1]], [0, 0]]])

    &lt;&lt;TAKE_INPUT&gt;&gt;

    <span class="org-keyword">def</span> <span class="org-function-name">move_left</span>(<span class="org-keyword">self</span>, t: np.ndarray, a: <span class="org-builtin">int</span>):
        <span class="org-doc">"""t is the matrix or tensor after a new term of a"""</span>
        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(t.shape)==2 <span class="org-keyword">and</span> <span class="org-keyword">self</span>.mode2D:
            <span class="org-variable-name">t2</span> = Chart.m2t(t)
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">t2</span> = t

        <span class="org-keyword">assert</span> tensor_ref(t2, <span class="org-string">'y'</span>) == tensor_ref(<span class="org-keyword">self</span>.current_tensor, <span class="org-string">'xy'</span>)
        <span class="org-keyword">assert</span> tensor_ref(t2, <span class="org-string">'1'</span>) == tensor_ref(<span class="org-keyword">self</span>.current_tensor, <span class="org-string">'x'</span>)
        <span class="org-keyword">self</span>.current_tensor = t2

        <span class="org-comment-delimiter"># </span><span class="org-comment">add a new column for all boards</span>
        <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards)):
            <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards[0])):
                <span class="org-keyword">self</span>.boards[i][j] = [<span class="org-constant">None</span>] + <span class="org-keyword">self</span>.boards[i][j]

        <span class="org-keyword">self</span>.boards[-2][-2][0] = tensor_ref(t2, <span class="org-string">'b'</span>)
        <span class="org-keyword">self</span>.boards[-2][-1][0] = tensor_ref(t2, <span class="org-string">'a'</span>)
        <span class="org-keyword">self</span>.boards[-1][-2][0] = tensor_ref(t2, <span class="org-string">'f'</span>)
        <span class="org-keyword">self</span>.boards[-1][-1][0] = tensor_ref(t2, <span class="org-string">'e'</span>)
        <span class="org-keyword">self</span>.a = [a] + <span class="org-keyword">self</span>.a

    <span class="org-keyword">def</span> <span class="org-function-name">move_down</span>(<span class="org-keyword">self</span>, t: np.ndarray, b: <span class="org-builtin">int</span>):
        <span class="org-doc">"""t is the matrix or tensor after a new term of b"""</span>
        <span class="org-keyword">assert</span> tensor_ref(t, <span class="org-string">'x'</span>) == tensor_ref(<span class="org-keyword">self</span>.current_tensor, <span class="org-string">'xy'</span>)
        <span class="org-keyword">assert</span> tensor_ref(t, <span class="org-string">'1'</span>) == tensor_ref(<span class="org-keyword">self</span>.current_tensor, <span class="org-string">'y'</span>)
        <span class="org-keyword">self</span>.current_tensor = t
        <span class="org-variable-name">new_row_numerator</span>   = [<span class="org-constant">None</span>] * <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards[0][0])
        <span class="org-variable-name">new_row_denominator</span> = [<span class="org-constant">None</span>] * <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards[1][0])
        <span class="org-variable-name">new_row_numerator</span>[0] = tensor_ref(t, <span class="org-string">'a'</span>)
        <span class="org-variable-name">new_row_numerator</span>[1] = tensor_ref(t, <span class="org-string">'c'</span>)
        <span class="org-variable-name">new_row_denominator</span>[0] = tensor_ref(t, <span class="org-string">'e'</span>)
        <span class="org-variable-name">new_row_denominator</span>[1] = tensor_ref(t, <span class="org-string">'g'</span>)
        <span class="org-keyword">self</span>.boards[-2] = <span class="org-keyword">self</span>.boards[-2] + [new_row_numerator]
        <span class="org-keyword">self</span>.boards[-1] = <span class="org-keyword">self</span>.boards[-1] + [new_row_denominator]
        <span class="org-keyword">self</span>.b[-1] = <span class="org-keyword">self</span>.b[-1] + [b]

        <span class="org-comment-delimiter"># </span><span class="org-comment">all boards under have to be expanded</span>
        <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(0, <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards)-2):
            <span class="org-keyword">self</span>.boards[i] = <span class="org-keyword">self</span>.boards[i] + [[<span class="org-constant">None</span>] * <span class="org-builtin">len</span>(new_row_numerator)]

    <span class="org-keyword">def</span> <span class="org-function-name">move_under</span>(<span class="org-keyword">self</span>, t: np.ndarray, output: <span class="org-builtin">int</span>):
        <span class="org-doc">"""t is the matrix or tensor after a Euclidean step. output is the quotient"""</span>
        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(t.shape)==2 <span class="org-keyword">and</span> <span class="org-keyword">self</span>.mode2D:
            <span class="org-variable-name">t2</span> = Chart.m2t(t)
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">t2</span> = t

        <span class="org-keyword">assert</span> tensor_ref(<span class="org-keyword">self</span>.current_tensor, <span class="org-string">'f'</span>) == tensor_ref(t2, <span class="org-string">'b'</span>)
        <span class="org-keyword">assert</span> tensor_ref(<span class="org-keyword">self</span>.current_tensor, <span class="org-string">'h'</span>) == tensor_ref(t2, <span class="org-string">'d'</span>)
        <span class="org-keyword">assert</span> tensor_ref(<span class="org-keyword">self</span>.current_tensor, <span class="org-string">'e'</span>) == tensor_ref(t2, <span class="org-string">'a'</span>)
        <span class="org-keyword">assert</span> tensor_ref(<span class="org-keyword">self</span>.current_tensor, <span class="org-string">'g'</span>) == tensor_ref(t2, <span class="org-string">'c'</span>)
        <span class="org-keyword">self</span>.current_tensor = t2

        <span class="org-variable-name">n_rows</span> = <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards[0])
        <span class="org-variable-name">n_cols</span> = <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards[0][0])
        <span class="org-keyword">def</span> <span class="org-function-name">new_row</span>():
            <span class="org-keyword">return</span> [<span class="org-constant">None</span>] * n_cols
        <span class="org-variable-name">new_boards</span> = [new_row() <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n_rows)]

        new_boards[-2][0] = tensor_ref(t2, <span class="org-string">'f'</span>)
        new_boards[-2][1] = tensor_ref(t2, <span class="org-string">'h'</span>)
        new_boards[-1][0] = tensor_ref(t2, <span class="org-string">'e'</span>)
        new_boards[-1][1] = tensor_ref(t2, <span class="org-string">'g'</span>)
        <span class="org-keyword">self</span>.boards = <span class="org-keyword">self</span>.boards + [new_boards]

        <span class="org-variable-name">new_b</span> = [<span class="org-constant">None</span>] * <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.b[-1])
        <span class="org-keyword">self</span>.b = <span class="org-keyword">self</span>.b + [new_b]

        <span class="org-keyword">self</span>.output = <span class="org-keyword">self</span>.output + [output]

    <span class="org-keyword">def</span> <span class="org-function-name">board_to_array</span>(<span class="org-keyword">self</span>, board: <span class="org-builtin">list</span>, b: <span class="org-builtin">list</span>, out: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">list</span>:
        <span class="org-variable-name">new_content</span> = []
        <span class="org-keyword">for</span> i, row <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(board):
            <span class="org-variable-name">skip</span> = <span class="org-constant">False</span>
            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.mode2D <span class="org-keyword">and</span> i%2==1:
                <span class="org-variable-name">skip</span> = <span class="org-constant">True</span>

            <span class="org-keyword">if</span> <span class="org-keyword">not</span> skip:
                <span class="org-variable-name">new_row</span> = row.copy()

                <span class="org-keyword">if</span> <span class="org-keyword">self</span>.include_b:
                    <span class="org-keyword">if</span> i == 0:
                        <span class="org-variable-name">new_row</span> = new_row + [<span class="org-constant">None</span>]
                    <span class="org-keyword">elif</span> b <span class="org-keyword">is</span> <span class="org-constant">None</span>:
                        <span class="org-variable-name">new_row</span> = new_row + [<span class="org-constant">None</span>]
                    <span class="org-keyword">elif</span> i &lt;= <span class="org-builtin">len</span>(b):
                        <span class="org-variable-name">new_row</span> = new_row + [b[i-1]]
                    <span class="org-keyword">else</span>:
                        <span class="org-variable-name">new_row</span> = new_row + [<span class="org-constant">None</span>]

                <span class="org-keyword">if</span> <span class="org-keyword">self</span>.include_out:
                    <span class="org-keyword">if</span> i == <span class="org-builtin">len</span>(board) - 2:
                        <span class="org-variable-name">new_row</span> = new_row + [out]
                    <span class="org-keyword">else</span>:
                        <span class="org-variable-name">new_row</span> = new_row + [<span class="org-constant">None</span>]

                <span class="org-variable-name">new_content</span> = new_content + [new_row]
        <span class="org-keyword">return</span> new_content

    <span class="org-keyword">def</span> <span class="org-function-name">to_array</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">list</span>:
        <span class="org-variable-name">content</span> = []
        <span class="org-variable-name">row</span> = []
        <span class="org-variable-name">n_rows</span> = <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards[0])
        <span class="org-variable-name">n_cols</span> = <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards[0][0])

        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.include_a:
            <span class="org-variable-name">row</span> = row + [<span class="org-constant">None</span>]
            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.include_b:
                <span class="org-variable-name">row</span> = row + [<span class="org-constant">None</span>]
            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.include_out:
                <span class="org-variable-name">row</span> = row + [<span class="org-constant">None</span>]
            <span class="org-variable-name">row</span> = <span class="org-keyword">self</span>.a + row
            <span class="org-variable-name">row</span> = [<span class="org-constant">None</span>] * (n_cols - <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.a) - 1) + row
            <span class="org-variable-name">content</span> = content + [row]

        <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards)):
            <span class="org-variable-name">board</span> = <span class="org-keyword">self</span>.boards[i]
            <span class="org-variable-name">b</span> = <span class="org-keyword">self</span>.b[i] <span class="org-keyword">if</span> i&lt;<span class="org-builtin">len</span>(<span class="org-keyword">self</span>.b) <span class="org-keyword">else</span> <span class="org-constant">None</span>
            <span class="org-variable-name">out</span> = <span class="org-keyword">self</span>.output[i] <span class="org-keyword">if</span> i&lt;<span class="org-builtin">len</span>(<span class="org-keyword">self</span>.output) <span class="org-keyword">else</span> <span class="org-constant">None</span>
            <span class="org-variable-name">content</span> = content + <span class="org-keyword">self</span>.board_to_array(board, b, out)

        <span class="org-keyword">return</span> content

    @<span class="org-builtin">staticmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">pp_item</span>(item: <span class="org-builtin">int</span>, field_width: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">str</span>:
        <span class="org-keyword">if</span> item <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-keyword">return</span> <span class="org-string">" "</span> * field_width
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> f<span class="org-string">"{item : &gt; {field_width}}"</span>

    @<span class="org-builtin">staticmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">pp_row</span>(row: <span class="org-builtin">list</span>, field_width: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">str</span>:
        <span class="org-keyword">return</span> <span class="org-builtin">reduce</span>(<span class="org-keyword">lambda</span> s, item: s + Chart.pp_item(item, field_width), row, <span class="org-string">""</span>) + <span class="org-string">"\n"</span>

    <span class="org-keyword">def</span> <span class="org-function-name">__repr__</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:
        <span class="org-variable-name">content</span> = <span class="org-keyword">self</span>.to_array()

        <span class="org-variable-name">content_nonone</span> = [[c <span class="org-keyword">for</span> c <span class="org-keyword">in</span> row <span class="org-keyword">if</span> c <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>] <span class="org-keyword">for</span> row <span class="org-keyword">in</span> content]
        <span class="org-variable-name">content_nonone</span> = [r <span class="org-keyword">for</span> r <span class="org-keyword">in</span> content_nonone <span class="org-keyword">if</span> r != []]
        <span class="org-variable-name">mx</span> = <span class="org-builtin">max</span>(<span class="org-builtin">map</span>(<span class="org-builtin">max</span>, content_nonone))
        <span class="org-variable-name">field_width</span> = <span class="org-builtin">len</span>(<span class="org-builtin">str</span>(mx)) + 1

        <span class="org-variable-name">s</span> = <span class="org-builtin">reduce</span>(<span class="org-keyword">lambda</span> s, r: s + Chart.pp_row(r, field_width), content, <span class="org-string">""</span>)
        <span class="org-keyword">return</span> s

    <span class="org-keyword">def</span> <span class="org-function-name">export_csv</span>(<span class="org-keyword">self</span>, filename: <span class="org-builtin">str</span>):
        <span class="org-variable-name">content</span> = <span class="org-keyword">self</span>.to_array()
        <span class="org-keyword">with</span> <span class="org-builtin">open</span>(filename, mode = <span class="org-string">'w'</span>) <span class="org-keyword">as</span> outfile:
            <span class="org-variable-name">writer</span> = csv.writer(outfile)
            writer.writerows(content)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">test</span>():
    <span class="org-keyword">pass</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-org2859e75" class="outline-3">
<h3 id="org2859e75"><span class="section-number-3">13.2.</span> Tabulated displays: 2D</h3>
<div class="outline-text-3" id="text-13-2">
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Tabulated displays: 2D</span>

<span class="org-keyword">def</span> <span class="org-function-name">r2cf_tab</span>(rn: Rational) -&gt; <span class="org-builtin">str</span>:
    <span class="org-doc">"""Show the prpocess of converting a rational numner to a continued fraction"""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">row</span>(st: <span class="org-builtin">str</span>, x: <span class="org-builtin">tuple</span>):
        <span class="org-variable-name">b</span>, <span class="org-variable-name">q</span> = x
        <span class="org-keyword">return</span> st + f<span class="org-string">"{b : &gt; 5}  {q : &lt; 5}\n"</span>
    <span class="org-variable-name">str0</span> = f<span class="org-string">"{rn.a : &gt; 5}\n"</span>
    <span class="org-keyword">return</span> <span class="org-builtin">reduce</span>(row, r2cf_(rn), str0) + f<span class="org-string">"{0 : &gt; 5}\n"</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_convergents1_tab</span>(cf: Iterator[<span class="org-builtin">int</span>]) -&gt; Chart:
    <span class="org-doc">"""Show the process of converting a continued fraction to a rational number"""</span>
    <span class="org-variable-name">chart</span> = Chart(m = np.identity(2, <span class="org-builtin">int</span>))
    <span class="org-variable-name">chart.include_out</span> = <span class="org-constant">False</span>
    (cf1, cf2) = tee(cf)
    <span class="org-keyword">for</span> (mat, a) <span class="org-keyword">in</span> <span class="org-builtin">zip</span>(cf_convergents1_(cf1), cf2):
        chart.move_left(mat, a)
    <span class="org-keyword">return</span> chart
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">euclid_matrix_tab</span>(m: np.ndarray) -&gt; Chart:
    <span class="org-doc">"""Show the matrix form of the Euclidean algorithm"""</span>
    <span class="org-variable-name">chart</span> = Chart(m = m)
    <span class="org-keyword">for</span> (q, r) <span class="org-keyword">in</span> euclid_matrix_(m):
        chart.move_under(r, q)
    <span class="org-keyword">return</span> chart
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_transform_tab</span>(cf: Iterator[<span class="org-builtin">int</span>], m0 = np.identity(2, <span class="org-builtin">int</span>)) -&gt; Chart:
    <span class="org-doc">"""Show the process of operating on a continued fraction.</span>
<span class="org-doc">    Make sure that cf has finite number of terms</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">chart</span> = Chart(m = m0)
    <span class="org-variable-name">res</span> = cf_transform_(cf, m0)

    <span class="org-keyword">for</span> (q, r, m, a, new_a) <span class="org-keyword">in</span> res:
        <span class="org-keyword">if</span> new_a:
            chart.move_left(m, a)
        <span class="org-keyword">if</span> q <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">this means that no euclid step was performed</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">do nothing</span>
            <span class="org-keyword">pass</span>
        <span class="org-keyword">else</span>:
            <span class="org-keyword">if</span> r <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
                chart.move_under(r, q)
            <span class="org-keyword">else</span>:
                <span class="org-comment-delimiter"># </span><span class="org-comment">r is None, meaning that the quotients are for rational numbers rathen than matrices</span>
                <span class="org-variable-name">chart.output</span> = chart.output + [q]
    <span class="org-keyword">return</span> chart
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc77bf00" class="outline-3">
<h3 id="orgc77bf00"><span class="section-number-3">13.3.</span> Tabulated displays: 3D</h3>
<div class="outline-text-3" id="text-13-3">
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Tabulated displays: 3D</span>

<span class="org-keyword">def</span> <span class="org-function-name">arithmetic_convergents_tab</span>(a: Iterator[<span class="org-builtin">int</span>], b: Iterator[<span class="org-builtin">int</span>], t0: np.ndarray = tForAddition) -&gt; Chart:
    <span class="org-doc">"""Show the process of calculating convergents of arithmetical operations"""</span>
    <span class="org-variable-name">c</span> = Chart(t0)
    <span class="org-keyword">for</span> direction, coefficient, t <span class="org-keyword">in</span> arithmetic_convergents_(a, b, t0):
        <span class="org-keyword">if</span> direction == <span class="org-string">'a'</span>:
            c.move_left(t, coefficient)
        <span class="org-keyword">else</span>:
            c.move_down(t, coefficient)
    <span class="org-keyword">return</span> c
</pre>
</div>
</div>
</div>

<div id="outline-container-org47c5dd5" class="outline-3">
<h3 id="org47c5dd5"><span class="section-number-3">13.4.</span> Pretty printing utilities</h3>
<div class="outline-text-3" id="text-13-4">
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Pretty printing utilities</span>

<span class="org-keyword">def</span> <span class="org-function-name">pp_qr</span>(qr: Tuple[<span class="org-builtin">int</span>, np.ndarray]) -&gt; <span class="org-constant">None</span>:
    <span class="org-doc">"""Pretty print a tuple of a quotient and a remainder matrix"""</span>
    <span class="org-variable-name">q</span>, <span class="org-variable-name">r</span> = qr
    <span class="org-keyword">print</span>(f<span class="org-string">"{q:&gt;2} {r[0][0]:2} {r[0][1]:2}"</span>)
    <span class="org-keyword">print</span>(f<span class="org-string">"   {r[1][0]:2} {r[1][1]:2}"</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">pp_inf_cf</span>(cf: <span class="org-builtin">list</span>) -&gt; <span class="org-builtin">str</span>:
    <span class="org-doc">"""Pretty print a list representing the first couple terms of a longer continued fraction"""</span>
    <span class="org-variable-name">res</span> = <span class="org-string">"["</span>
    <span class="org-variable-name">res</span> = res + <span class="org-builtin">reduce</span>(<span class="org-keyword">lambda</span> s, n: s + <span class="org-builtin">str</span>(n) + <span class="org-string">","</span>, cf, <span class="org-string">""</span>)
    <span class="org-variable-name">res</span> = res[:-1] + <span class="org-string">"...]"</span>
    <span class="org-keyword">return</span> res
</pre>
</div>
</div>
</div>

<div id="outline-container-org0af09ba" class="outline-3">
<h3 id="org0af09ba"><span class="section-number-3">13.5.</span> LaTeX utilities</h3>
<div class="outline-text-3" id="text-13-5">
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Utilities functions for LaTeX displays</span>

<span class="org-keyword">def</span> <span class="org-function-name">latex_cf</span>(lst: <span class="org-builtin">list</span>) -&gt; <span class="org-builtin">str</span>:
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(lst) == 1:
        <span class="org-keyword">return</span> <span class="org-builtin">str</span>(lst[0])
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">x</span> = <span class="org-builtin">str</span>(lst[0]) + <span class="org-string">"+"</span>
        <span class="org-variable-name">x</span> = x + r<span class="org-string">"\frac{1}{"</span> + latex_cf(lst[1:]) + <span class="org-string">"}"</span>
        <span class="org-keyword">return</span> x

<span class="org-keyword">def</span> <span class="org-function-name">latex_rational</span>(r: Rational) -&gt; <span class="org-builtin">str</span>:
    <span class="org-keyword">return</span> r<span class="org-string">"\frac{"</span> + <span class="org-builtin">str</span>(r.a) + <span class="org-string">"}{"</span> + <span class="org-builtin">str</span>(r.b) + <span class="org-string">"}"</span>

<span class="org-keyword">def</span> <span class="org-function-name">show_cf_expansion</span>(r: Rational) -&gt; <span class="org-builtin">str</span>:
    <span class="org-keyword">print</span>(r<span class="org-string">"\["</span>)
    <span class="org-keyword">print</span>(r<span class="org-string">"\frac{"</span>, r.a, <span class="org-string">"}{"</span>, r.b, <span class="org-string">"}="</span>)
    <span class="org-variable-name">nc</span> = <span class="org-builtin">list</span>(r2cf(r))
    <span class="org-keyword">print</span>(latex_cf(nc))
    <span class="org-keyword">print</span>(r<span class="org-string">"\]"</span>)

<span class="org-keyword">def</span> <span class="org-function-name">show_rational_series</span>(itr: Iterator[<span class="org-builtin">int</span>]) -&gt; <span class="org-builtin">str</span>:
    <span class="org-variable-name">rLst</span> = <span class="org-builtin">list</span>(cf_convergents0(itr))
    <span class="org-variable-name">s</span> = <span class="org-string">""</span>
    <span class="org-keyword">for</span> r <span class="org-keyword">in</span> rLst:
        <span class="org-variable-name">s</span> = s + <span class="org-string">"$"</span> + latex_rational(r) + <span class="org-string">"$"</span> + <span class="org-string">","</span>

    <span class="org-keyword">print</span>(s[:-1])
</pre>
</div>
</div>
</div>
<div id="outline-container-org171b263" class="outline-3">
<h3 id="org171b263"><span class="section-number-3">13.6.</span> Imports</h3>
<div class="outline-text-3" id="text-13-6">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> cont_frac <span class="org-keyword">import</span> *
<span class="org-keyword">from</span> functools <span class="org-keyword">import</span> <span class="org-builtin">reduce</span>
<span class="org-keyword">import</span> csv
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org5799451" class="outline-2">
<h2 id="org5799451"><span class="section-number-2">14.</span> Appendix: Imports</h2>
<div class="outline-text-2" id="text-14">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> math
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> typing <span class="org-keyword">import</span> NamedTuple, Iterator, Tuple, Optional
<span class="org-keyword">from</span> functools <span class="org-keyword">import</span> <span class="org-builtin">reduce</span>
<span class="org-keyword">from</span> itertools <span class="org-keyword">import</span> tee, islice
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> cont_frac <span class="org-keyword">import</span> *
<span class="org-keyword">from</span> cont_frac_io <span class="org-keyword">import</span> *
<span class="org-keyword">from</span> itertools <span class="org-keyword">import</span> islice
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hsin-Hao Yu</p>
<p class="date">Created: 2022-04-25 Mon 22:43</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
