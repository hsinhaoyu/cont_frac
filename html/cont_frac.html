<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2022-05-01 Sun 08:56 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Understanding Bill Gospher's continued fraction arithmetic (implemented in Python)</title>
<meta name="author" content="Hsin-Hao Yu" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/src/readtheorg_theme/js/readtheorg.js"></script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "left",
        displayIndent: "0em",

        "HTML-CSS": { scale: 85,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 85,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 85},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Understanding Bill Gospher's continued fraction arithmetic (implemented in Python)</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orge2896bf">1. Representing rational numbers as continued fractions</a></li>
<li><a href="#org7553a73">2. Calculating the convergents of a continued fraction</a></li>
<li><a href="#org1c8d332">3. Continued fractions as recursive functions</a></li>
<li><a href="#org1e6d8d6">4. Calculating convergents using matrices</a></li>
<li><a href="#org0dadee1">5. Turning convergents into continued fractions using the Euclidean algorithm</a></li>
<li><a href="#orgf547574">6. Simple transformations of continued fractions</a></li>
<li><a href="#org10cc324">7. Arithmetic (Step 1): From matrices to tensors</a></li>
<li><a href="#orgb6ca73c">8. Arithmetic (Step 2):  Representing arithmetic operations</a></li>
<li><a href="#org4f6958d">9. Arithmetic (Step 3): Calculating convergents using tensors</a></li>
<li><a href="#org1d9f204">10. Arithmetic (Step 4): Applying the Euclidean algorithm to convergents</a></li>
<li><a href="#org05af327">11. The final section with complex figures</a></li>
<li><a href="#org0f1761a">12. Appendix: Quotients/remainders for matrices</a></li>
<li><a href="#org8a7d946">13. Appendix: Quotients/remainders for tensors</a></li>
<li><a href="#orgaa3f244">14. Appendix: Unit tests</a>
<ul>
<li><a href="#org3f9c00f">14.1. Using continued fractions to represent rational numbers</a></li>
<li><a href="#orgc0f89a4">14.2. Convergents</a></li>
<li><a href="#org0567cd9">14.3. Symbolic Euclidean algorithm</a></li>
<li><a href="#orgf96ffb3">14.4. Transformations of continued fractions</a></li>
<li><a href="#org95751bb">14.5. Bihomography</a></li>
<li><a href="#org0482f23">14.6. Imports</a></li>
</ul>
</li>
<li><a href="#org805551c">15. Appendix: Display utilities</a>
<ul>
<li><a href="#orgb205175">15.1. Tabulated display utilities</a>
<ul>
<li><a href="#orgb91d275">15.1.1. Take inputs from continued fractions</a></li>
<li><a href="#orga7754d7">15.1.2. Process output</a></li>
<li><a href="#orgbd0e5d7">15.1.3. Convert to array</a></li>
<li><a href="#org1e9ccbc">15.1.4. Display/export</a></li>
</ul>
</li>
<li><a href="#orgd70e2cf">15.2. Tabulated displays: 2D</a></li>
<li><a href="#orgd4c4962">15.3. Tabulated displays: 3D</a></li>
<li><a href="#orgb82d23f">15.4. Pretty printing utilities</a></li>
<li><a href="#org634332e">15.5. LaTeX utilities</a></li>
<li><a href="#orga55a918">15.6. Imports</a></li>
</ul>
</li>
<li><a href="#org38373c7">16. Appendix: Imports and outlines</a></li>
</ul>
</div>
</div>


<div id="outline-container-orge2896bf" class="outline-2">
<h2 id="orge2896bf"><span class="section-number-2">1.</span> Representing rational numbers as continued fractions</h2>
<div class="outline-text-2" id="text-1">
<p>
Since we'll use rational numbers a lot, let's define a class:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">Rational</span>(NamedTuple(<span class="org-string">'Rational'</span>, [(<span class="org-string">'a'</span>, <span class="org-builtin">int</span>), (<span class="org-string">'b'</span>, <span class="org-builtin">int</span>)])):
    <span class="org-doc">"""Rational(a, b) = a/b"""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__repr__</span>(<span class="org-keyword">self</span>):
        <span class="org-keyword">return</span> f<span class="org-string">'{self.a}/{self.b}'</span>
</pre>
</div>

<p>
How to convert a rational number to a continued fraction? Observing that
</p>

<p>
\[
\frac{254}{100}
= 2 + \frac{54}{100}
= 2 + \frac{1}{\frac{100}{54}}
= 2 + \frac{1}{1 + \frac{46}{54}}
= 2 + \frac{1}{1 + \frac{1}{\frac{46}{54}}}
\]
</p>

<p>
it should be obvious that the solution is just the <a href="https://en.wikipedia.org/wiki/Euclidean_algorithm">Euclidean algorithm</a> for finding the greatest common divider: we first decompose the numerator \(a\) as \(a=b*q+r\), where \(b\) is the denominator, \(q\) is an integer called the <i>quotient</i>, and \(r\) is the remainder. We output \(q\), and repeat the process, using \(b\) as the numerator and \(r\) as the denominator. We stop when the numerator becomes 0. 
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Convert a rational number to a continued fraction</span>

<span class="org-keyword">def</span> <span class="org-function-name">qr</span>(a: <span class="org-builtin">int</span>, b: <span class="org-builtin">int</span>) -&gt; Tuple[<span class="org-builtin">int</span>, <span class="org-builtin">int</span>]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Find the quotient and remainder of a rational number.</span>

<span class="org-doc">    a = b * q + r, return (q, r).</span>
<span class="org-doc">    :param a: The numerator of the rational number</span>
<span class="org-doc">    :param b: The denominator of the rational number</span>
<span class="org-doc">    :return: (quotient, remainder)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">q</span> = math.floor(a / b)  <span class="org-comment-delimiter"># </span><span class="org-comment">the quotient</span>
    <span class="org-variable-name">r</span> = a - b * q          <span class="org-comment-delimiter"># </span><span class="org-comment">the remainder</span>
    <span class="org-keyword">return</span> (q, r)

<span class="org-keyword">def</span> <span class="org-function-name">r2cf_</span>(rn: Rational) -&gt; Iterator[Tuple[<span class="org-builtin">int</span>, <span class="org-builtin">int</span>]]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Turn a rational number into a continued fraction.</span>

<span class="org-doc">    The Euclidean algoirthm.</span>
<span class="org-doc">    :param rn: The rational number</span>
<span class="org-doc">    :return: An iterator of the old denominator and the quotient</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span> = rn
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-variable-name">q</span>, <span class="org-variable-name">r</span> = qr(a, b)
        <span class="org-keyword">yield</span> b, q
        <span class="org-keyword">if</span> r == 0:
            <span class="org-keyword">break</span>
        <span class="org-variable-name">a</span>, <span class="org-variable-name">b</span> = b, r

<span class="org-keyword">def</span> <span class="org-function-name">r2cf</span>(rn: Rational) -&gt; Iterator[<span class="org-builtin">int</span>]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Turn a rational number to a continued fraction.</span>

<span class="org-doc">    :param rn: The rational number</span>
<span class="org-doc">    :return: An iterator of integers</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">def</span> <span class="org-function-name">second</span>(x: <span class="org-builtin">tuple</span>):
        <span class="org-keyword">return</span> x[1]
    <span class="org-keyword">return</span> <span class="org-builtin">map</span>(second, r2cf_(rn))
</pre>
</div>

<p>
Now we can use <code>r2cf</code> to convert a rational number into a continued fraction. In this article, I use Python generators to represent continued fractions, because they can have infinite number of terms. However, in the specific case of <code>r2cf</code>, the generators returned always have finite numbers of terms, because the continued fractions associated with rational numbers always have finite numbers of terms. This is one of the fundamental properties of rational numbers.
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">nc</span> = r2cf(Rational(254, 100))
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(nc))
</pre>
</div>

<pre class="example">
[2, 1, 1, 5, 1, 3]
</pre>


<p>
This means that
\[
\frac{ 254 }{ 100 }=
2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}
\]
</p>

<p>
We can display the process in a tabular format. For example:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(r2cf_tab(Rational(254, 100)))
</pre>
</div>

<pre class="example">
254
100   2   
 54   1   
 46   1   
  8   5   
  6   1   
  2   3   
  0

</pre>


<p>
On the top, we begin with the rational number \(\frac{254}{100}\). The quotient 2, displayed on the side, is the first term of the continued fraction. The rational number now becomes \(\frac{100}{54}\), and we continue the process until we reach 0. As a side note, the penultimate numerator 2 is the greatest common divider for 254 and 100, according to the Euclidean algorithm.
</p>

<p>
Interestingly, the reciprocal of \(\frac{254}{100}\) (that is, \(\frac{100}{254}\)) is represented by the following as a continued fraction:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">nc</span> = r2cf(Rational(100, 254))
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(nc))
</pre>
</div>

<pre class="example">
[0, 2, 1, 1, 5, 1, 3]
</pre>


<p>
It's the same sequence with an additional 0 at the beginning! This is our first clue that a continued fraction can be transformed by performing some operations at the beginning of the Euclidean algorithm. We'll come back to this point later.
</p>
</div>
</div>

<div id="outline-container-org7553a73" class="outline-2">
<h2 id="org7553a73"><span class="section-number-2">2.</span> Calculating the convergents of a continued fraction</h2>
<div class="outline-text-2" id="text-2">
<p>
Given a continued fraction, how do we calculate its value? If the series is finite, we can easily write a recursive function. However, if it's an infinite series, we need a method to incrementally approximate the value as more terms are received. Also, we want the evaluation to be accumulative, so that each update is based on the previous one.
</p>

<p>
This question has an easy solution if we use a series of rational numbers to approximate the continued fraction. Each term in the series is called a <i>convergent</i>. The formula for the convergents can be derived easily with mathematical induction, and it is implemented below. For the moment, we'll use the formula just a convenience to get the job done. We'll get deeper into its meaning in the next section.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the convergents of a continued fraction</span>

<span class="org-keyword">def</span> <span class="org-function-name">cf_convergents0</span>(cf: Iterator[<span class="org-builtin">int</span>]) -&gt; Iterator[Rational]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the convergents of a continued fraction.</span>

<span class="org-doc">    :param cf: A continued fraction</span>
<span class="org-doc">    :return: An iterator of rational numbers</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">p1</span>, <span class="org-variable-name">p0</span> = 1, 0
    <span class="org-variable-name">q1</span>, <span class="org-variable-name">q0</span> = 0, 1

    <span class="org-keyword">for</span> a <span class="org-keyword">in</span> cf:
        <span class="org-variable-name">p</span> = a * p1 + p0
        <span class="org-variable-name">q</span> = a * q1 + q0
        <span class="org-keyword">yield</span> Rational(p, q)

        <span class="org-variable-name">p0</span>, <span class="org-variable-name">p1</span> = p1, p
        <span class="org-variable-name">q0</span>, <span class="org-variable-name">q1</span> = q1, q
</pre>
</div>

<p>
<a id="orgb9d155f"></a>For example, for the continued fraction \([2, 1, 1, 5, 1, 3]\), we get
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_convergents0(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3]))))
</pre>
</div>

<pre class="example">
[2/1, 3/1, 5/2, 28/11, 33/13, 127/50]
</pre>


<p>
In other words, 
\(2+\frac{1}{1+\frac{1}{1+\frac{1}{5+\frac{1}{1+\frac{1}{3}}}}}\)
can be approximated with
\(\frac{2}{1}\),\(\frac{3}{1}\),\(\frac{5}{2}\),\(\frac{28}{11}\),\(\frac{33}{13}\),\(\frac{127}{50}\)
.
</p>

<p>
For convenience, we define a specialized version of <code>cf_convergents0</code> just for finite-term continued fractions. It returns the rational number corresponding to the continued fraction:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf2r0</span>(cf: Iterator[<span class="org-builtin">int</span>]) -&gt; Rational:
    <span class="org-doc">"""</span>
<span class="org-doc">    The value of a finite-length continued fraction as a rational number.</span>

<span class="org-doc">    This function will get into an infinite loop if the iterator doesn't stop.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> <span class="org-builtin">list</span>(cf_convergents0(cf))[-1]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(cf2r0(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3])))
</pre>
</div>

<pre class="example">
127/50
</pre>


<p>
Another example: the irrational number \(e\) can be expressed as a continued fraction by this code:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Examples of continued fractions</span>

<span class="org-keyword">def</span> <span class="org-function-name">cf_e</span>() -&gt; Iterator[<span class="org-builtin">int</span>]:
    <span class="org-doc">'''e as a continued fraction'''</span>
    <span class="org-keyword">yield</span> 2
    <span class="org-variable-name">k</span> = 0
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">a finite generator comprehension</span>
        <span class="org-keyword">for</span> i <span class="org-keyword">in</span> (j <span class="org-keyword">for</span> j <span class="org-keyword">in</span> [1, 2 * k + 2, 1]):
            <span class="org-keyword">yield</span> i
        <span class="org-variable-name">k</span> = k + 1
</pre>
</div>

<p>
It has infinite number of terms, but the series follows a simple pattern. This is just the first 16 terms:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(islice(cf_e(), 16)))
</pre>
</div>

<pre class="example">
[2, 1, 2, 1, 1, 4, 1, 1, 6, 1, 1, 8, 1, 1, 10, 1]
</pre>


<p>
Here are the convergents, as rational and as floating point numbers:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">conv_</span> = cf_convergents0(cf_e())
<span class="org-variable-name">conv</span> = <span class="org-builtin">list</span>(islice(conv_, 16)) <span class="org-comment-delimiter"># </span><span class="org-comment">the first 16 convergents</span>
<span class="org-keyword">for</span> c <span class="org-keyword">in</span> conv:
    <span class="org-keyword">print</span>(f<span class="org-string">'{repr(c):&lt;20} {c[0]/c[1]:.8f}'</span>)
</pre>
</div>

<pre class="example" id="orgca425c4">
2/1                  2.00000000
3/1                  3.00000000
8/3                  2.66666667
11/4                 2.75000000
19/7                 2.71428571
87/32                2.71875000
106/39               2.71794872
193/71               2.71830986
1264/465             2.71827957
1457/536             2.71828358
2721/1001            2.71828172
23225/8544           2.71828184
25946/9545           2.71828182
49171/18089          2.71828183
517656/190435        2.71828183
566827/208524        2.71828183
</pre>
</div>
</div>

<div id="outline-container-org1c8d332" class="outline-2">
<h2 id="org1c8d332"><span class="section-number-2">3.</span> Continued fractions as recursive functions</h2>
<div class="outline-text-2" id="text-3">
<p>
<a id="org545ca2a"></a>
Given the first 3 terms in a continued fraction \([5, 1, 4...]\), let \(x\) denote the reciprocal of the value of the remaining series. We can express the convergent as \(f_1(x)\), \(f_2(x)\), \(f_3(x)\)&#x2026;, where
</p>

\begin{equation*}
    f_1(x) = 5 + \frac{1}{x}
\end{equation*}

\begin{equation*}
    f_2(x) = 5 + \frac{1}{1 + \frac{1}{x}} = f_1(1 + \frac{1}{x})
\end{equation*}

\begin{equation*}
    f_3(x) = 5 + \frac{1}{1 + \frac{1}{4 + \frac{1}{x}}} = f_1(f_2(4 + \frac{1}{x}))
\end{equation*}

<p>
Or more compactly, let
</p>
\begin{equation*}
    h(a, x) = a + \frac{1}{x}
\end{equation*}

<p>
then
</p>
\begin{equation*}
    f_1(x) = h(5, x)
\end{equation*}

\begin{equation*}
    f_2(x) = h(5, h(1, x))
\end{equation*}

\begin{equation*}
    f_3(x) = h(5, h(1, h(4, x))) 
\end{equation*}

<p>
This way, we express the approximation as a recursive process. If the continued fraction stops at the third term, its value is \(h_3(\infty) = h(5, h(1, h(4, \infty)))\). Infinity might seem odd here, but remember that \(x\) is the reciprocal of the rest of the sequence. So it just means that the rest of the sequence evaluates to 0.
</p>

<p>
Before we rush to translate this into code, let's dig deeper. If we use column vectors to represent rational numbers:
</p>

\begin{equation*}
    \begin{bmatrix}
           p \\
           q
    \end{bmatrix} = \frac{p}{q}
\end{equation*}

<p>
Then we can turn everything into linear algebra:
</p>

\begin{equation*}
    h(a, x) = a + \frac{1}{x} = \frac{ax + 1}{x}
\end{equation*}

<p>
can be written in our matrix notation as
</p>

\begin{equation*}

    \begin{bmatrix}
        ax + 1 \\
        x
    \end{bmatrix}

    =

    \begin{bmatrix}
        a & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix}
\end{equation*}

<p>
Furthermore, 
</p>

\begin{equation*}
    f_3(x) = h(5, h(1, h(4, x)))
\end{equation*}

<p>
can be written as
</p>

\begin{equation*}

    \begin{bmatrix}
        5 & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        1 & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        4 & 1 \\
        1 & 0
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix}

    = 

    \begin{bmatrix}
        29 & 6 \\
        5 & 1
    \end{bmatrix}

    \begin{bmatrix}
        x \\
        1 
    \end{bmatrix}

\end{equation*}

<p>
So, the 2-by-2 matrix
</p>

<p>
\(\begin{bmatrix}
    29 & 6 \\
     5 & 1
\end{bmatrix}\)
</p>

<p>
represents a function that approximates a continued fraction with more terms. If the continued fractions has only 3 terms, we terminate the process by evaluating
</p>

\begin{equation*}

    \begin{bmatrix}
        29 & 6 \\
         5 & 1
    \end{bmatrix}

    \begin{bmatrix}
        1 \\
        0 
    \end{bmatrix}

    = 

    \begin{bmatrix}
        29 \\
         5
    \end{bmatrix}

    = \frac{29}{5}
\end{equation*}

<p>
Multiplying the matrix with
\(\begin{bmatrix}
    1 \\
    0 
\end{bmatrix}\) turns the function into a rational value, which is the first column of the matrix.
</p>
</div>
</div>

<div id="outline-container-org1e6d8d6" class="outline-2">
<h2 id="org1e6d8d6"><span class="section-number-2">4.</span> Calculating convergents using matrices</h2>
<div class="outline-text-2" id="text-4">
<p>
Now, we are ready to rewrite the formula in <code>cf_convergents0</code> as matrix multiplications:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the convergents using matrix multiplication</span>

<span class="org-keyword">def</span> <span class="org-function-name">h</span>(a: <span class="org-builtin">int</span>) -&gt; np.ndarray:
    <span class="org-doc">'''Homographic matrix for one term of continued fraction'''</span>
    <span class="org-keyword">return</span> np.array([[a, 1], [1,0]])

<span class="org-keyword">def</span> <span class="org-function-name">cf_convergents1_</span>(cf: Iterator[<span class="org-builtin">int</span>]) -&gt; Iterator[np.ndarray]:
    <span class="org-doc">"""</span>
<span class="org-doc">    The convergents (as matrices) of a continued fraction.</span>

<span class="org-doc">    :param cf: The continued fraction</span>
<span class="org-doc">    :return: An iterator of 2x2 matrices representing the convergents</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">res</span> = np.array([[1, 0], [0, 1]])
    <span class="org-keyword">for</span> a <span class="org-keyword">in</span> cf:
        <span class="org-variable-name">res</span> = np.matmul(res, h(a))
        <span class="org-keyword">yield</span> res

<span class="org-keyword">def</span> <span class="org-function-name">cf_convergents1</span>(cf: Iterator[<span class="org-builtin">int</span>]) -&gt; Iterator[Rational]:
    <span class="org-doc">"""</span>
<span class="org-doc">    The convergents (as rational numbers ) of a continued fraction</span>

<span class="org-doc">    :param cf: The continued fraction</span>
<span class="org-doc">    :return: An iterator of rational numbers</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">mLst</span> = cf_convergents1_(cf)
    <span class="org-keyword">for</span> m <span class="org-keyword">in</span> mLst:
        <span class="org-keyword">yield</span> Rational(m[0, 0], m[1, 0])
</pre>
</div>

<p>
<a id="org2bfe2c9"></a>Let's try it on an example that we used <a href="#orgb9d155f">previously</a>:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_convergents1(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3]))))
</pre>
</div>

<pre class="example">
[2/1, 3/1, 5/2, 28/11, 33/13, 127/50]
</pre>


<p>
A very charming thing that Gosper did was that he used a compact tabulated format to illustrate the process. It's unnecessary for the computation, but I think it looks pretty cool:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(cf_convergents1_tab(<span class="org-builtin">iter</span>([5, 1, 4])))
</pre>
</div>

<pre class="example">
    4  1  5   
29  6  5  1  0
 5  1  1  0  1

</pre>


<p>
This table is read from the right to the left. The right-to-left direction takes some getting used to, but it's needed to preserve the normal representation of matrices. The first row represents the terms of the continued fraction. What are the numbers below the first row? They are the matrices representing the convergents associated with \([5, 1, 4]\). To see why, we calculate the matrices for each additional term in the continued fraction:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">itr</span> = cf_convergents1_(<span class="org-builtin">iter</span>([5, 1, 4]))
<span class="org-keyword">print</span>(<span class="org-builtin">next</span>(itr),<span class="org-string">"\n"</span>)
<span class="org-keyword">print</span>(<span class="org-builtin">next</span>(itr),<span class="org-string">"\n"</span>)
<span class="org-keyword">print</span>(<span class="org-builtin">next</span>(itr))
</pre>
</div>

<pre class="example">
[[5 1]
 [1 0]] 

[[6 5]
 [1 1]] 

[[29  6]
 [ 5  1]]
</pre>


<p>
You can see these matrices shift leftwards in the tabular representation, with adjacent matrices sharing a column. Suppose that the current matrix is
\(\begin{bmatrix}
    p & q \\
    r & s
\end{bmatrix}\), and we have to update it with a new term \(a_n\) in the continued fraction. The updated matrix is
</p>
\begin{equation*}
    \begin{bmatrix}
        p & q \\
        r & s
    \end{bmatrix}
    \begin{bmatrix}
        a_n & 1 \\
        1 & 0
    \end{bmatrix} =
    \begin{bmatrix}
        a_n p + q & p \\
        a_n r + s & r
    \end{bmatrix}
\end{equation*}

<p>
This explains the shift, and we have recovered the formula in <code>cf_convergents0</code>.
</p>

<p>
Finally, we define a specialized version of <code>cf_convergents1</code> just for finite-term continued fractions. 
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf2r1</span>(cf: Iterator[<span class="org-builtin">int</span>]) -&gt; Rational:
    <span class="org-doc">"""</span>
<span class="org-doc">    Turn a continued fraction into a rational number.</span>

<span class="org-doc">    The continued fraction must have finite length.</span>
<span class="org-doc">    If not, this function will get into an infinite loop.</span>

<span class="org-doc">    :param cf: The continued fraction</span>
<span class="org-doc">    :return: A rational number</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">return</span> <span class="org-builtin">list</span>(cf_convergents1(cf))[-1]
</pre>
</div>
</div>
</div>

<div id="outline-container-org0dadee1" class="outline-2">
<h2 id="org0dadee1"><span class="section-number-2">5.</span> Turning convergents into continued fractions using the Euclidean algorithm</h2>
<div class="outline-text-2" id="text-5">
<p>
In this section, we'll calculate convergents as in <code>cf_convergent1</code>, but as it happens, we'll also turn them into continued fractions. This seems to be a pointless exercise, because a continued fraction is what we start with! Indeed, at the end of this section, we'll see that our code receives a continued fraction, and just returns the same series. However, in the next section, it will be used to do interesting things.
</p>

<p>
Let's take the continued fraction \([5, 1, 4... ]\) as an example. Since we already know from the <a href="#org2bfe2c9">last section</a> that the third convergent of \([5, 1, 4]\) is \(\frac{29}{5}\), can't we just turn \(\frac{29}{5}\) into a continued fraction, using the <code>r2cf</code> function that we have already written? It is not as simple as that, because \([5, 1, 4]\) and \([5, 1, 4...]\) are not the same. For the former, the third convergent is just a rational number. However, for the latter, the third convergent 
\(\begin{bmatrix}
    29 & 6 \\
     5 & 1
\end{bmatrix}\) represents the function \(\frac{29x + 6}{5x + 1}\). To turn it into a continued fraction, we'll need to take the rest of the series, represented by \(x\), into account.
</p>

<p>
How? The answer is still the Euclidean algorithm, but we have to use it symbolically rather than numerically.
</p>

<p>
The first step is to symbolically represent the function as a quotient and a remainder. I implemented this operation in <code>qr_matrix</code> in the <a href="#orgd51efa2">Appendix</a>. We can use it on the third convergent:
</p>
<div class="org-src-container">
<pre class="src src-python">
pp_qr(qr_matrix(np.array([[29, 6], [5, 1]])))
</pre>
</div>

<pre class="example">
5  5  1
   4  1
</pre>


<p>
This means that \(f_3(x) = \frac{29x+6}{5x+1} = 5 + \frac{1}{\frac{5x+1}{4x+1}}\). Why is the quotient 5? Since \(\lim_{x \to 0} f_3(x) = 6\) and \(\lim_{x \to \infty} f_3(x) = \frac{29}{5} = 5.8\), the function is bounded by \(5.8 < f_3(x) < 6\) (note that \(0 < x < \infty\)). The quotient therefore has to be 5.
</p>


<div id="org2acc7fe" class="figure">
<p><img src="../figs/fig1.png" alt="fig1.png" width="400" />
</p>
</div>

<p>
Now, we are ready to implement the symbolic form of the Euclidean algorithm by calling <code>qr_matrix</code> repeatedly:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">euclid_matrix_</span>(m: np.ndarray) -&gt; Iterator[Tuple[<span class="org-builtin">int</span>, np.ndarray]]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Symbolic Euclidean algorithm for a homographic function.</span>

<span class="org-doc">    :param m: The 2x2 matrix representing the function.</span>
<span class="org-doc">    :return: An iterator of the quotient and the remainder.</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-keyword">if</span> m[0][0] == 0 <span class="org-keyword">and</span> [0][1] == 0:
            <span class="org-comment-delimiter"># </span><span class="org-comment">if there is no remain, stop</span>
            <span class="org-keyword">break</span>
        <span class="org-keyword">else</span>:
            (q, r) = qr_matrix(m)
            <span class="org-keyword">if</span> q <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
                <span class="org-keyword">yield</span> q, r
                <span class="org-variable-name">m</span> = r
            <span class="org-keyword">else</span>:
                <span class="org-comment-delimiter"># </span><span class="org-comment">if the quotient cannot be determined, stop</span>
                <span class="org-keyword">break</span>
</pre>
</div>

<p>
Let's try it on
\(\begin{bmatrix}
    70 & 29 \\
    12 & 5
\end{bmatrix}\)
</p>

<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">q</span> = euclid_matrix_(np.array([[70, 29], [12, 5]]))
<span class="org-keyword">for</span> (r, m) <span class="org-keyword">in</span> q:
    pp_qr((r, m))
    <span class="org-keyword">print</span>()
</pre>
</div>

<pre class="example">
5 12  5
  10  4

1 10  4
   2  1

4  2  1
   2  0

</pre>


<p>
So there is enough information in \(\frac{70x+29}{12x+5}\) to precisely determine 3 terms (5, 1, 4). The last matrix represents \(\frac{2x+1}{2x}\), an unbounded function. This means that depending on the next term of the input, the function can evaluate to any value. We don't have enough information to determine the quotient, so we have to stop.
</p>

<p>
<a id="org5ceb018"></a>
As before, Gospher stacked the matrices in a compact format to illustrate the process:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(euclid_matrix_tab(np.array([[70, 29], [12, 5]])))
</pre>
</div>

<pre class="example">

70 29   
12  5  5
10  4  1
 2  1  4
 2  0   

</pre>


<p>
This is a just an extension of the format that we use to visualize <code>r2cf</code>: we start with \(\begin{bmatrix} 70 & 29 \\ 12 & 5\end{bmatrix}\), end with \(\begin{bmatrix}2 & 1 \\ 2 & 0\end{bmatrix}\), and output 5, 1, 4 in the process. 
</p>

<p>
Now, we can combine convergent calculation with the symbolic Euclidean algorithm. The first function below <code>cf_transform_</code> returns the desired information (the quotient) along with internal states of the algorithm. It's useful for debugging and visualization. We use a second function <code>cf_transform</code> to filter out the internal states:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_transform_</span>(cf: Iterator[<span class="org-builtin">int</span>], m0: np.ndarray = np.identity(2, <span class="org-builtin">int</span>), finite_term = <span class="org-constant">True</span>) -&gt; Iterator[Tuple[Optional[<span class="org-builtin">int</span>], Optional[np.ndarray], np.ndarray, <span class="org-builtin">int</span>, <span class="org-builtin">bool</span>]]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Transform a continued fraction.</span>

<span class="org-doc">    Exposes the internal states of the algorithm for visualization.</span>
<span class="org-doc">    A step can do: 1. Update the homographic matrix</span>
<span class="org-doc">                   2. Update, and an Euclidean step</span>
<span class="org-doc">                   3. Only an Euclidean step</span>

<span class="org-doc">    :param cf: The continued fraction.</span>
<span class="org-doc">    :param m0: The initial 2x2 matrix representing the transformatiom.</span>
<span class="org-doc">    :param finite-term: True, if cf is a continued fraction with finite terms.</span>
<span class="org-doc">                        False, if cf represents a truncated continued fraction.</span>
<span class="org-doc">    :return: q: The quotient. None if the Euclidean step cannot be performed.</span>
<span class="org-doc">             r: The remainder. None if the Euclidean step cannot be performed.</span>
<span class="org-doc">             m: The 2x2 matrix before the Euclidean step</span>
<span class="org-doc">             a: The term of the continued fraction that was used in this update</span>
<span class="org-doc">             new_a: Was a new a term used?</span>
<span class="org-doc">                    False if this step only did Euclidean</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">m</span> = m0
    <span class="org-keyword">for</span> a <span class="org-keyword">in</span> cf:
        <span class="org-variable-name">m</span> = np.matmul(m, h(a))
        <span class="org-variable-name">new_a</span> = <span class="org-constant">True</span>
        <span class="org-keyword">for</span> (q, r) <span class="org-keyword">in</span> euclid_matrix_(m):
            <span class="org-keyword">yield</span> q, r, m, a, new_a
            <span class="org-variable-name">new_a</span> = <span class="org-constant">False</span>
            <span class="org-variable-name">m</span> = r
        <span class="org-keyword">if</span> new_a:
            <span class="org-comment-delimiter"># </span><span class="org-comment">Nothing was yielded.</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">This convergent cannot be turned into a continued fraction</span>
            <span class="org-keyword">yield</span> (<span class="org-constant">None</span>, <span class="org-constant">None</span>, m, a, new_a)

    <span class="org-comment-delimiter"># </span><span class="org-comment">We will only reach this point if the series is finite</span>
    <span class="org-keyword">if</span> finite_term <span class="org-keyword">and</span> m[1][0] != 0:
        <span class="org-keyword">for</span> s <span class="org-keyword">in</span> r2cf(Rational(m[0][0], m[1][0])):
            <span class="org-keyword">yield</span> s, <span class="org-constant">None</span>, m, a, <span class="org-constant">False</span>

<span class="org-keyword">def</span> <span class="org-function-name">cf_transform</span>(cf: Iterator[<span class="org-builtin">int</span>], m0: np.ndarray = np.identity(2, <span class="org-builtin">int</span>), finite_term = <span class="org-constant">True</span>) -&gt; Iterator[<span class="org-builtin">int</span>]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Transform the input continued fraction into a new continued fraction.</span>

<span class="org-doc">    :param cf: The continued fraction.</span>
<span class="org-doc">    :param m0: The 2x2 matrix representing the transformation.</span>
<span class="org-doc">    :param finite_term: Is cf a finite-term fraction?</span>
<span class="org-doc">                        Set to false if cf is a finite truncation of</span>
<span class="org-doc">                        an infinite continued fractuon</span>
<span class="org-doc">    :return: A new continued fraction</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">for</span> res <span class="org-keyword">in</span> cf_transform_(cf, m0, finite_term):
        (q, r, m, a, new_a) = res
        <span class="org-keyword">if</span> q <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
            <span class="org-keyword">yield</span> q
        <span class="org-keyword">else</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">q can be None, indicating that more terms are needed</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">to continue. It can be ignored</span>
            <span class="org-keyword">pass</span>
</pre>
</div>

<p>
Run it on a continued fraction, and it just returns the same sequence. It doesn't seem to do any transformation. We'll see why the function is called <code>cf_transform</code> in the next section. 
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_transform(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3]))))
</pre>
</div>

<pre class="example">
[2, 1, 1, 5, 1, 3]
</pre>


<p>
This seems to be anti-climatic for quite a bit of work&#x2026; but here's something cool. Gospher combined the two stacked matrix representations that we have seen, to illustrate every step in the algorithm:
</p>

<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(cf_transform_tab(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3])))
</pre>
</div>

<pre class="example">
  3 1 5 1 1 2    
        3 2 1 0  
      2 1 1 0 1 2
    6 1 1 0     1
  6 5 1 0       1
4 1 1 0         5
3 1 0           1
1 0             3

</pre>


<p>
The numbers on the right are the outputs of <code>cf_transform</code>.
</p>
</div>
</div>

<div id="outline-container-orgf547574" class="outline-2">
<h2 id="orgf547574"><span class="section-number-2">6.</span> Simple transformations of continued fractions</h2>
<div class="outline-text-2" id="text-6">
<p>
The beauty of the matrix representation is that we can transform convergents with a function of the form \(f(x) = \frac{px+q}{rx+s}\). All we need is an additional matrix multiplication on the left side! This can be calculated by giving <code>cf_transform</code> an initial matrix.
</p>

<p>
<a id="orgaa68208"></a>
The continued fraction \([2, 1, 1, 5, 1]\) is \(\frac{33}{13}\). Let's double that, and turn it back to a continued fraction:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-keyword">print</span>(<span class="org-string">"[2, 1, 1, 5, 1] is "</span>, cf2r1(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1])))
<span class="org-keyword">print</span>(<span class="org-string">"The continued fraction of 66/13 is "</span>, <span class="org-builtin">list</span>(r2cf(Rational(66, 13))), <span class="org-string">"\n"</span>)
<span class="org-keyword">print</span>(r2cf_tab(Rational(66, 13)))
</pre>
</div>

<pre class="example">
[2, 1, 1, 5, 1] is  33/13
The continued fraction of 66/13 is  [5, 13] 

   66
   13   5   
    1   13  
    0

</pre>


<p>
According to the above, \(2 * [2, 1, 1, 5, 1]\) is \([5, 13]\). How do we end up with fewer terms? We can illustrate the process by running <code>cf_transform_tab</code> with the initial matrix \(\begin{bmatrix} 2 & 0 \\ 0 & 1 \end{bmatrix}\) (which stands for the function \(f(x) = 2x\)):
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">m0</span> = np.array([[2, 0], [0, 1]], <span class="org-builtin">int</span>)
<span class="org-variable-name">cf</span> = cf_transform(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1]), m0 = m0)
<span class="org-keyword">print</span>(<span class="org-string">" 2 * [2, 1, 1, 5, 1] is "</span>, <span class="org-builtin">list</span>(cf), <span class="org-string">"\n"</span>)
<span class="org-keyword">print</span>(cf_transform_tab(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1]), m0 = m0))
</pre>
</div>

<pre class="example">
2 * [2, 1, 1, 5, 1] is  [5, 13] 

    1  5  1  1  2      
      10  6  4  2  0   
13 11  2  1  1  0  1  5
 1  1  0  1          13

</pre>


<p>
Take one of the matrices in the tabulated display \(\begin{bmatrix} 6 & 4 \\ 1 & 1\end{bmatrix}\) for example. The range of \(\frac{6x+4}{x+1}\) is too wide (between 4 and 6) for the quotient to be determined. The algorithm therefore needs another term of the continued fraction. The matrix shifts leftwards without outputting a quotient. That's why the transformed continued fraction has a smaller number of terms. 
</p>

<p>
Previously, we saw that the reciprocal of a continued fraction has an addition 0 in the beginning. Let's verify that with the initial matrix \(\begin{bmatrix} 0 & 1 \\ 1 & 0 \end{bmatrix}\) (which stands for the function \(f(x) = \frac{1}{x}\)): 
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">m0</span> = np.array([[0, 1], [1, 0]], <span class="org-builtin">int</span>)
<span class="org-variable-name">cf</span> = cf_transform(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1]), m0 = m0)
<span class="org-keyword">print</span>(<span class="org-string">"The reciprocal of [2, 1, 1, 5, 1] is "</span>, <span class="org-builtin">list</span>(cf), <span class="org-string">"\n"</span>)
<span class="org-keyword">print</span>(cf_transform_tab(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1]), m0 = m0))
</pre>
</div>

<pre class="example" id="org24b5d6a">
The reciprocal of [2, 1, 1, 5, 1] is  [0, 2, 1, 1, 5, 1] 

   1 5 1 1 2    
         1 0 1  
       3 2 1 0 0
     2 1 1 0   2
   6 1 1 0     1
 6 5 1 0       1
 1 1 0         5
 1 0           1

</pre>

<p>
Another example: what is \(\frac{2}{3-\sqrt{2}}\) as a continued fraction? First, \(\sqrt{2} = [1, 2, 2, 2...]\), so we should define an infinite generator:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_sqrt2</span>():
    <span class="org-doc">"""A generator representing sqrt(2) as a continued fraction"""</span>
    <span class="org-keyword">yield</span> 1
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-keyword">yield</span> 2
</pre>
</div>

<p>
Then, we just need to run <code>cf_transform</code> with \(\begin{bmatrix} 0 & 2 \\ -1 & 3 \end{bmatrix}\) (which stands for \(\frac{2}{-x + 3}\)):
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">m0</span> = np.array([[0, 2], [-1, 3]], <span class="org-builtin">int</span>)
<span class="org-variable-name">cf</span> = islice(cf_transform(cf_sqrt2(), m0 = m0), 6)
<span class="org-keyword">print</span>(<span class="org-string">" 2 / (3 - sqrt(2)) is "</span>, pp_inf_cf(<span class="org-builtin">list</span>(cf)), <span class="org-string">"\n"</span>)
<span class="org-keyword">print</span>(cf_transform_tab(islice(cf_sqrt2(), 6), m0 = m0))
</pre>
</div>

<pre class="example" id="orga5dc449">
2 / (3 - sqrt(2)) is  [1,3,1,4,1,4...] 

    2  2  2  2  2  1      
             4  2  0  2   
          8  3  2 -1  3  1
       5  2  1  0        3
   10  4  2  0           1
 5  2  1  0              4
 4  2  0                 1
 1  0                    4

</pre>
<p>
The answer is a periodic continued fraction \([1, 3, 1, 4, 1, 4...]\).
</p>

<p>
Another example: what is \(\tanh{\frac{1}{2}} = \frac{e-1}{e+1}\)? We have already defined the continued fraction for \(e\), so it's just a matter of choosing the right initial matrix (\(\begin{bmatrix} 1 & -1 \\ 1 & 1 \end{bmatrix}\), representing \(\frac{x-1}{x+1}\)):
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">m0</span> = np.array([[1, -1], [1, 1]], <span class="org-builtin">int</span>)
<span class="org-variable-name">cf</span> = islice(cf_transform(cf_e(), m0 = m0), 6)
<span class="org-keyword">print</span>(<span class="org-string">"(e-1)/(e+1) is "</span>, pp_inf_cf(<span class="org-builtin">list</span>(cf)), <span class="org-string">"\n"</span>)
<span class="org-keyword">print</span>(cf_transform_tab(islice(cf_e(), 12), m0 = m0))
</pre>
</div>

<pre class="example" id="org62f37c1">
(e-1)/(e+1) is  [0,2,6,10,14,18...] 

     8  1  1  6  1  1  4  1  1  2  1  2      
                                   1  1 -1   
                                4  3  1  1  0
                      12  7  5  2  1  1     2
             20 11  9  2  1  1  0  1        6
    28 15 13  2  1  1  0  1                10
 17  2  1  1  0  1                         14
  1  0  1                                  17

</pre>
<p>
The answer is a continued fraction with a simple pattern: after the second term, add 4 to the previous term.
</p>

<p>
I find the tabulated displays visually appealing, so I wrote some external codes (in <i>Mathematica</i>) to give them some colors. The colors make it easier to see the patterns in the numbers.
</p>

<div id="orgae24b3e" class="figure">
<p><img src="../figs/cf_transform_summary.png" alt="cf_transform_summary.png" width="600" />
</p>
</div>

<p>
Before we proceed further, there is a small but important point that should be clarified. In the last example, we transformed \(e\) to calculate \(\frac{e-1}{e+1}\). It was done by truncating \(e\)'s infinite number of terms, retaining only the first 6 terms. This might give the impression that <code>cf_transform</code> is for approximating \(\frac{e-1}{e+1}\). That is not the case. The entire point of Gospher's work is to show that <i>exact</i> continued fraction arithmetic is possible. If this is not clear to you, let's define a different interface to <code>cf_transform_</code>, to make the point more obvious.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_transform_func</span>(cf: Iterator[<span class="org-builtin">int</span>], m0: np.ndarray) -&gt; Tuple[List[<span class="org-builtin">int</span>], np.ndarray]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Transform a continued continuation with finite number of terms.</span>

<span class="org-doc">    Returns a list (representing the transformed fraction) and the</span>
<span class="org-doc">    last homographic function so that it can be used on more terms.</span>

<span class="org-doc">    If cf is infinite, this function won't terminate.</span>

<span class="org-doc">    :param cf: The input continuned fraction.</span>
<span class="org-doc">    :param m0: A 2x2 matrix representing the transformation</span>
<span class="org-doc">    :return: A list representing the transformed fraction, and</span>
<span class="org-doc">             a 2x2 matrix representing the homographic function</span>
<span class="org-doc">    """</span>
    outputs: <span class="org-variable-name">List</span>[<span class="org-builtin">int</span>] = []
    out_m: <span class="org-variable-name">Optional</span>[np.ndarray] = <span class="org-constant">None</span>
    <span class="org-keyword">for</span> res <span class="org-keyword">in</span> cf_transform_(cf, m0, finite_term = <span class="org-constant">False</span>):
        (q, r, m, a, new_a) = res
        <span class="org-keyword">if</span> q <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
            <span class="org-variable-name">outputs</span> = outputs + [q]
            <span class="org-variable-name">out_m</span> = r
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">out_m</span> = m
    <span class="org-keyword">assert</span> <span class="org-builtin">isinstance</span>(out_m, np.ndarray)
    <span class="org-keyword">return</span> outputs, out_m
</pre>
</div>

<p>
I call this function <code>cf_transform_func</code>, to emphasize that the output is a list integers, <i>and</i> a function represented by a matrix. The list of integers is an approximation, but together with the function, we have the exact solution to the computation. Why is it exact? Because if we have more terms of \(e\), we can send it to the function to get more output terms. This is a recursive process that can continue forever.
</p>

<p>
The example below, we call <code>cf_transform_func</code> with the first 6 terms of \(e\). We get 3 terms (0, 2, 6), and the function \(f(x) = \frac{9x + 2}{x}\), represented by the matrix. We can get 6 more terms of \(e\), and call <code>cf_transform_func</code> again with the matrix to continue the process.
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">m0</span> = np.array([[1, -1], [1, 1]], <span class="org-builtin">int</span>)
<span class="org-variable-name">cf</span> = cf_e()
<span class="org-variable-name">cf6</span> = islice(cf, 6)
(outs, m) = cf_transform_func(cf6, m0 = m0)
<span class="org-keyword">print</span>(<span class="org-string">"Using the first 6 terms of e, (e-1)/(e+1) is "</span>, outs)
<span class="org-keyword">print</span>(<span class="org-string">"The homomorphic function is:\n "</span>, m)
<span class="org-comment-delimiter"># </span><span class="org-comment">take 6 more terms from e</span>
<span class="org-variable-name">cf6</span> = islice(cf, 6)
<span class="org-comment-delimiter"># </span><span class="org-comment">we can continue our calculations to get more terms</span>
(outs, m) = cf_transform_func(cf6, m0 = m)
<span class="org-keyword">print</span>(<span class="org-string">"With 6 more terms of e, we get "</span>, outs)
</pre>
</div>

<pre class="example">
Using the first 6 terms of e, (e-1)/(e+1) is  [0, 2, 6]
The homomorphic function is:
  [[9 2]
 [1 0]]
With 6 more terms of e, we get  [10, 14]
</pre>
</div>
</div>

<div id="outline-container-org10cc324" class="outline-2">
<h2 id="org10cc324"><span class="section-number-2">7.</span> Arithmetic (Step 1): From matrices to tensors</h2>
<div class="outline-text-2" id="text-7">
<p>
We have been dealing with one continued fraction at a time. In those situations, all operations involve functions of the form \(f(x) = \frac{px+q}{rx+s}\). They are known as <i>homographic functions</i>, and they can be represented by the matrix \(\begin{bmatrix} p & q \\ r & s \end{bmatrix}\). How do we generalize it to operations involving two continued fractions?
</p>

<p>
The problem is solved with <i>bihomographic functions</i> of the form \(f(x, y) = \frac{axy + bx + cy + d}{exy + fx + gy + h}\), where \(x\) and \(y\) are the unknown terms for the two continued fractions \(a\) and \(b\) respectively. We can write it in matrix form as:
</p>

\begin{equation*}
f(x, y) = \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} b & d \\ a & c \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} \bigg/
          \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} f & h \\ e & g \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix}
\end{equation*}


<p>
Since we are working with two matrices as a single entity, it's natural to use tensors to represent bihomographic functions:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Tensor representations of bihomographic functions</span>

<span class="org-keyword">def</span> <span class="org-function-name">tFrom2x4</span>(m: np.ndarray) -&gt; np.ndarray:
    <span class="org-doc">"""</span>
<span class="org-doc">    Translate a bihomographic function from algebraic to tensor form.</span>

<span class="org-doc">    :param m: A 2x4 matrix representing the function</span>
<span class="org-doc">    :return: A 2x2x2 tensor</span>
<span class="org-doc">    """</span>
    ((a, b, c, d), (e, f, g, h)) = m.tolist()
    <span class="org-keyword">return</span> np.array([[[b, d], [a, c]], [[f, h], [e, g]]])

<span class="org-keyword">def</span> <span class="org-function-name">tTo2x4</span>(m: np.ndarray) -&gt; np.ndarray:
    <span class="org-doc">"""</span>
<span class="org-doc">    Translate a bihomographic function from tensor to algebraic form.</span>

<span class="org-doc">    :param m: A 2x2x2 tensor</span>
<span class="org-doc">    :return: A 2x4 matrix</span>
<span class="org-doc">    """</span>

    (((b, d), (a, c)), ((f, h), (e, g))) = m.tolist()
    <span class="org-keyword">return</span> np.array([[a, b, c, d], [e, f, g, h]])
</pre>
</div>

<p>
I need a utility function to make it easy to access so many numbers in the tensors:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">tensor_ref</span>(t: np.ndarray, label: <span class="org-builtin">str</span>) -&gt; Union[<span class="org-builtin">int</span>, Tuple[<span class="org-builtin">int</span>, <span class="org-builtin">int</span>]]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Easy accessing elements of a tensor</span>

<span class="org-doc">    :param t: A 2x2x2 tensor</span>
<span class="org-doc">    :param label: a-h refers to a number in the tensor</span>
<span class="org-doc">                  xy, x, y, 1 refers to numerator/denominator pairs</span>
<span class="org-doc">    :return: A number, or a pair of numbers</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">assert</span> t.shape == (2, 2, 2)
    <span class="org-keyword">assert</span> label <span class="org-keyword">in</span> [<span class="org-string">'a'</span>, <span class="org-string">'b'</span>, <span class="org-string">'c'</span>, <span class="org-string">'d'</span>, <span class="org-string">'e'</span>, <span class="org-string">'f'</span>, <span class="org-string">'g'</span>, <span class="org-string">'h'</span>, <span class="org-string">'xy'</span>, <span class="org-string">'x'</span>, <span class="org-string">'y'</span>, <span class="org-string">'1'</span>]
    <span class="org-variable-name">lookup</span> = {}
    <span class="org-variable-name">lookup</span>[<span class="org-string">'a'</span>]  = t[0,1,0]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'b'</span>]  = t[0,0,0]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'c'</span>]  = t[0,1,1]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'d'</span>]  = t[0,0,1]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'e'</span>]  = t[1,1,0]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'f'</span>]  = t[1,0,0]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'g'</span>]  = t[1,1,1]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'h'</span>]  = t[1,0,1]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'xy'</span>] = lookup[<span class="org-string">'a'</span>], lookup[<span class="org-string">'e'</span>]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'x'</span>]  = lookup[<span class="org-string">'b'</span>], lookup[<span class="org-string">'f'</span>]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'y'</span>]  = lookup[<span class="org-string">'c'</span>], lookup[<span class="org-string">'g'</span>]
    <span class="org-variable-name">lookup</span>[<span class="org-string">'1'</span>]  = lookup[<span class="org-string">'d'</span>], lookup[<span class="org-string">'h'</span>]
    <span class="org-keyword">return</span> lookup[label]
</pre>
</div>

<p>
What happens to \(f(x, y)\), with the addition of a new term \(a_n\) of \(a\)?
</p>

\begin{equation*}
f(a_n + \frac{1}{x}, y) = \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} a_n b  + d & b \\ a_n a + c & a \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} \bigg /
                          \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} a_n f  + h & f \\ a_n e + g & e \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} 
\end{equation*}

<p>
This is familiar, isn't it? It's exactly the same update rule that we use for updating the convergents! All we need to do is to right-multiply \(\begin{bmatrix} a_n & 1 \\ 1 & 0\end{bmatrix}\) the two matrices.
</p>

<p>
We can do the same with a new term \(b_n\) for \(b\):
</p>

\begin{equation*}
f(x, b_n + \frac{1}{y}) = \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} a & c \\ b_n a + b & b_n c + d \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} \bigg /
                          \begin{bmatrix} 1 & y \end{bmatrix} \begin{bmatrix} e & g \\ b_n e + f & b_n g + h \end{bmatrix} \begin{bmatrix} x \\ 1 \end{bmatrix} 
\end{equation*}

<p>
This is basically the same thing, except that the direction is different. This corresponds to left-multiplying \(\begin{bmatrix} 0 & 1 \\ 1 & b_n\end{bmatrix}\).
</p>

<p>
The above suggests an elegant way to visualize continued fraction arithmetic: if we imagine that two matrices form a 2x2x2 cube, this cube moves leftwards upon receiving a new term of \(a\), and it moves downwards upon receiving a new term of \(b\). As before, we'll also use the Euclidean algorithm to convert the bihomographic function into continued fractions. When we get to perform the Euclidean step, the 2x2x2 cube moves in the third dimension. The following figure illustrates that continued fraction arithmetic is a direct generalization of the 2D case:
</p>


<div id="orgfcd66b1" class="figure">
<p><img src="../figs/cf_space.png" alt="cf_space.png" width="500px" />
</p>
</div>

<p>
To implement the cube movements in Python, I use my favorite Numpy function: <code>einsum</code> (Einstein's sum; see <a href="https://ajcr.net/Basic-guide-to-einsum/">this tutorial</a>). If the very compact notation (invented by Einstein) seems cryptic, don't worry. It's just repeated matrix multiplication.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">apply_a</span>(t: np.ndarray, a: <span class="org-builtin">int</span>) -&gt; np.ndarray:
    <span class="org-doc">'''Move tensor t to the left by taking a new term of a'''</span>
    <span class="org-variable-name">ha</span> = h(a)
    <span class="org-keyword">return</span> np.einsum(<span class="org-string">'dyx,xz-&gt;dyz'</span>, t, ha)

<span class="org-keyword">def</span> <span class="org-function-name">h_rotated</span>(b: <span class="org-builtin">int</span>) -&gt; np.ndarray:
    <span class="org-doc">'''A rotated version of the 2x2 homgraphic matrix'''</span>
    <span class="org-keyword">return</span> np.array([[0, 1], [1, b]])

<span class="org-keyword">def</span> <span class="org-function-name">apply_b</span>(t: np.ndarray, b: <span class="org-builtin">int</span>) -&gt; np.ndarray:
    <span class="org-doc">'''Move tensor t downwards by taking a new term of b'''</span>
    <span class="org-variable-name">hb</span> = h_rotated(b)
    <span class="org-keyword">return</span> np.einsum(<span class="org-string">'zy,dyx-&gt;dzx'</span>, hb, t)

<span class="org-keyword">def</span> <span class="org-function-name">apply_ab</span>(t: np.ndarray, term: <span class="org-builtin">int</span>, label: <span class="org-builtin">str</span>) -&gt; np.ndarray:
    <span class="org-doc">"""</span>
<span class="org-doc">    Apply a new term to the bihomographic tensor</span>

<span class="org-doc">    :param t: The tensor</span>
<span class="org-doc">    :param term: The new term to be applied to the tensor</span>
<span class="org-doc">    :param label: Is the term from continued fraction a or b?</span>
<span class="org-doc">    :return: A new 2x2x2 tensor</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">assert</span> label <span class="org-keyword">in</span> [<span class="org-string">'a'</span>, <span class="org-string">'b'</span>]
    <span class="org-keyword">if</span> label == <span class="org-string">'a'</span>:
        <span class="org-keyword">return</span> apply_a(t, term)
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> apply_b(t, term)
</pre>
</div>
</div>
</div>
<div id="outline-container-orgb6ca73c" class="outline-2">
<h2 id="orgb6ca73c"><span class="section-number-2">8.</span> Arithmetic (Step 2):  Representing arithmetic operations</h2>
<div class="outline-text-2" id="text-8">
<p>
Something is curious about the discussion so far. We have a generic method for ingesting terms of two continued fractions, but how do we actually perform a specific operation on them? It's not hard to see that it all depends on the initial matrices. With appropriately chosen initial matrices, we can do multiplication, addition, division, subtraction, and their combinations. I think it's quite a remarkable result, because when we are dealing with numbers with multiple terms, multiplication is usually harder than addition. With continued fraction, the computational steps are exactly the same!
</p>

<p>
I made the following two figures to explain how addition and multiplication are done. Here's \(a+b\). We begin with just the initial matrices (first row), add the first term of \(a\), and then add the first term of \(b\). 
</p>

<div id="orgd2337ca" class="figure">
<p><img src="../figs/addition.png" alt="addition.png" width="500px" />
</p>
</div>

<p>
Here's the same process for multiplication:
</p>

<div id="orgdcba512" class="figure">
<p><img src="../figs/multiplication.png" alt="multiplication.png" width="500px" />
</p>
</div>

<p>
These are the initial tensors for the four basic operations:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Initial tensors for basic arithemtic operations</span>

<span class="org-variable-name">tForAddition</span> = np.array([[[1, 0], [0, 1]], [[0, 1], [0, 0]]])
<span class="org-variable-name">tForSubtraction</span> = np.array([[[1, 0], [0, -1]], [[0, 1], [0, 0]]])
<span class="org-variable-name">tForMultiplication</span> = np.array([[[0, 0], [1, 0]], [[0, 1], [0, 0]]])
<span class="org-variable-name">tForDivision</span> = np.array([[[1, 0], [0, 0]], [[0, 0], [0, 1]]])
</pre>
</div>

<p>
To make sure that the addition matrix works:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">t</span> = tForAddition
<span class="org-variable-name">t</span> = apply_ab(t, 2, <span class="org-string">'a'</span>)
<span class="org-variable-name">t</span> = apply_ab(t, 3, <span class="org-string">'b'</span>)
<span class="org-variable-name">t</span> = apply_ab(t, 4, <span class="org-string">'a'</span>)
<span class="org-variable-name">t</span> = apply_ab(t, 5, <span class="org-string">'b'</span>)
<span class="org-keyword">print</span>(tTo2x4(t))
</pre>
</div>

<pre class="example">
[[109  21  26   5]
 [ 20   4   5   1]]
</pre>


<p>
\(\begin{bmatrix} 109 & 21 & 26 & 5 \\ 20 & 4 & 5 & 1 \end{bmatrix}\) means \(\frac{109xy + 21x + 26y + 5}{20xy + 4x + 5y + 1}\), which equals \((2+\frac{1}{4+\frac{1}{x}}) + (3+\frac{1}{5+\frac{1}{y}})\). That's correct.
</p>

<p>
Let's try multiplication:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">t</span> = tForMultiplication
<span class="org-variable-name">t</span> = apply_ab(t, 2, <span class="org-string">'a'</span>)
<span class="org-variable-name">t</span> = apply_ab(t, 3, <span class="org-string">'b'</span>)
<span class="org-variable-name">t</span> = apply_ab(t, 4, <span class="org-string">'a'</span>)
<span class="org-keyword">print</span>(tTo2x4(t))
</pre>
</div>

<pre class="example">
[[27  9  6  2]
 [ 4  0  1  0]]
</pre>


<p>
\(\frac{27xy+9x+6y+2}{4xy+y} = (2 + \frac{1}{4+\frac{1}{x}}) \cdot (3+\frac{1}{y})\). That's also correct.
</p>
</div>
</div>

<div id="outline-container-org4f6958d" class="outline-2">
<h2 id="org4f6958d"><span class="section-number-2">9.</span> Arithmetic (Step 3): Calculating convergents using tensors</h2>
<div class="outline-text-2" id="text-9">
<p>
By updating the bihomographic function with new terms of \(a\) and \(b\), we can generate a series of rational numbers that converges to the result. The following code does this by applying a new term of \(a\), and then a new term of \(b\)&#x2026; and so on. This is not the only way to update the tensors. Any process that applies the terms in sequence will work. You can, for example, update with two terms of \(a\), and then two terms of \(b\).
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Continued fraction arithmethic - convergents</span>

<span class="org-keyword">def</span> <span class="org-function-name">arithmetic_convergents_</span>(a: Iterator[<span class="org-builtin">int</span>], b: Iterator[<span class="org-builtin">int</span>], t0 = tForAddition) -&gt; Iterator[Tuple[<span class="org-builtin">str</span>, <span class="org-builtin">int</span>, np.ndarray]]:
    <span class="org-doc">"""</span>
<span class="org-doc">    The convergents of doing arithemtic on two continued fractions.</span>

<span class="org-doc">    This version exposes the internal steps for visualization and debugging.</span>
<span class="org-doc">    New terms of the two continued fractions are applied alternately</span>

<span class="org-doc">    :param a: The first continued fraction.</span>
<span class="org-doc">    :param b: The second continued fraction.</span>
<span class="org-doc">    :param t0: The 2x2x2 tensor representing the operation.</span>
<span class="org-doc">    :return: The source (a or b?), the term, and the result (a 2x2x2 tensor)</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">res</span> = t0.copy()
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-variable-name">an</span> = <span class="org-builtin">next</span>(a, <span class="org-constant">None</span>)
        <span class="org-variable-name">bn</span> = <span class="org-builtin">next</span>(b, <span class="org-constant">None</span>)

        <span class="org-keyword">if</span> an <span class="org-keyword">is</span> <span class="org-constant">None</span> <span class="org-keyword">and</span> bn <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-keyword">break</span>

        <span class="org-keyword">if</span> an <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
            <span class="org-variable-name">res</span> = apply_ab(res, an, <span class="org-string">'a'</span>)
            <span class="org-keyword">yield</span> <span class="org-string">'a'</span>, an, res
        <span class="org-keyword">if</span> bn <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
            <span class="org-variable-name">res</span> = apply_ab(res, bn, <span class="org-string">'b'</span>)
            <span class="org-keyword">yield</span> <span class="org-string">'b'</span>, bn, res

<span class="org-keyword">def</span> <span class="org-function-name">arithmetic_convergents</span>(a: Iterator[<span class="org-builtin">int</span>], b: Iterator[<span class="org-builtin">int</span>], t0 = tForAddition) -&gt; Iterator[Rational]:
    <span class="org-doc">"""</span>
<span class="org-doc">    The convergents of doing arithmetic on two continued fraction.</span>

<span class="org-doc">    This version returns an iteartor of rational numbers.</span>
<span class="org-doc">    :param a: The first continued fraction.</span>
<span class="org-doc">    :param b: The second continued fraction.</span>
<span class="org-doc">    :param t0: The 2x2x2 tensor representing the operation.</span>
<span class="org-doc">    :return: An iterator of rational numbers</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">c</span> = arithmetic_convergents_(a, b, t0)
    <span class="org-keyword">for</span> _, _, res <span class="org-keyword">in</span> c:
        <span class="org-variable-name">r</span> = tensor_ref(res, <span class="org-string">'xy'</span>)
        <span class="org-keyword">assert</span> <span class="org-builtin">isinstance</span>(r, <span class="org-builtin">tuple</span>)
        <span class="org-keyword">yield</span> Rational(r[0], r[1])
</pre>
</div>

<p>
We have calculated <a href="#orgaa68208">previously</a> that \(2*[2, 1, 1, 5, 1] = \frac{66}{13}\). Let's verify it by adding the continued fraction to itself:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-variable-name">b</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(arithmetic_convergents(a, b, tForAddition)))
</pre>
</div>

<pre class="example">
[1/0, 4/1, 5/1, 6/1, 11/2, 20/4, 111/22, 616/121, 727/143, 858/169]
</pre>


<p>
Yup. \(\frac{858}{169}\) equals to \(\frac{66}{13}\).
</p>

<p>
Let's try subtraction. Observe that \([2, 1, 1, 5, 1] - [2, 1, 1, 5, 1]\) does become 0 (that is \(\frac{0}{169}\)):
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-variable-name">b</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(arithmetic_convergents(a, b, tForSubtraction)), <span class="org-string">"\n"</span>)
</pre>
</div>

<pre class="example">
[-1/0, 0/1, 1/1, 0/1, -1/2, 0/4, 1/22, 0/121, -1/143, 0/169] 

</pre>


<p>
Note that the numerator oscillates between -1, 0, and 1, while the denominator gets larger and larger.
</p>

<p>
How about division? Yup. \(\frac{429}{429}=1\).
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-variable-name">b</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(arithmetic_convergents(a, b, tForDivision)), <span class="org-string">"\n"</span>)
</pre>
</div>

<pre class="example">
[0/1, 2/2, 3/2, 3/3, 5/6, 10/10, 56/55, 308/308, 363/364, 429/429] 

</pre>


<p>
Finally, let's try \(\sqrt{2}*\sqrt{2}\). With infinite number of terms, the answer should be 2. With finite number of terms, however, we get an approximation of 2 (\(\frac{9801}{4900}=2.0002\)).
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = islice(cf_sqrt2(), 6)
<span class="org-variable-name">b</span> = islice(cf_sqrt2(), 6)  
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(arithmetic_convergents(a, b, tForMultiplication)), <span class="org-string">"\n"</span>)
</pre>
</div>

<pre class="example">
[1/0, 1/1, 3/2, 9/4, 21/10, 49/25, 119/60, 289/144, 697/348, 1681/841, 4059/2030, 9801/4900] 

</pre>


<p>
Now we've come to visualization. Again, Gospher developed an ingenious method for visualizing the computational process, representing 2x2x2 tensors with a pseudo-3D effect. I decided not to implement his method because I find it hard to read. Instead, I will display the numerator and the denominator matrices separately. This format is not as compact as Gospher's method, but it works better when the numbers get large. In the figure below, the upper "band" is the evolution of the numerator matrix, and the lower band does the same for the denominator matrix. Note that for a 2x2 matrix in either band, you should read off the number in the lower-left corner, because \(\lim_{\substack{x\to \infty \\ y\to \infty}} \frac{axy + bx + cy + d}{exy + fx + gy + h} = \frac{a}{e}\).
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-variable-name">b</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])  
<span class="org-keyword">print</span>(arithmetic_convergents_tab(a, b, tForAddition))  
</pre>
</div>

<pre class="example" id="org29ad3bc">
      1   5   1   1   2        
                  2   1   0    
              1   1   0   1   2
          9   5   4   1       1
     61  11   6   5           1
131 111  20  11               5
727 616 111                   1
858 727                        
                  1   0   1    
              0   0   0   0    
          2   1   1   0        
     11   2   1   1            
 26  22   4   2                
143 121  22                    
169 143                        

</pre>
<p>
The result \(\frac{858}{168}\) comes from the numbers at the lower-left corners of the two bands. Note that the row on top and the column on the right represent the two continued fractions.
</p>

<p>
Finally, some colors:
</p>

<div id="orgae9c1eb" class="figure">
<p><img src="../figs/arithmetic_convergents.png" alt="arithmetic_convergents.png" width="600px" />
</p>
</div>

<p>
Unfortunately, I think these displays are not very satisfying, because the numbers tend to grow monotonically. That's because we haven't performed any Euclidean step. That's for the next section.
</p>
</div>
</div>

<div id="outline-container-org1d9f204" class="outline-2">
<h2 id="org1d9f204"><span class="section-number-2">10.</span> Arithmetic (Step 4): Applying the Euclidean algorithm to convergents</h2>
<div class="outline-text-2" id="text-10">
<p>
Since our tensors are just representations of bihomographic functions, it's straightforward to apply the Euclidean algorithm symbolically on them. <code>euclid_tensor_</code> is almost identical to <code>euclid_matrix_</code> in code structure:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Continued fraction arithmetic - full version with Euclidean steps</span>

<span class="org-keyword">def</span> <span class="org-function-name">euclid_tensor_</span>(t: np.ndarray) -&gt; Iterator[Tuple[<span class="org-builtin">int</span>, np.ndarray]]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Symbolic Euclidean step for tensor t</span>

<span class="org-doc">    :param t: The 2x2x2 tensor</span>
<span class="org-doc">    :return: An iterator of quotient (an int) and remainder (a tensor)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-keyword">if</span> np.<span class="org-builtin">all</span>(t[0]==0):
            <span class="org-comment-delimiter"># </span><span class="org-comment">if the numerator is all zero, stop</span>
            <span class="org-keyword">break</span>
        <span class="org-keyword">else</span>:
            (q, r) = qr_tensor(t)
            <span class="org-keyword">if</span> q <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
                <span class="org-keyword">yield</span> q, r
                <span class="org-variable-name">t</span> = r
            <span class="org-keyword">else</span>:
                <span class="org-keyword">break</span>
</pre>
</div>

<p>
In the following example, we manage to extract three terms from the bihomographic function \(f(x, y) = \frac{3466xy + 1150x + 483y + 216}{1318xy + 601x + 182y + 83}\):
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">t</span> = np.array([[[1550, 216], [3466, 483]], [[601, 83], [1318, 182]]])          
<span class="org-variable-name">res</span> = euclid_tensor_(t)
<span class="org-keyword">for</span> (q, r) <span class="org-keyword">in</span> res:
    <span class="org-keyword">print</span>(q)
</pre>
</div>

<pre class="example">
2
1
1
</pre>



<p>
A tabulated format can be used to visualize the process. It is a generalization of the format that we used to visualize the symbolic Euclidean algorithm (see <a href="#org5ceb018">here</a>), except that we are now flipping entire matrices instead of rows.
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">t</span> = np.array([[[1550, 216], [3466, 483]], [[601, 83], [1318, 182]]])          
<span class="org-variable-name">c</span> = euclid_tensor_tab(t)
<span class="org-keyword">print</span>(c)
</pre>
</div>

<pre class="example" id="orgd3151df">
1550  216     
3466  483     
 601   83    2
1318  182     
 348   50    1
 830  119     
 253   33    1
 488   63     
  95   17     
 342   56     

</pre>
<p>
The algorithm stops after 3 steps, because the bihomographic function associated with the remainder of the last step \(f(x, y) = \frac{488xy+253x+63y+33}{342xy+95x+56y+17}\) is bounded by \(\frac{63}{56}=1.125\) and \(\frac{253}{95}=2.66316\). The range is too wide to determine a quotient.
</p>


<div id="orgdcf4edd" class="figure">
<p><img src="../figs/fig2.png" alt="fig2.png" width="400" />
</p>
</div>

<p>
Now it's time to combine the Euclidean algorithm (<code>euclid_tensor_</code>) with convergent calculation (<code>arithmetic_convergents_</code>). The code structure is basically the same as <code>cf_transform_</code>, except that there is one additional issue to consider: when we work with just one continued fraction, if the Euclidean step fails to determine a quotient, the only thing that we can do is to ingest one more term from the continued fraction. But now we have two continued fractions, so we have to decide which one to use. In terms of the 3D space, the question becomes: should we move the cube left or down? The decision is more or less arbitrary, because the Euclidean step will eventually sort out the result, as long as the terms from the two continued fractions are ingested sequentially. However, for visualization, we want to perform the Euclidean step as soon as possible, to prevent the numbers in the tensor from becoming too big. I use some heuristics from Gospher's paper to make this decision. The implementation (<code>ABQueue</code>) is in the <a href="#orgdcc76fb">Appendix</a>.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_arithmetic_</span>(cf_a: Iterator[<span class="org-builtin">int</span>], cf_b: Iterator[<span class="org-builtin">int</span>], t0: np.ndarray, finite_term = <span class="org-constant">True</span>) -&gt; Iterator:
    <span class="org-doc">"""</span>
<span class="org-doc">    Perform arithmetic operation on two continued fraction.</span>

<span class="org-doc">    :param cf_a: The first continued fraction.</span>
<span class="org-doc">    :param cf_b: The second continued fraction.</span>
<span class="org-doc">    :param t0: The 2x2x2 tensor representing the opertion.</span>
<span class="org-doc">    :param finite_term: Is this a finite-length continued fraction,</span>
<span class="org-doc">                        or a truncation of an infinite one?</span>
<span class="org-doc">    :return: q - quotient (None if no Euclidean step performed)</span>
<span class="org-doc">             r - remainder (2x2x2 tensor)</span>
<span class="org-doc">             t - the tensor before the Euclidean step</span>
<span class="org-doc">             term - the term used in the update</span>
<span class="org-doc">             label - where does the term come from? cf_a or cf_b?</span>
<span class="org-doc">             new_term - was a new term (either from cf_a or cf_b) used?</span>
<span class="org-doc">                        It's false if only an Euclidean step was performed.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">t</span> = t0
    <span class="org-variable-name">next_ab</span> = ABQueue(cf_a, cf_b)

    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-variable-name">term</span>, <span class="org-variable-name">label</span> = next_ab(t)
        <span class="org-keyword">if</span> term <span class="org-keyword">is</span> <span class="org-constant">None</span> <span class="org-keyword">and</span> label <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">cf_a and cf_b are exhausted</span>
            <span class="org-keyword">break</span>
        <span class="org-keyword">else</span>:
            <span class="org-keyword">assert</span> <span class="org-builtin">isinstance</span>(term, <span class="org-builtin">int</span>)
            <span class="org-keyword">assert</span> <span class="org-builtin">isinstance</span>(label, <span class="org-builtin">str</span>)
            <span class="org-variable-name">t</span> = apply_ab(t, term, label)
            <span class="org-variable-name">new_term</span> = <span class="org-constant">True</span>
            <span class="org-keyword">for</span> (q, r) <span class="org-keyword">in</span> euclid_tensor_(t):
                <span class="org-keyword">yield</span> q, r, t, term, label, new_term
                <span class="org-variable-name">t</span> = r
                <span class="org-variable-name">new_term</span> = <span class="org-constant">False</span>
            <span class="org-keyword">if</span> new_term:
                <span class="org-comment-delimiter"># </span><span class="org-comment">Nothing was yielded.</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">This means that an Euclidean step was not performed</span>
                <span class="org-keyword">yield</span> <span class="org-constant">None</span>, <span class="org-constant">None</span>, t, term, label, new_term

    <span class="org-comment-delimiter"># </span><span class="org-comment">we will only reach this point if cf_a and cf_b have finite terms</span>
    <span class="org-keyword">if</span> finite_term <span class="org-keyword">and</span> tensor_ref(t, <span class="org-string">'e'</span>) != 0:
        <span class="org-variable-name">rxy</span> = tensor_ref(t, <span class="org-string">'xy'</span>)
        <span class="org-keyword">assert</span> <span class="org-builtin">isinstance</span>(rxy, <span class="org-builtin">tuple</span>)
        <span class="org-keyword">for</span> s <span class="org-keyword">in</span> r2cf(Rational(rxy[0], rxy[1])):
            <span class="org-keyword">yield</span> s, <span class="org-constant">None</span>, t, <span class="org-constant">None</span>, <span class="org-constant">None</span>, <span class="org-constant">False</span>
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">if the 'e' term is 0, that means the quotient is 0.</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">there is no need to return it</span>
        <span class="org-keyword">pass</span>

<span class="org-keyword">def</span> <span class="org-function-name">cf_arithmetic</span>(cf_a: Iterator[<span class="org-builtin">int</span>], cf_b: Iterator[<span class="org-builtin">int</span>], t0: np.ndarray, finite_term = <span class="org-constant">True</span>) -&gt; Iterator[<span class="org-builtin">int</span>]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Perform arithmetic operation on two continued fractions.</span>

<span class="org-doc">    :param cf_a: The first continued fraction.</span>
<span class="org-doc">    :param cf_b: The second continued fraction.</span>
<span class="org-doc">    :param t0: The operation, represented by a 2x2x2 tensor.</span>
<span class="org-doc">    :param finite_term: Is this a continued fraction with finite terms,</span>
<span class="org-doc">                        or a truncated one?</span>
<span class="org-doc">    :return: An iterator of the new continued fraction</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">for</span> res <span class="org-keyword">in</span> cf_arithmetic_(cf_a, cf_b, t0, finite_term = finite_term):
        (q, r, t, term, label, new_term) = res
        <span class="org-keyword">if</span> q <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
            <span class="org-keyword">yield</span> q

<span class="org-keyword">def</span> <span class="org-function-name">cf_arithmetic_func</span>(cf_a: Iterator[<span class="org-builtin">int</span>], cf_b: Iterator[<span class="org-builtin">int</span>], t0: np.ndarray) -&gt; Tuple[List[<span class="org-builtin">int</span>], np.ndarray]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Perform arithmetic operations on two finite-length continued fraction.</span>

<span class="org-doc">    Return a new fraction, and a bihomographic functiom, which can be</span>
<span class="org-doc">    applied to more terms.</span>

<span class="org-doc">    :param cf_a: The first finite-length continued fraction.</span>
<span class="org-doc">    :param cf_b: The second finite-length continued fraction.</span>
<span class="org-doc">    :param t0: A 2x2x2 tensor representing the operation.</span>
<span class="org-doc">    :return: A list, representing terms of the new continued fraction.</span>
<span class="org-doc">             A 2x2x2 tensor representing the final bihomographic function.</span>
<span class="org-doc">    """</span>
    outputs: <span class="org-variable-name">List</span>[<span class="org-builtin">int</span>] = []
    out_t: <span class="org-variable-name">Optional</span>[np.ndarray] = <span class="org-constant">None</span>
    <span class="org-keyword">for</span> res <span class="org-keyword">in</span> cf_arithmetic_(cf_a, cf_b, t0, finite_term = <span class="org-constant">False</span>):
        <span class="org-variable-name">q</span>, <span class="org-variable-name">r</span>, <span class="org-variable-name">t</span>, <span class="org-variable-name">term</span>, <span class="org-variable-name">label</span>, <span class="org-variable-name">new_term</span> = res
        <span class="org-keyword">if</span> q <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
            <span class="org-variable-name">outputs</span> = outputs + [q]
            <span class="org-variable-name">out_t</span> = r
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">out_t</span> = t

    <span class="org-keyword">assert</span> <span class="org-builtin">isinstance</span>(out_t, np.ndarray)
    <span class="org-keyword">return</span> outputs, out_t
</pre>
</div>

<p>
In an earlier <a href="#orgaa68208">section</a>, we showed that \(2 * [2, 1, 1, 5, 1] = [5, 13]\). Let's see if we can duplicate this by adding \([2, 1, 1, 5, 1]\) to itself.
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-variable-name">b</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_arithmetic(a, b, tForAddition)))
</pre>
</div>

<pre class="example">
[5, 13]
</pre>


<p>
It works! Subtraction?
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-variable-name">b</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_arithmetic(a, b, tForSubtraction)))
</pre>
</div>

<pre class="example">
[0]
</pre>


<p>
Yup! Multiplication?
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-variable-name">b</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_arithmetic(a, b, tForMultiplication)))
</pre>
</div>

<pre class="example">
[6, 2, 3, 1, 18]
</pre>


<p>
So, \(\Bigg( 2 + \frac{1}{1 + \frac{1}{1 + \frac{1}{5 + \frac{1}{1}}}} \Bigg)^2 = 6 + \frac{1}{2 + \frac{1}{3 + \frac{1}{1 + \frac{1}{18}}}}\). This is pretty cool, and it's something that we couldn't do before.
</p>


<p>
How about division?
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-variable-name">b</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_arithmetic(a, b, tForDivision)))
</pre>
</div>

<pre class="example">
[1]
</pre>


<p>
Also works. One more sanity check. This is a different way of demonstrating that the reciprocal of a continued fraction has an additional 0 in front. Note that the terms of a continued fraction are unique, except for the last one. \([2, 1, 1, 6]\) is just a different way of expressing \([2, 1, 1, 5, 1]\).
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = <span class="org-builtin">iter</span>([1])
<span class="org-variable-name">b</span> = <span class="org-builtin">iter</span>([2, 1, 1, 5, 1])
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_arithmetic(a, b, tForDivision)))
</pre>
</div>

<pre class="example">
[0, 2, 1, 1, 6]
</pre>


<p>
Finally, a more difficult question: \(\sqrt{2} * \sqrt{2} = 2\). Because \(\sqrt{2}\) is an irrational number, we'll get 2 only if we have infinite number of terms. With finite number of terms, the best that we can do is approximation.
</p>

<p>
With 6 terms of \(\sqrt{2}\), we get \(2 + \frac{1}{4900}\)
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = islice(cf_sqrt2(), 6)
<span class="org-variable-name">b</span> = islice(cf_sqrt2(), 6)
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_arithmetic(a, b, tForMultiplication)))
</pre>
</div>

<pre class="example">
[2, 4900]
</pre>


<p>
With 8 terms of \(\sqrt{2}\), we get \(2 + \frac{1}{5654884}\). So indeed, we are getting more accurate approximations of 2.
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = islice(cf_sqrt2(), 10)
<span class="org-variable-name">b</span> = islice(cf_sqrt2(), 10)
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(cf_arithmetic(a, b, tForMultiplication)))
</pre>
</div>

<pre class="example">
[2, 5654884]
</pre>


<p>
We don't have to truncate the inputs to finite terms. If the two continued fractions have infinite number of terms, we'll get the first term of the result (2) easily. However, if we ask for a second term, the program will get stuck in an infinite loop.
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">a</span> = cf_sqrt2()
<span class="org-variable-name">b</span> = cf_sqrt2()
<span class="org-variable-name">res</span> = cf_arithmetic(a, b, tForMultiplication)
<span class="org-keyword">print</span>(<span class="org-builtin">next</span>(res))
</pre>
</div>

<pre class="example">
2
</pre>
</div>
</div>

<div id="outline-container-org05af327" class="outline-2">
<h2 id="org05af327"><span class="section-number-2">11.</span> The final section with complex figures</h2>
<div class="outline-text-2" id="text-11">
<p>
Finally, we'll replicate a complex example in Gospher's paper. This example involves \(a=\frac{e^2+1}{e^2-1} = [1, 3, 5, 7\cdots]\), and \(b=\sqrt{6}=[2, 2, 4, 2, 4, 2\cdots]\). The goal is to calculate \(\frac{2ab+a}{ab+b}\).
</p>

<p>
First, define the two continued fractions:
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_sqrt6</span>():
    <span class="org-doc">"""sqrt(6) = [2, 2, 4, 2, 4, 2...]"""</span>
    <span class="org-keyword">yield</span> 2
    <span class="org-keyword">yield</span> 2
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-keyword">yield</span> 4
        <span class="org-keyword">yield</span> 2

<span class="org-keyword">def</span> <span class="org-function-name">cf_coth1</span>():
    <span class="org-doc">"""(e^2+1)/(e^2-1) = [1, 3, 5, 7...]"""</span>
    <span class="org-variable-name">s</span> = 1
    <span class="org-keyword">while</span> <span class="org-constant">True</span>:
        <span class="org-keyword">yield</span> s
        <span class="org-variable-name">s</span> = s + 2
</pre>
</div>

<p>
Then we calculate with <code>cf_arithmettic</code>:
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">t0</span> = np.array([[[1, 0], [2, 0]], [[0, 0], [1, 1]]])
<span class="org-variable-name">b</span> = islice(cf_sqrt6(), 4)
<span class="org-variable-name">a</span> = islice(cf_coth1(), 4)
<span class="org-variable-name">c</span> = cf_arithmetic(a, b, t0, finite_term = <span class="org-constant">False</span>)
<span class="org-keyword">print</span>(<span class="org-builtin">list</span>(c))
</pre>
</div>

<pre class="example">
[1, 2, 1, 2, 1, 1]
</pre>


<p>
Visualizing the process is much more difficult than the 2D cases. The tabulated display that I implemented is not very intuitive. It takes some time to learn to read it.
</p>
<div class="org-src-container">
<pre class="src src-python">
<span class="org-variable-name">t0</span> = np.array([[[1, 0], [2, 0]], [[0, 0], [1, 1]]])
<span class="org-variable-name">b</span> = islice(cf_sqrt6(), 4)
<span class="org-variable-name">a</span> = islice(cf_coth1(), 4)
<span class="org-variable-name">c</span> = cf_arithmetic_tab(a, b, t0)
<span class="org-variable-name">c.include_out</span> = <span class="org-constant">False</span>
<span class="org-keyword">print</span>(c)
</pre>
</div>

<pre class="example" id="orga3a37d0">
        7    5    3    1          
                       1    0     
             8    2    2    0    2
            20    5    5    0     
                       0    0     
             7    2    1    1     
       74   14    4    2    2    2
      185   35   10               
             1    0               
       31    6    1               
       67   13    2              4
      299   58                    
       12    2                    
 366   51    9                    
1550  216   38                   2
3466  483                         
 116   16    4                    
 601   83   20                    
1318  182                         
 348   50                         
 830  119                         
 253   33                         
 488   63                         
  95   17                         
 342   56                         

</pre>

<p>
This rendering should make it easier to understand what is going on:
</p>


<div id="orgc5a3687" class="figure">
<p><img src="../figs/cf_arithmetic_summary.png" alt="cf_arithmetic_summary.png" width="600" />
</p>
</div>

<p>
These images are fun to look at. Here's another one that I like. This is \(e+e=2e\). I rotated it to give it a horizontal orientation. 
</p>

<div id="org114dbd4" class="figure">
<p><img src="../figs/e2rotated_edit.png" alt="e2rotated_edit.png" width="600" />
</p>
</div>
</div>
</div>

<div id="outline-container-org0f1761a" class="outline-2">
<h2 id="org0f1761a"><span class="section-number-2">12.</span> Appendix: Quotients/remainders for matrices</h2>
<div class="outline-text-2" id="text-12">
<p>
Given a homographic function represented by a 2x2 matrix, determine if the Euclidean step can be performed. If yes, return the quotient.
<a id="orgd51efa2"></a>
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Simple transformation of continued fraction</span>

<span class="org-variable-name">flip_m</span> = np.array([[0, 1], [1, 0]])
<span class="org-variable-name">identity_m</span> = np.array([[1, 0], [0, 1]])

<span class="org-keyword">def</span> <span class="org-function-name">flip_remain</span>(m: np.ndarray, q: <span class="org-builtin">int</span>) -&gt; np.ndarray:
    <span class="org-doc">"""</span>
<span class="org-doc">    Caclulate the remainder, and then flip</span>

<span class="org-doc">    :param m: A 2x2 matrix</span>
<span class="org-doc">    :param q: The quotient</span>
<span class="org-doc">    :return: A 2x2 matrix</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">assert</span> q &gt;= 0
    <span class="org-variable-name">r</span> = m[0] - m[1] * q
    <span class="org-variable-name">m</span>[0] = r
    <span class="org-keyword">return</span> np.matmul(flip_m, m)

<span class="org-keyword">def</span> <span class="org-function-name">qr_matrix</span>(m: np.ndarray) -&gt; Tuple[Optional[<span class="org-builtin">int</span>], np.ndarray]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the quotient and the remainder of a 2x2 matrix</span>

<span class="org-doc">    :param m: A 2x2 matrix</span>
<span class="org-doc">    :return: The quotient (None if it cannot be found)</span>
<span class="org-doc">             The remainder (2x2 matrix; idetity if quotient cannot be found)</span>
<span class="org-doc">    """</span>

    <span class="org-keyword">assert</span> <span class="org-keyword">not</span>(m[1][0] == 0 <span class="org-keyword">and</span> m[1][1] == 0)
    <span class="org-comment-delimiter"># </span><span class="org-comment">This means that the series has already ended.</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">Nothing further needs to be done</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">The caller should not call qr_matrix in this case</span>

    <span class="org-variable-name">m2</span> = m.copy()

    <span class="org-keyword">if</span> m2[1][0] == 0 <span class="org-keyword">or</span> m2[1][1] == 0:
        <span class="org-comment-delimiter"># </span><span class="org-comment">If the function is unbounded, the quotient cannot be determined</span>
        <span class="org-keyword">return</span> (<span class="org-constant">None</span>, identity_m)
    <span class="org-keyword">elif</span> m2[1][1] &lt; 0:
        <span class="org-comment-delimiter"># </span><span class="org-comment">This means that the denominator can be made 0 (i.e., a singularity)</span>
        <span class="org-keyword">return</span> (<span class="org-constant">None</span>, identity_m)
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">If the function is bounded...</span>
        v0: <span class="org-builtin">float</span> = m[0][0] / m[1][0]
        v1: <span class="org-builtin">float</span> = m[0][1] / m[1][1]
        <span class="org-variable-name">v0</span>, <span class="org-variable-name">v1</span> = <span class="org-builtin">sorted</span>([v0, v1])
        d0: <span class="org-builtin">int</span> = math.floor(v0)
        d1: <span class="org-builtin">int</span> = math.floor(v1)
        <span class="org-keyword">if</span> d0 == d1:
            <span class="org-comment-delimiter"># </span><span class="org-comment">If d1 and d2 are the same, the quotient is determined</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">Calculate the remain, and flip the matrix</span>
            <span class="org-variable-name">m2</span> = flip_remain(m2, d1)
            <span class="org-keyword">return</span> d1, m2
        <span class="org-keyword">elif</span> d1 == d0 + 1:
            <span class="org-keyword">if</span> d1 == v1:
                <span class="org-comment-delimiter"># </span><span class="org-comment">This means that d1 is the upper-bound</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">it's only reached at 0 or infinity </span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">So d0 is the quotient</span>
                <span class="org-variable-name">m2</span> = flip_remain(m2, d0)
                <span class="org-keyword">return</span> d0, m2
            <span class="org-keyword">else</span>:
                <span class="org-comment-delimiter"># </span><span class="org-comment">The bounds are not tight enough to determine the quotient</span>
                <span class="org-keyword">return</span> (<span class="org-constant">None</span>, identity_m)
        <span class="org-keyword">else</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">The bounds are not tight enough to determine the quotient</span>
            <span class="org-keyword">return</span> (<span class="org-constant">None</span>, identity_m)
</pre>
</div>
</div>
</div>

<div id="outline-container-org8a7d946" class="outline-2">
<h2 id="org8a7d946"><span class="section-number-2">13.</span> Appendix: Quotients/remainders for tensors</h2>
<div class="outline-text-2" id="text-13">
<p>
<a id="orgdcc76fb"></a>
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Continued fraction arithmetic - Euclidean algorithmn</span>

<span class="org-keyword">def</span> <span class="org-function-name">qr_tensor</span>(t: np.ndarray) -&gt; Tuple[Optional[<span class="org-builtin">int</span>], np.ndarray]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Find the quotient and remainder of a 2x2x2 tensor</span>

<span class="org-doc">    :param t: The tensor</span>
<span class="org-doc">    :return: The quotient (None if cannot be determined)</span>
<span class="org-doc">             The remainder (2x2x2 tensor; identity if quotient is None</span>
<span class="org-doc">    """</span>

    <span class="org-variable-name">t1</span> = t.copy()
    <span class="org-keyword">if</span> np.<span class="org-builtin">all</span>(t1[1]&gt;0):
        <span class="org-comment-delimiter"># </span><span class="org-comment">if the denominator matrix doesn't have any 0 or negative number</span>
       <span class="org-variable-name">r</span> = t_ratios(t)
       <span class="org-keyword">if</span> r[0][0] == r[0][1] == r[1][0] == r[1][1]:
           <span class="org-comment-delimiter"># </span><span class="org-comment">if the integer parts are all the same, we've got a quotient</span>
           <span class="org-variable-name">q</span> = r[0][0]
           <span class="org-variable-name">rem</span> = np.array([t1[1], t1[0] - q * t1[1]])
           <span class="org-keyword">return</span> (q, rem)
       <span class="org-keyword">else</span>:
           <span class="org-comment-delimiter"># </span><span class="org-comment">the range is too big to determine the quotient</span>
           <span class="org-keyword">return</span> (<span class="org-constant">None</span>, np.array([identity_m, identity_m]))
    <span class="org-keyword">else</span>:
        <span class="org-comment-delimiter"># </span><span class="org-comment">the denominator can be zero. The dihomographic function is unbounded</span>
        <span class="org-keyword">return</span> (<span class="org-constant">None</span>, np.array([identity_m, identity_m]))
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">t_ratios</span>(t: np.ndarray) -&gt; <span class="org-builtin">list</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Calculate the floor ratios of the numerator and the denominator terms.</span>

<span class="org-doc">    Make sure that the denominator doesn't have 0 or negative numbers</span>

<span class="org-doc">    :param t: the 2x2x2 tensor</span>
<span class="org-doc">    :return: A 2x2 matrix (as list of lists)</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">def</span> <span class="org-function-name">r</span>(label):
        <span class="org-variable-name">numerator</span>, <span class="org-variable-name">denominator</span> = tensor_ref(t, label)
        <span class="org-keyword">return</span> [numerator/denominator, math.floor(numerator/denominator), label]

    <span class="org-variable-name">zz</span> = [r(<span class="org-string">'xy'</span>), r(<span class="org-string">'x'</span>), r(<span class="org-string">'y'</span>), r(<span class="org-string">'1'</span>)]
    <span class="org-comment-delimiter"># </span><span class="org-comment">sort by the floating point ratio</span>
    <span class="org-variable-name">zz_sorted</span> = <span class="org-builtin">sorted</span>(zz, key = <span class="org-keyword">lambda</span> item: item[0])

    <span class="org-variable-name">zz_max</span> = zz_sorted[-1]
    <span class="org-keyword">if</span> zz_max[0] == zz_max[1]:
        <span class="org-comment-delimiter"># </span><span class="org-comment">In this situation, the upper-bound zz_max[0] will never be reached</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">so we return the value - 1</span>
        <span class="org-variable-name">zz_max</span>[1] = zz_max[1] - 1

    <span class="org-builtin">dict</span> = {}
    <span class="org-keyword">for</span> item <span class="org-keyword">in</span> zz_sorted:
        <span class="org-builtin">dict</span>[item[2]] = item[1]

    <span class="org-keyword">return</span> [[<span class="org-builtin">dict</span>[<span class="org-string">'x'</span>], <span class="org-builtin">dict</span>[<span class="org-string">'1'</span>]], [<span class="org-builtin">dict</span>[<span class="org-string">'xy'</span>], <span class="org-builtin">dict</span>[<span class="org-string">'y'</span>]]]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Continued fraction arithmetic - scoring</span>

<span class="org-keyword">def</span> <span class="org-function-name">score</span>(t: np.ndarray) -&gt; <span class="org-builtin">float</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    A scoring function for the 2x2x2 tensor.</span>

<span class="org-doc">    A higher number means that the tensor is</span>
<span class="org-doc">    getting closer for a quotient to be determined</span>
<span class="org-doc">    """</span>

    <span class="org-keyword">def</span> <span class="org-function-name">r</span>(label):
        <span class="org-variable-name">numerator</span>, <span class="org-variable-name">denominator</span> = tensor_ref(t, label)
        <span class="org-keyword">return</span> math.floor(numerator/denominator)

    <span class="org-comment-delimiter"># </span><span class="org-comment">number of zero in the denominator</span>
    <span class="org-comment-delimiter"># </span><span class="org-comment">a negative value means that the denominator can be made zero</span>
    <span class="org-variable-name">n_zero</span> = np.count_nonzero(t[1]&lt;=0)
    <span class="org-keyword">if</span> n_zero == 3 <span class="org-keyword">or</span> n_zero == 4:
        <span class="org-comment-delimiter"># </span><span class="org-comment">0 can be removed in 2 moves</span>
        <span class="org-keyword">return</span> -2 
    <span class="org-keyword">elif</span> n_zero == 2:
        <span class="org-keyword">if</span> tensor_ref(t, <span class="org-string">'f'</span>) == 0 <span class="org-keyword">and</span> tensor_ref(t, <span class="org-string">'h'</span>) == 0:
            <span class="org-keyword">if</span> r(<span class="org-string">'xy'</span>) == r(<span class="org-string">'y'</span>):
                <span class="org-comment-delimiter"># </span><span class="org-comment">0 0</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">2 2</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">after one step, in a good position</span>
                <span class="org-keyword">return</span> -0.5
            <span class="org-keyword">else</span>:
                <span class="org-comment-delimiter"># </span><span class="org-comment">0 0</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">2 3</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">both zeros can be removed in one step</span>
                <span class="org-keyword">return</span> -1.0
        <span class="org-keyword">elif</span> tensor_ref(t, <span class="org-string">'h'</span>) == 0 <span class="org-keyword">and</span> tensor_ref(t, <span class="org-string">'g'</span>) == 0:
            <span class="org-keyword">if</span> r(<span class="org-string">'xy'</span>) == r(<span class="org-string">'x'</span>):
                <span class="org-comment-delimiter"># </span><span class="org-comment">2 0</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">2 0</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">in good position in one step</span>
                <span class="org-keyword">return</span> -0.5
            <span class="org-keyword">else</span>:
                <span class="org-comment-delimiter"># </span><span class="org-comment">2 0</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">3 0</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">both zeroes can be remoevd in one step</span>
                <span class="org-keyword">return</span> -1
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> -2
    <span class="org-keyword">elif</span> n_zero == 1:
        <span class="org-keyword">if</span> tensor_ref(t, <span class="org-string">'e'</span>) == 0:
            <span class="org-comment-delimiter"># </span><span class="org-comment">3 8</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">0 1</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">takes 2 moves to remove 0</span>
            <span class="org-keyword">return</span> -2.0
        <span class="org-keyword">elif</span> tensor_ref(t, <span class="org-string">'f'</span>) == 0:
            <span class="org-keyword">if</span> r(<span class="org-string">'xy'</span>) == r(<span class="org-string">'y'</span>):
                <span class="org-comment-delimiter"># </span><span class="org-comment">0 x</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">2 2</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">in good position in one step</span>
                <span class="org-keyword">return</span> -0.5
            <span class="org-keyword">else</span>:
                <span class="org-comment-delimiter"># </span><span class="org-comment">0 2</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">3 4</span>
                <span class="org-keyword">return</span> -1.0
        <span class="org-keyword">elif</span> tensor_ref(t, <span class="org-string">'g'</span>) == 0:
            <span class="org-keyword">if</span> (r(<span class="org-string">'xy'</span>) == r(<span class="org-string">'x'</span>)):
                <span class="org-comment-delimiter"># </span><span class="org-comment">2 3</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">2 0</span>
                <span class="org-keyword">return</span> -0.5
            <span class="org-keyword">else</span>:
                <span class="org-comment-delimiter"># </span><span class="org-comment">2 3</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">3 0                </span>
                <span class="org-keyword">return</span> -1.0
        <span class="org-keyword">else</span>:
            <span class="org-keyword">if</span> (r(<span class="org-string">'xy'</span>) == r(<span class="org-string">'x'</span>)) <span class="org-keyword">or</span> (r(<span class="org-string">'xy'</span>) == r(<span class="org-string">'y'</span>)):
                <span class="org-comment-delimiter"># </span><span class="org-comment">2 0</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">2 3</span>
                <span class="org-keyword">return</span> -0.5
            <span class="org-keyword">else</span>:
                <span class="org-keyword">return</span> -1.0
    <span class="org-keyword">else</span>: <span class="org-comment-delimiter"># </span><span class="org-comment">no zereos in the denominator</span>
        <span class="org-variable-name">r_</span>  = t_ratios(t)
        <span class="org-keyword">if</span> r_[0][0] == r_[0][1] == r_[1][0] == r_[1][1]:
            <span class="org-comment-delimiter"># </span><span class="org-comment">the 4 ratios are all the same. This is the best situation</span>
            <span class="org-keyword">return</span> 4.0
        <span class="org-keyword">elif</span> (r_[0][0] == r_[1][0]) <span class="org-keyword">or</span> (r_[1][0] == r_[1][1]):
            <span class="org-comment-delimiter"># </span><span class="org-comment">3 1       1 2</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">3 2 or    3 3</span>
            <span class="org-keyword">return</span> 1.0
        <span class="org-keyword">else</span>:
            <span class="org-keyword">return</span> 0.0
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">ABQueue</span>(a: Iterator[<span class="org-builtin">int</span>], b: Iterator[<span class="org-builtin">int</span>]) -&gt; Callable[[np.ndarray], Tuple[Optional[<span class="org-builtin">int</span>], Optional[<span class="org-builtin">str</span>]]]:
    <span class="org-doc">"""</span>
<span class="org-doc">    Return next term either from the first or the second continued fraction.</span>

<span class="org-doc">    The source is selected by the scoring function.</span>

<span class="org-doc">    :param a: The first continued fraction.</span>
<span class="org-doc">    :param b: The second continued fraction.</span>
<span class="org-doc">    :return: A closure. Give 2x2x2 tensor, return a new term, and the source.</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">current_a</span> = <span class="org-constant">None</span>
    <span class="org-variable-name">current_b</span> = <span class="org-constant">None</span>
    <span class="org-variable-name">last_tie</span> = <span class="org-string">'b'</span>

    <span class="org-keyword">def</span> <span class="org-function-name">ABQueue_</span>(t: np.ndarray) -&gt; Tuple[Optional[<span class="org-builtin">int</span>], Optional[<span class="org-builtin">str</span>]]:
        <span class="org-keyword">nonlocal</span> current_a
        <span class="org-keyword">nonlocal</span> current_b
        <span class="org-keyword">nonlocal</span> last_tie

        <span class="org-keyword">def</span> <span class="org-function-name">dequeue</span>(label: <span class="org-builtin">str</span>) -&gt; Tuple[Optional[<span class="org-builtin">int</span>], Optional[<span class="org-builtin">str</span>]]:
            <span class="org-keyword">nonlocal</span> current_a
            <span class="org-keyword">nonlocal</span> current_b
            <span class="org-keyword">nonlocal</span> last_tie
            <span class="org-keyword">assert</span> label <span class="org-keyword">in</span> [<span class="org-string">'a'</span>, <span class="org-string">'b'</span>, <span class="org-string">'alt'</span>]
            <span class="org-keyword">if</span> label == <span class="org-string">'a'</span>:
                <span class="org-variable-name">next_term</span> = current_a
                <span class="org-variable-name">current_a</span> = <span class="org-constant">None</span>
                <span class="org-keyword">return</span> next_term, <span class="org-string">'a'</span>
            <span class="org-keyword">elif</span> label == <span class="org-string">'b'</span>:
                <span class="org-variable-name">next_term</span> = current_b
                <span class="org-variable-name">current_b</span> = <span class="org-constant">None</span>
                <span class="org-keyword">return</span> next_term, <span class="org-string">'b'</span>
            <span class="org-keyword">else</span>:
                <span class="org-keyword">assert</span> label == <span class="org-string">'alt'</span>
                <span class="org-keyword">if</span> last_tie == <span class="org-string">'a'</span>:
                    <span class="org-variable-name">next_term</span> = current_b
                    <span class="org-variable-name">current_b</span> = <span class="org-constant">None</span>
                    <span class="org-variable-name">last_tie</span> = <span class="org-string">'b'</span>
                    <span class="org-keyword">return</span> next_term, <span class="org-string">'b'</span>
                <span class="org-keyword">else</span>:
                    <span class="org-variable-name">next_term</span> = current_a
                    <span class="org-variable-name">current_a</span> = <span class="org-constant">None</span>
                    <span class="org-variable-name">last_tie</span> = <span class="org-string">'a'</span>
                    <span class="org-keyword">return</span> next_term, <span class="org-string">'a'</span>

        <span class="org-keyword">if</span> current_a <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-variable-name">current_a</span> = <span class="org-builtin">next</span>(a, <span class="org-constant">None</span>)
        <span class="org-keyword">if</span> current_b <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-variable-name">current_b</span> = <span class="org-builtin">next</span>(b, <span class="org-constant">None</span>)

        <span class="org-keyword">if</span> current_a <span class="org-keyword">is</span> <span class="org-constant">None</span> <span class="org-keyword">and</span> current_b <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">both a and b are empty</span>
            <span class="org-keyword">return</span> <span class="org-constant">None</span>, <span class="org-constant">None</span>
        <span class="org-keyword">elif</span> current_a <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">if a is empty, return b</span>
            <span class="org-keyword">return</span> dequeue(<span class="org-string">'b'</span>)
        <span class="org-keyword">elif</span> current_b <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">if b is empty, return a</span>
            <span class="org-keyword">return</span> dequeue(<span class="org-string">'a'</span>)
        <span class="org-keyword">else</span>:
            <span class="org-variable-name">t_a</span> = apply_ab(t, current_a, <span class="org-string">'a'</span>)
            <span class="org-variable-name">t_b</span> = apply_ab(t, current_b, <span class="org-string">'b'</span>)
            <span class="org-variable-name">s_a</span>, <span class="org-variable-name">s_b</span> = score(t_a), score(t_b)
            <span class="org-keyword">if</span> s_a == s_b:
                <span class="org-keyword">return</span> dequeue(<span class="org-string">'alt'</span>)
            <span class="org-keyword">if</span> s_a &lt; s_b:
                <span class="org-keyword">return</span> dequeue(<span class="org-string">'b'</span>)
            <span class="org-keyword">else</span>:
                <span class="org-keyword">return</span> dequeue(<span class="org-string">'a'</span>)
    <span class="org-keyword">return</span> ABQueue_
</pre>
</div>
</div>
</div>

<div id="outline-container-orgaa3f244" class="outline-2">
<h2 id="orgaa3f244"><span class="section-number-2">14.</span> Appendix: Unit tests</h2>
<div class="outline-text-2" id="text-14">
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;TEST_IMPORTS&gt;&gt;
&lt;&lt;TEST_R2CF&gt;&gt;
&lt;&lt;TEST_QR_MATRIX&gt;&gt;
&lt;&lt;TEST_CONVERGENTS&gt;&gt;
&lt;&lt;TEST_CF2R&gt;&gt;
&lt;&lt;TEST_CF_TRANSFORM&gt;&gt;
&lt;&lt;TEST_BIHO&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-org3f9c00f" class="outline-3">
<h3 id="org3f9c00f"><span class="section-number-3">14.1.</span> Using continued fractions to represent rational numbers</h3>
<div class="outline-text-3" id="text-14-1">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">TestR2cf</span>(<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">test_basic</span>(<span class="org-keyword">self</span>):
        <span class="org-variable-name">res</span> = r2cf(Rational(254, 100))
        <span class="org-keyword">assert</span> <span class="org-builtin">list</span>(res) == [2, 1, 1, 5, 1, 3]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc0f89a4" class="outline-3">
<h3 id="orgc0f89a4"><span class="section-number-3">14.2.</span> Convergents</h3>
<div class="outline-text-3" id="text-14-2">
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Apply this test to two functions, because they should be equivalent</span>
<span class="org-type">@pytest.mark.parametrize</span>(<span class="org-string">'conv_func'</span>, [cf_convergents0, cf_convergents1])
<span class="org-keyword">def</span> <span class="org-function-name">test_convergents_basci1</span>(conv_func):
    <span class="org-variable-name">lst</span> = <span class="org-builtin">list</span>(conv_func(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1, 3])))
    <span class="org-keyword">assert</span> lst[0] == Rational(2, 1)
    <span class="org-keyword">assert</span> lst[1] == Rational(3, 1)
    <span class="org-keyword">assert</span> lst[2] == Rational(5, 2)
    <span class="org-keyword">assert</span> lst[3] == Rational(28, 11)
    <span class="org-keyword">assert</span> lst[4] == Rational(33, 13)
    <span class="org-keyword">assert</span> lst[5] == Rational(127, 50)
    <span class="org-keyword">assert</span> <span class="org-builtin">len</span>(lst) == 6

<span class="org-comment-delimiter"># </span><span class="org-comment">Apply this test to two functions, because they should be equivalent</span>
<span class="org-type">@pytest.mark.parametrize</span>(<span class="org-string">'conv_func'</span>, [cf_convergents0, cf_convergents1])
<span class="org-keyword">def</span> <span class="org-function-name">test_convergents_basic2</span>(conv_func):
    <span class="org-variable-name">lst</span> = <span class="org-builtin">list</span>(cf_convergents0(<span class="org-builtin">iter</span>([1, 2, 3, 4, 5])))
    <span class="org-keyword">assert</span> lst[0] == Rational(1, 1)
    <span class="org-keyword">assert</span> lst[1] == Rational(3, 2)
    <span class="org-keyword">assert</span> lst[2] == Rational(10, 7)
    <span class="org-keyword">assert</span> lst[3] == Rational(43, 30)
    <span class="org-keyword">assert</span> lst[4] == Rational(225, 157)
    <span class="org-keyword">assert</span> <span class="org-builtin">len</span>(lst) == 5
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">cf2r0 and cf2r1 should be equivalent</span>
<span class="org-type">@pytest.mark.parametrize</span>(<span class="org-string">'cf2r_func'</span>, [cf2r0, cf2r1])
<span class="org-keyword">def</span> <span class="org-function-name">test_cf2r</span>(cf2r_func):
    <span class="org-keyword">assert</span> cf2r_func([2, 1, 1, 5, 1, 3]) == Rational(127, 50)
    <span class="org-keyword">assert</span> cf2r_func([1, 2, 3, 4, 5]) == Rational(225, 157)
</pre>
</div>
</div>
</div>

<div id="outline-container-org0567cd9" class="outline-3">
<h3 id="org0567cd9"><span class="section-number-3">14.3.</span> Symbolic Euclidean algorithm</h3>
<div class="outline-text-3" id="text-14-3">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">TestQRMatrix</span>(<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">qr</span>(<span class="org-keyword">self</span>, m):
        <span class="org-variable-name">res</span> = qr_matrix(np.array(m))
        <span class="org-keyword">if</span> res <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-keyword">return</span> <span class="org-constant">None</span>
        <span class="org-keyword">else</span>:
            (q, r) = res
            <span class="org-keyword">return</span> q, r.tolist()

    <span class="org-keyword">def</span> <span class="org-function-name">test_basic1</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(4x+2)/(3x+2) is between 4/2 and 2/2 (1 to 1.33)</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">increasing</span>
        <span class="org-variable-name">m</span> = [[4, 2], [3, 2]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 1 <span class="org-keyword">and</span> r == [[3, 2], [1, 0]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_basic2</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(70x + 29)/ (12x + 5) is between 29/5 and 35/6 (5.8 to 5.88)</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">increasing. an example in the paper</span>
        <span class="org-variable-name">m</span> = [[70, 29], [12, 5]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 5 <span class="org-keyword">and</span> r == [[12, 5], [10, 4]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_basic3</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(12x + 5) / (10 x + 4) is between 6/5 and 5/4 (1.2 to 1.25)</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">decreasing. an example in the paper</span>
        <span class="org-variable-name">m</span> = [[12, 5], [10, 4]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 1 <span class="org-keyword">and</span> r == [[10, 4], [2, 1]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_edgecase1</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(10x + 4) / (2x + 1) is bounded between 4 and 5</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">the quotient is 4, because it is 5 only at infinity</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">increasing. an example in the paper</span>
        <span class="org-variable-name">m</span> = [[10, 4], [2, 1]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 4 <span class="org-keyword">and</span> r == [[2, 1], [2, 0]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_edgecase2</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(8x + 3) / (2x + 1) is bounded between 3 and 4</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">it is only 4 if x is infinity, so the quotient has to be 3</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">increasing</span>
        <span class="org-variable-name">m</span> = [[8, 3], [2, 1]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 3 <span class="org-keyword">and</span> r == [[2, 1], [2, 0]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_edgecase3</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(29x + 6) / (5x + 1) is bounded between 5.8 and 6</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">it is only 6 if x is 0, so the coefficient has to be 5</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">decreasing</span>
        <span class="org-variable-name">m</span> = [[29, 6], [5, 1]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 5 <span class="org-keyword">and</span> r == [[5, 1], [4, 1]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_unbounded1</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">4x + 2 is unbounded</span>
        <span class="org-variable-name">m</span> = [[4, 2], [0, 1]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q <span class="org-keyword">is</span> <span class="org-constant">None</span>

    <span class="org-keyword">def</span> <span class="org-function-name">test_unbounded2</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(4x + 2) / 3 is unbounded</span>
        <span class="org-variable-name">m</span> = [[4, 2], [3, 0]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q <span class="org-keyword">is</span> <span class="org-constant">None</span>

    <span class="org-keyword">def</span> <span class="org-function-name">test_unbounded3</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">2x / (2x - 1) is unbounded, because there is a singularity at x = 1/2</span>
        <span class="org-comment-delimiter"># </span><span class="org-comment">This is in the paper</span>
        <span class="org-variable-name">m</span> = [[2, 0], [2, -1]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q <span class="org-keyword">is</span> <span class="org-constant">None</span>

    <span class="org-keyword">def</span> <span class="org-function-name">test_zero_coeff</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(1x + 2) / (2x + 3) is bounded between 1/2 and 2/3 (0.5 to 0.666)</span>
        <span class="org-variable-name">m</span> = [[1, 2], [2, 3]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q == 0 <span class="org-keyword">and</span> r == [[2, 3], [1, 2]]

    <span class="org-keyword">def</span> <span class="org-function-name">test_too_wide</span>(<span class="org-keyword">self</span>):
        <span class="org-comment-delimiter"># </span><span class="org-comment">(7x + 5) / (x + 1) is bounded between 5 and 7. </span>
        <span class="org-variable-name">m</span> = [[7, 5], [1, 1]]
        (q, r) = <span class="org-keyword">self</span>.qr(m)
        <span class="org-keyword">assert</span> q <span class="org-keyword">is</span> <span class="org-constant">None</span>
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf96ffb3" class="outline-3">
<h3 id="orgf96ffb3"><span class="section-number-3">14.4.</span> Transformations of continued fractions</h3>
<div class="outline-text-3" id="text-14-4">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">TestCFTransform</span>(<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">test_cf_transform_basic1</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">""" 2 * [2, 1, 1, 5, 1] == 66/13"""</span>
        <span class="org-variable-name">m0</span> = np.array([[2, 0], [0, 1]], <span class="org-builtin">int</span>)
        <span class="org-variable-name">cf1</span> = <span class="org-builtin">list</span>(cf_transform(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1]), m0 = m0))
        <span class="org-variable-name">cf2</span> = <span class="org-builtin">list</span>(r2cf(Rational(66, 13)))
        <span class="org-keyword">assert</span> cf1 == cf2

    <span class="org-keyword">def</span> <span class="org-function-name">test_cf_transform_basic2</span>(<span class="org-keyword">self</span>):
        <span class="org-doc">""" 1 / [2, 1, 1, 5, 1] == [0, 2, 1, 1, 5, 1]"""</span>
        <span class="org-variable-name">m0</span> = np.array([[0, 1], [1, 0]], <span class="org-builtin">int</span>)
        <span class="org-variable-name">cf1</span> = <span class="org-builtin">list</span>(cf_transform(<span class="org-builtin">iter</span>([2, 1, 1, 5, 1]), m0 = m0))
        <span class="org-variable-name">cf2</span> = [0, 2, 1, 1, 5, 1]
        <span class="org-keyword">assert</span> cf1 == cf2
</pre>
</div>
</div>
</div>

<div id="outline-container-org95751bb" class="outline-3">
<h3 id="org95751bb"><span class="section-number-3">14.5.</span> Bihomography</h3>
<div class="outline-text-3" id="text-14-5">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">class</span> <span class="org-type">TestBiho</span>(<span class="org-builtin">object</span>):
    <span class="org-keyword">def</span> <span class="org-function-name">test_biho_basic1</span>(<span class="org-keyword">self</span>):
        (a, b, c, d, e, f, g, h) = (1, 2, 3, 4, 5, 6, 7, 8)
        <span class="org-variable-name">m</span> = np.array([[a, b, c, d], [e, f, g, h]])
        <span class="org-variable-name">t</span> = tFrom2x4(m)
        <span class="org-keyword">assert</span> np.array_equal(t, np.array([[[b, d], [a, c]], [[f, h], [e, g]]]))

    <span class="org-keyword">def</span> <span class="org-function-name">test_biho_basic2</span>(<span class="org-keyword">self</span>):
        (a, b, c, d, e, f, g, h) = (1, 2, 3, 4, 5, 6, 7, 8)
        <span class="org-variable-name">m</span> = np.array([[a, b, c, d], [e, f, g, h]])
        <span class="org-variable-name">t</span> = np.array([[[b, d], [a, c]], [[f, h], [e, g]]])
        <span class="org-keyword">assert</span> np.array_equal(tTo2x4(t), m)
</pre>
</div>
</div>
</div>
<div id="outline-container-org0482f23" class="outline-3">
<h3 id="org0482f23"><span class="section-number-3">14.6.</span> Imports</h3>
<div class="outline-text-3" id="text-14-6">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">import</span> pytest
<span class="org-keyword">from</span> cont_frac <span class="org-keyword">import</span> *
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org805551c" class="outline-2">
<h2 id="org805551c"><span class="section-number-2">15.</span> Appendix: Display utilities</h2>
<div class="outline-text-2" id="text-15">
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;IO_IMPORTS&gt;&gt;
&lt;&lt;TAB_UTILS&gt;&gt;
&lt;&lt;TABS&gt;&gt;
&lt;&lt;TABS3D&gt;&gt;
&lt;&lt;MISC&gt;&gt;  
&lt;&lt;LATEX_UTILS&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-orgb205175" class="outline-3">
<h3 id="orgb205175"><span class="section-number-3">15.1.</span> Tabulated display utilities</h3>
<div class="outline-text-3" id="text-15-1">
<p>
<code>Chart</code> is a class for constructing and exporting tabulated displays. It can be used for 2D (i.e., operations involving one continued fraction) or 3D (operations involving two continued fractions) displays. For 2D displayed, the homographic matrices are converted into bihomographic tensors.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Utilities for tabulated displays</span>

<span class="org-keyword">class</span> <span class="org-type">Chart</span>(<span class="org-builtin">object</span>):
    <span class="org-doc">"""Construction and export tabulated displays"""</span>
    <span class="org-keyword">def</span> <span class="org-function-name">__init__</span>(<span class="org-keyword">self</span>, m: np.ndarray = tForAddition):
        <span class="org-keyword">if</span> <span class="org-builtin">len</span>(m.shape) == 2:
            <span class="org-comment-delimiter"># </span><span class="org-comment">if initialized with a matrix intead of a tensor</span>
            <span class="org-keyword">self</span>.include_b = <span class="org-constant">False</span>
            <span class="org-keyword">self</span>.mode2D = <span class="org-constant">True</span>
            <span class="org-keyword">self</span>.current_tensor = Chart.m2t(m)
            <span class="org-keyword">self</span>.boards = <span class="org-keyword">self</span>.current_tensor.tolist()
        <span class="org-keyword">else</span>:
            <span class="org-keyword">self</span>.boards = m.tolist()
            <span class="org-keyword">self</span>.include_b = <span class="org-constant">True</span>
            <span class="org-keyword">self</span>.mode2D = <span class="org-constant">False</span>
            <span class="org-keyword">self</span>.current_tensor = m.copy()

        <span class="org-keyword">self</span>.output: List[Optional[<span class="org-builtin">int</span>]] = [<span class="org-constant">None</span>]
        <span class="org-keyword">self</span>.a: <span class="org-variable-name">List</span> = []
        <span class="org-keyword">self</span>.b: <span class="org-variable-name">List</span> = [[]]
        <span class="org-keyword">self</span>.include_a = <span class="org-constant">True</span>
        <span class="org-keyword">self</span>.include_out = <span class="org-constant">True</span>

    @<span class="org-builtin">staticmethod</span>
    <span class="org-keyword">def</span> <span class="org-function-name">m2t</span>(m: np.ndarray) -&gt; np.ndarray:
        <span class="org-doc">"""Convert a homographic matrix into a bihomographic tensor"""</span>
        <span class="org-keyword">return</span> np.array([[[m[0,0], m[0,1]], [0, 0]], [[m[1,0], m[1,1]], [0, 0]]])

    &lt;&lt;ACCEPT_INPUT&gt;&gt;
    &lt;&lt;PROCESS_OUTPUT&gt;&gt;
    &lt;&lt;MAKE_ARRAY&gt;&gt;
    &lt;&lt;DISPLAY_EXPORT&gt;&gt;
</pre>
</div>
</div>

<div id="outline-container-orgb91d275" class="outline-4">
<h4 id="orgb91d275"><span class="section-number-4">15.1.1.</span> Take inputs from continued fractions</h4>
<div class="outline-text-4" id="text-15-1-1">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">move_left</span>(<span class="org-keyword">self</span>, t: np.ndarray, a: <span class="org-builtin">int</span>):
    <span class="org-doc">"""t is the matrix or tensor after a new term of a"""</span>
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(t.shape)==2 <span class="org-keyword">and</span> <span class="org-keyword">self</span>.mode2D:
        <span class="org-variable-name">t2</span> = Chart.m2t(t)
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">t2</span> = t

    <span class="org-keyword">assert</span> tensor_ref(t2, <span class="org-string">'y'</span>) == tensor_ref(<span class="org-keyword">self</span>.current_tensor, <span class="org-string">'xy'</span>)
    <span class="org-keyword">assert</span> tensor_ref(t2, <span class="org-string">'1'</span>) == tensor_ref(<span class="org-keyword">self</span>.current_tensor, <span class="org-string">'x'</span>)
    <span class="org-keyword">self</span>.current_tensor = t2

    <span class="org-comment-delimiter"># </span><span class="org-comment">add a new column for all boards</span>
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards)):
        <span class="org-keyword">for</span> j <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards[0])):
            <span class="org-keyword">self</span>.boards[i][j] = [<span class="org-constant">None</span>] + <span class="org-keyword">self</span>.boards[i][j]

    <span class="org-keyword">self</span>.boards[-2][-2][0] = tensor_ref(t2, <span class="org-string">'b'</span>)
    <span class="org-keyword">self</span>.boards[-2][-1][0] = tensor_ref(t2, <span class="org-string">'a'</span>)
    <span class="org-keyword">self</span>.boards[-1][-2][0] = tensor_ref(t2, <span class="org-string">'f'</span>)
    <span class="org-keyword">self</span>.boards[-1][-1][0] = tensor_ref(t2, <span class="org-string">'e'</span>)
    <span class="org-keyword">self</span>.a = [a] + <span class="org-keyword">self</span>.a

<span class="org-keyword">def</span> <span class="org-function-name">move_down</span>(<span class="org-keyword">self</span>, t: np.ndarray, b: <span class="org-builtin">int</span>):
    <span class="org-doc">"""t is the matrix or tensor after a new term of b"""</span>
    <span class="org-keyword">assert</span> tensor_ref(t, <span class="org-string">'x'</span>) == tensor_ref(<span class="org-keyword">self</span>.current_tensor, <span class="org-string">'xy'</span>)
    <span class="org-keyword">assert</span> tensor_ref(t, <span class="org-string">'1'</span>) == tensor_ref(<span class="org-keyword">self</span>.current_tensor, <span class="org-string">'y'</span>)
    <span class="org-keyword">self</span>.current_tensor = t
    <span class="org-variable-name">new_row_numerator</span>   = [<span class="org-constant">None</span>] * <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards[0][0])
    <span class="org-variable-name">new_row_denominator</span> = [<span class="org-constant">None</span>] * <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards[1][0])
    <span class="org-variable-name">new_row_numerator</span>[0] = tensor_ref(t, <span class="org-string">'a'</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">type: ignore</span>
    <span class="org-variable-name">new_row_numerator</span>[1] = tensor_ref(t, <span class="org-string">'c'</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">type: ignore</span>
    <span class="org-variable-name">new_row_denominator</span>[0] = tensor_ref(t, <span class="org-string">'e'</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">type: ignore</span>
    <span class="org-variable-name">new_row_denominator</span>[1] = tensor_ref(t, <span class="org-string">'g'</span>) <span class="org-comment-delimiter"># </span><span class="org-comment">type: ignore</span>
    <span class="org-keyword">self</span>.boards[-2] = <span class="org-keyword">self</span>.boards[-2] + [new_row_numerator]
    <span class="org-keyword">self</span>.boards[-1] = <span class="org-keyword">self</span>.boards[-1] + [new_row_denominator]
    <span class="org-keyword">self</span>.b[-1] = <span class="org-keyword">self</span>.b[-1] + [b]

    <span class="org-comment-delimiter"># </span><span class="org-comment">all boards under have to be expanded</span>
    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(0, <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards)-2):
        <span class="org-keyword">self</span>.boards[i] = <span class="org-keyword">self</span>.boards[i] + [[<span class="org-constant">None</span>] * <span class="org-builtin">len</span>(new_row_numerator)]
</pre>
</div>
</div>
</div>

<div id="outline-container-orga7754d7" class="outline-4">
<h4 id="orga7754d7"><span class="section-number-4">15.1.2.</span> Process output</h4>
<div class="outline-text-4" id="text-15-1-2">
<p>
After an Euclidean step, we "move under" by creating a new board.
</p>
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">move_under</span>(<span class="org-keyword">self</span>, t: np.ndarray, output: <span class="org-builtin">int</span>):
    <span class="org-doc">"""</span>
<span class="org-doc">    t is the matrix or tensor after a Euclidean step.</span>
<span class="org-doc">    output is the quotient</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(t.shape)==2 <span class="org-keyword">and</span> <span class="org-keyword">self</span>.mode2D:
        <span class="org-variable-name">t2</span> = Chart.m2t(t)
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">t2</span> = t

    <span class="org-keyword">assert</span> tensor_ref(<span class="org-keyword">self</span>.current_tensor, <span class="org-string">'f'</span>) == tensor_ref(t2, <span class="org-string">'b'</span>)
    <span class="org-keyword">assert</span> tensor_ref(<span class="org-keyword">self</span>.current_tensor, <span class="org-string">'h'</span>) == tensor_ref(t2, <span class="org-string">'d'</span>)
    <span class="org-keyword">assert</span> tensor_ref(<span class="org-keyword">self</span>.current_tensor, <span class="org-string">'e'</span>) == tensor_ref(t2, <span class="org-string">'a'</span>)
    <span class="org-keyword">assert</span> tensor_ref(<span class="org-keyword">self</span>.current_tensor, <span class="org-string">'g'</span>) == tensor_ref(t2, <span class="org-string">'c'</span>)
    <span class="org-keyword">self</span>.current_tensor = t2

    <span class="org-variable-name">n_rows</span> = <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards[0])
    <span class="org-variable-name">n_cols</span> = <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards[0][0])
    <span class="org-keyword">def</span> <span class="org-function-name">new_row</span>():
        <span class="org-keyword">return</span> [<span class="org-constant">None</span>] * n_cols
    <span class="org-variable-name">new_boards</span> = [new_row() <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(n_rows)]

    new_boards[-2][0] = tensor_ref(t2, <span class="org-string">'f'</span>)
    new_boards[-2][1] = tensor_ref(t2, <span class="org-string">'h'</span>)
    new_boards[-1][0] = tensor_ref(t2, <span class="org-string">'e'</span>)
    new_boards[-1][1] = tensor_ref(t2, <span class="org-string">'g'</span>)
    <span class="org-keyword">self</span>.boards = <span class="org-keyword">self</span>.boards + [new_boards]

    <span class="org-variable-name">new_b</span> = [<span class="org-constant">None</span>] * <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.b[-1])
    <span class="org-keyword">self</span>.b = <span class="org-keyword">self</span>.b + [new_b]

    <span class="org-keyword">self</span>.output = <span class="org-keyword">self</span>.output + [output]
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbd0e5d7" class="outline-4">
<h4 id="orgbd0e5d7"><span class="section-number-4">15.1.3.</span> Convert to array</h4>
<div class="outline-text-4" id="text-15-1-3">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">board_to_array</span>(<span class="org-keyword">self</span>, board: List, b: List, out: Optional[<span class="org-builtin">int</span>], truncate_board = <span class="org-constant">False</span>) -&gt; List:
    new_content: List[List[Optional[<span class="org-builtin">int</span>]]] = []
    <span class="org-keyword">for</span> i, row <span class="org-keyword">in</span> <span class="org-builtin">enumerate</span>(board):
        <span class="org-variable-name">skip</span> = <span class="org-constant">False</span>
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.mode2D <span class="org-keyword">and</span> i%2==1:
            <span class="org-variable-name">skip</span> = <span class="org-constant">True</span>

        <span class="org-keyword">if</span> truncate_board:
            <span class="org-keyword">if</span> row.count(<span class="org-constant">None</span>) == <span class="org-builtin">len</span>(row):
                <span class="org-variable-name">skip</span> = <span class="org-constant">True</span>

        <span class="org-keyword">if</span> <span class="org-keyword">not</span> skip:
            <span class="org-variable-name">new_row</span> = row.copy()

            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.include_b:
                <span class="org-keyword">if</span> i == 0:
                    <span class="org-variable-name">new_row</span> = new_row + [<span class="org-constant">None</span>]
                <span class="org-keyword">elif</span> b <span class="org-keyword">is</span> <span class="org-constant">None</span>:
                    <span class="org-variable-name">new_row</span> = new_row + [<span class="org-constant">None</span>]
                <span class="org-keyword">elif</span> i &lt;= <span class="org-builtin">len</span>(b):
                    <span class="org-variable-name">new_row</span> = new_row + [b[i-1]]
                <span class="org-keyword">else</span>:
                    <span class="org-variable-name">new_row</span> = new_row + [<span class="org-constant">None</span>]

            <span class="org-keyword">if</span> <span class="org-keyword">self</span>.include_out:
                <span class="org-keyword">if</span> i == <span class="org-builtin">len</span>(board) - 2:
                    <span class="org-variable-name">new_row</span> = new_row + [out]
                <span class="org-keyword">else</span>:
                    <span class="org-variable-name">new_row</span> = new_row + [<span class="org-constant">None</span>]

            <span class="org-variable-name">new_content</span> = new_content + [new_row]
    <span class="org-keyword">return</span> new_content

<span class="org-keyword">def</span> <span class="org-function-name">to_array</span>(<span class="org-keyword">self</span>, truncate_board = <span class="org-constant">False</span>) -&gt; <span class="org-builtin">list</span>:
    content: <span class="org-variable-name">List</span>[List] = []
    row: List[Optional[<span class="org-builtin">int</span>]] = []
    <span class="org-variable-name">n_cols</span> = <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards[0][0])

    <span class="org-keyword">if</span> <span class="org-keyword">self</span>.include_a:
        <span class="org-variable-name">row</span> = row + [<span class="org-constant">None</span>]
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.include_b:
            <span class="org-variable-name">row</span> = row + [<span class="org-constant">None</span>]
        <span class="org-keyword">if</span> <span class="org-keyword">self</span>.include_out:
            <span class="org-variable-name">row</span> = row + [<span class="org-constant">None</span>]
        <span class="org-variable-name">row</span> = <span class="org-keyword">self</span>.a + row
        <span class="org-variable-name">row</span> = [<span class="org-constant">None</span>] * (n_cols - <span class="org-builtin">len</span>(<span class="org-keyword">self</span>.a) - 1) + row <span class="org-comment-delimiter"># </span><span class="org-comment">type: ignore</span>
        <span class="org-variable-name">content</span> = content + [row]

    <span class="org-keyword">for</span> i <span class="org-keyword">in</span> <span class="org-builtin">range</span>(<span class="org-builtin">len</span>(<span class="org-keyword">self</span>.boards)):
        <span class="org-variable-name">board</span> = <span class="org-keyword">self</span>.boards[i]
        <span class="org-variable-name">b</span> = <span class="org-keyword">self</span>.b[i] <span class="org-keyword">if</span> i&lt;<span class="org-builtin">len</span>(<span class="org-keyword">self</span>.b) <span class="org-keyword">else</span> <span class="org-constant">None</span>
        <span class="org-variable-name">out</span> = <span class="org-keyword">self</span>.output[i] <span class="org-keyword">if</span> i&lt;<span class="org-builtin">len</span>(<span class="org-keyword">self</span>.output) <span class="org-keyword">else</span> <span class="org-constant">None</span>
        <span class="org-variable-name">content</span> = content + <span class="org-keyword">self</span>.board_to_array(board, b, out, truncate_board = truncate_board)

    <span class="org-keyword">return</span> content
</pre>
</div>
</div>
</div>
<div id="outline-container-org1e9ccbc" class="outline-4">
<h4 id="org1e9ccbc"><span class="section-number-4">15.1.4.</span> Display/export</h4>
<div class="outline-text-4" id="text-15-1-4">
<div class="org-src-container">
<pre class="src src-python">@<span class="org-builtin">staticmethod</span>
<span class="org-keyword">def</span> <span class="org-function-name">pp_item</span>(item: <span class="org-builtin">int</span>, field_width: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">str</span>:
    <span class="org-keyword">if</span> item <span class="org-keyword">is</span> <span class="org-constant">None</span>:
        <span class="org-keyword">return</span> <span class="org-string">" "</span> * field_width
    <span class="org-keyword">else</span>:
        <span class="org-keyword">return</span> f<span class="org-string">"{item : &gt; {field_width}}"</span>

@<span class="org-builtin">staticmethod</span>
<span class="org-keyword">def</span> <span class="org-function-name">pp_row</span>(row: <span class="org-builtin">list</span>, field_width: <span class="org-builtin">int</span>) -&gt; <span class="org-builtin">str</span>:
    <span class="org-keyword">return</span> <span class="org-builtin">reduce</span>(<span class="org-keyword">lambda</span> s, item: s + Chart.pp_item(item, field_width), row, <span class="org-string">""</span>) + <span class="org-string">"\n"</span>

<span class="org-keyword">def</span> <span class="org-function-name">__repr__</span>(<span class="org-keyword">self</span>) -&gt; <span class="org-builtin">str</span>:
    <span class="org-variable-name">content</span> = <span class="org-keyword">self</span>.to_array(truncate_board = <span class="org-constant">True</span>)

    <span class="org-variable-name">content_nonone</span> = [[c <span class="org-keyword">for</span> c <span class="org-keyword">in</span> row <span class="org-keyword">if</span> c <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>] <span class="org-keyword">for</span> row <span class="org-keyword">in</span> content]
    <span class="org-variable-name">content_nonone</span> = [r <span class="org-keyword">for</span> r <span class="org-keyword">in</span> content_nonone <span class="org-keyword">if</span> r != []]
    <span class="org-variable-name">mx</span> = <span class="org-builtin">max</span>(<span class="org-builtin">map</span>(<span class="org-builtin">max</span>, content_nonone))
    <span class="org-variable-name">field_width</span> = <span class="org-builtin">len</span>(<span class="org-builtin">str</span>(mx)) + 1

    <span class="org-variable-name">s</span> = <span class="org-builtin">reduce</span>(<span class="org-keyword">lambda</span> s, r: s + Chart.pp_row(r, field_width), content, <span class="org-string">""</span>)
    <span class="org-keyword">return</span> s

<span class="org-keyword">def</span> <span class="org-function-name">export_csv</span>(<span class="org-keyword">self</span>, filename: <span class="org-builtin">str</span>, truncate_board = <span class="org-constant">False</span>):
    <span class="org-variable-name">content</span> = <span class="org-keyword">self</span>.to_array(truncate_board = truncate_board)
    <span class="org-keyword">with</span> <span class="org-builtin">open</span>(filename, mode = <span class="org-string">'w'</span>) <span class="org-keyword">as</span> outfile:
        <span class="org-variable-name">writer</span> = csv.writer(outfile)
        writer.writerows(content)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgd70e2cf" class="outline-3">
<h3 id="orgd70e2cf"><span class="section-number-3">15.2.</span> Tabulated displays: 2D</h3>
<div class="outline-text-3" id="text-15-2">
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Tabulated displays: 2D</span>

<span class="org-keyword">def</span> <span class="org-function-name">r2cf_tab</span>(rn: Rational) -&gt; <span class="org-builtin">str</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Show the prpocess of converting a rational numner</span>
<span class="org-doc">    to a continued fraction</span>
<span class="org-doc">    """</span>
    <span class="org-keyword">def</span> <span class="org-function-name">row</span>(st: <span class="org-builtin">str</span>, x: <span class="org-builtin">tuple</span>):
        <span class="org-variable-name">b</span>, <span class="org-variable-name">q</span> = x
        <span class="org-keyword">return</span> st + f<span class="org-string">"{b : &gt; 5}  {q : &lt; 5}\n"</span>
    <span class="org-variable-name">str0</span> = f<span class="org-string">"{rn.a : &gt; 5}\n"</span>
    <span class="org-keyword">return</span> <span class="org-builtin">reduce</span>(row, r2cf_(rn), str0) + f<span class="org-string">"{0 : &gt; 5}\n"</span>
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_convergents1_tab</span>(cf: Iterator[<span class="org-builtin">int</span>]) -&gt; Chart:
    <span class="org-doc">"""</span>
<span class="org-doc">    Show the process of converting a continued fraction</span>
<span class="org-doc">    to a rational number</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">chart</span> = Chart(m = np.identity(2, <span class="org-builtin">int</span>))
    <span class="org-variable-name">chart.include_out</span> = <span class="org-constant">False</span>
    (cf1, cf2) = tee(cf)
    <span class="org-keyword">for</span> (mat, a) <span class="org-keyword">in</span> <span class="org-builtin">zip</span>(cf_convergents1_(cf1), cf2):
        chart.move_left(mat, a)
    <span class="org-keyword">return</span> chart
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">euclid_matrix_tab</span>(m: np.ndarray) -&gt; Chart:
    <span class="org-doc">"""Show the matrix form of the Euclidean algorithm"""</span>
    <span class="org-variable-name">chart</span> = Chart(m = m)
    <span class="org-keyword">for</span> (q, r) <span class="org-keyword">in</span> euclid_matrix_(m):
        chart.move_under(r, q)
    <span class="org-keyword">return</span> chart
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_transform_tab</span>(cf: Iterator[<span class="org-builtin">int</span>], m0 = np.identity(2, <span class="org-builtin">int</span>)) -&gt; Chart:
    <span class="org-doc">"""Show the process of operating on a continued fraction.</span>
<span class="org-doc">    Make sure that cf has finite number of terms</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">chart</span> = Chart(m = m0)
    <span class="org-variable-name">res</span> = cf_transform_(cf, m0)

    <span class="org-keyword">for</span> (q, r, m, a, new_a) <span class="org-keyword">in</span> res:
        <span class="org-keyword">if</span> new_a:
            chart.move_left(m, a)
        <span class="org-keyword">if</span> q <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">this means that no euclid step was performed</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">do nothing</span>
            <span class="org-keyword">pass</span>
        <span class="org-keyword">else</span>:
            <span class="org-keyword">if</span> r <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
                chart.move_under(r, q)
            <span class="org-keyword">else</span>:
                <span class="org-comment-delimiter"># </span><span class="org-comment">r is None; the quotients are for rational numbers</span>
                <span class="org-comment-delimiter"># </span><span class="org-comment">rather than matrices</span>
                <span class="org-variable-name">chart.output</span> = chart.output + [q]
    <span class="org-keyword">return</span> chart
</pre>
</div>
</div>
</div>

<div id="outline-container-orgd4c4962" class="outline-3">
<h3 id="orgd4c4962"><span class="section-number-3">15.3.</span> Tabulated displays: 3D</h3>
<div class="outline-text-3" id="text-15-3">
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Tabulated displays: 3D</span>

<span class="org-keyword">def</span> <span class="org-function-name">arithmetic_convergents_tab</span>(a: Iterator[<span class="org-builtin">int</span>], b: Iterator[<span class="org-builtin">int</span>], t0: np.ndarray = tForAddition) -&gt; Chart:
    <span class="org-doc">"""</span>
<span class="org-doc">    Show the process of calculating the convergents of</span>
<span class="org-doc">    arithmetical operations</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">c</span> = Chart(t0)
    <span class="org-variable-name">c.include_out</span> = <span class="org-constant">False</span>
    <span class="org-keyword">for</span> direction, coefficient, t <span class="org-keyword">in</span> arithmetic_convergents_(a, b, t0):
        <span class="org-keyword">if</span> direction == <span class="org-string">'a'</span>:
            c.move_left(t, coefficient)
        <span class="org-keyword">else</span>:
            c.move_down(t, coefficient)
    <span class="org-keyword">return</span> c
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">euclid_tensor_tab</span>(t):
    <span class="org-variable-name">c</span> = Chart(t)
    <span class="org-variable-name">c.include_a</span> = <span class="org-constant">False</span>
    <span class="org-variable-name">c.include_b</span> = <span class="org-constant">False</span>
    <span class="org-variable-name">res</span> = euclid_tensor_(t)
    <span class="org-keyword">for</span> (q, r) <span class="org-keyword">in</span> res:
        c.move_under(r, q)
    <span class="org-keyword">return</span> c
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_arithmetic_tab</span>(cf_a, cf_b, t0):
    <span class="org-variable-name">chart</span> = Chart(m = t0)
    <span class="org-variable-name">chart.include_a</span> = <span class="org-constant">True</span>
    <span class="org-variable-name">chart.include_b</span> = <span class="org-constant">True</span>
    <span class="org-variable-name">chart.include_out</span> = <span class="org-constant">True</span>
    <span class="org-variable-name">res</span> = cf_arithmetic_(cf_a, cf_b, t0)

    <span class="org-keyword">for</span> (q, r, t, term, label, new_term) <span class="org-keyword">in</span> res:
        <span class="org-keyword">if</span> new_term:
            <span class="org-keyword">if</span> label == <span class="org-string">'a'</span>:
                chart.move_left(t, term)
            <span class="org-keyword">else</span>:
                <span class="org-keyword">assert</span> label == <span class="org-string">'b'</span>
                chart.move_down(t, term)
        <span class="org-keyword">if</span> q <span class="org-keyword">is</span> <span class="org-constant">None</span>:
            <span class="org-comment-delimiter"># </span><span class="org-comment">this means that no Euclidean step was performed</span>
            <span class="org-comment-delimiter"># </span><span class="org-comment">do nothing</span>
            <span class="org-keyword">pass</span>
        <span class="org-keyword">else</span>:
            <span class="org-keyword">if</span> r <span class="org-keyword">is</span> <span class="org-keyword">not</span> <span class="org-constant">None</span>:
                chart.move_under(r, q)
            <span class="org-keyword">else</span>:
                <span class="org-variable-name">chart.output</span> = chart.output + [q]
    <span class="org-keyword">return</span> chart
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb82d23f" class="outline-3">
<h3 id="orgb82d23f"><span class="section-number-3">15.4.</span> Pretty printing utilities</h3>
<div class="outline-text-3" id="text-15-4">
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Pretty printing utilities</span>

<span class="org-keyword">def</span> <span class="org-function-name">pp_qr</span>(qr: Tuple[<span class="org-builtin">int</span>, np.ndarray]) -&gt; <span class="org-constant">None</span>:
    <span class="org-doc">'''Pretty print a tuple of a quotient and a remainder matrix'''</span>
    <span class="org-variable-name">q</span>, <span class="org-variable-name">r</span> = qr
    <span class="org-keyword">print</span>(f<span class="org-string">"{q:&gt;2} {r[0][0]:2} {r[0][1]:2}"</span>)
    <span class="org-keyword">print</span>(f<span class="org-string">"   {r[1][0]:2} {r[1][1]:2}"</span>)
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">pp_inf_cf</span>(cf: <span class="org-builtin">list</span>) -&gt; <span class="org-builtin">str</span>:
    <span class="org-doc">"""</span>
<span class="org-doc">    Pretty print a list representing the first couple terms of</span>
<span class="org-doc">    a longer continued fraction</span>
<span class="org-doc">    """</span>
    <span class="org-variable-name">res</span> = <span class="org-string">"["</span>
    <span class="org-variable-name">res</span> = res + <span class="org-builtin">reduce</span>(<span class="org-keyword">lambda</span> s, n: s + <span class="org-builtin">str</span>(n) + <span class="org-string">","</span>, cf, <span class="org-string">""</span>)
    <span class="org-variable-name">res</span> = res[:-1] + <span class="org-string">"...]"</span>
    <span class="org-keyword">return</span> res
</pre>
</div>
</div>
</div>

<div id="outline-container-org634332e" class="outline-3">
<h3 id="org634332e"><span class="section-number-3">15.5.</span> LaTeX utilities</h3>
<div class="outline-text-3" id="text-15-5">
<div class="org-src-container">
<pre class="src src-python"><span class="org-comment-delimiter"># </span><span class="org-comment">Utilities functions for LaTeX displays</span>

<span class="org-keyword">def</span> <span class="org-function-name">latex_cf</span>(lst: <span class="org-builtin">list</span>) -&gt; <span class="org-builtin">str</span>:
    <span class="org-keyword">if</span> <span class="org-builtin">len</span>(lst) == 1:
        <span class="org-keyword">return</span> <span class="org-builtin">str</span>(lst[0])
    <span class="org-keyword">else</span>:
        <span class="org-variable-name">x</span> = <span class="org-builtin">str</span>(lst[0]) + <span class="org-string">"+"</span>
        <span class="org-variable-name">x</span> = x + r<span class="org-string">"\frac{1}{"</span> + latex_cf(lst[1:]) + <span class="org-string">"}"</span>
        <span class="org-keyword">return</span> x

<span class="org-keyword">def</span> <span class="org-function-name">latex_rational</span>(r: Rational) -&gt; <span class="org-builtin">str</span>:
    <span class="org-keyword">return</span> r<span class="org-string">"\frac{"</span> + <span class="org-builtin">str</span>(r.a) + <span class="org-string">"}{"</span> + <span class="org-builtin">str</span>(r.b) + <span class="org-string">"}"</span>

<span class="org-keyword">def</span> <span class="org-function-name">show_cf_expansion</span>(r: Rational):
    <span class="org-keyword">print</span>(r<span class="org-string">"\["</span>)
    <span class="org-keyword">print</span>(r<span class="org-string">"\frac{"</span>, r.a, <span class="org-string">"}{"</span>, r.b, <span class="org-string">"}="</span>)
    <span class="org-variable-name">nc</span> = <span class="org-builtin">list</span>(r2cf(r))
    <span class="org-keyword">print</span>(latex_cf(nc))
    <span class="org-keyword">print</span>(r<span class="org-string">"\]"</span>)

<span class="org-keyword">def</span> <span class="org-function-name">show_rational_series</span>(itr: Iterator[<span class="org-builtin">int</span>]):
    <span class="org-variable-name">rLst</span> = <span class="org-builtin">list</span>(cf_convergents0(itr))
    <span class="org-variable-name">s</span> = <span class="org-string">""</span>
    <span class="org-keyword">for</span> r <span class="org-keyword">in</span> rLst:
        <span class="org-variable-name">s</span> = s + <span class="org-string">"$"</span> + latex_rational(r) + <span class="org-string">"$"</span> + <span class="org-string">","</span>

    <span class="org-keyword">print</span>(s[:-1])
</pre>
</div>
</div>
</div>
<div id="outline-container-orga55a918" class="outline-3">
<h3 id="orga55a918"><span class="section-number-3">15.6.</span> Imports</h3>
<div class="outline-text-3" id="text-15-6">
<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> cont_frac <span class="org-keyword">import</span> *
<span class="org-keyword">from</span> typing <span class="org-keyword">import</span> List
<span class="org-keyword">from</span> functools <span class="org-keyword">import</span> <span class="org-builtin">reduce</span>
<span class="org-keyword">from</span> itertools <span class="org-keyword">import</span> tee
<span class="org-keyword">import</span> csv
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org38373c7" class="outline-2">
<h2 id="org38373c7"><span class="section-number-2">16.</span> Appendix: Imports and outlines</h2>
<div class="outline-text-2" id="text-16">
<p>
This is the outline of the main code <code>cont_frac.py</code>.
</p>
<div class="org-src-container">
<pre class="src src-python">&lt;&lt;IMPORTS&gt;&gt;
&lt;&lt;RATIONAL_NUM&gt;&gt;
&lt;&lt;R2CF&gt;&gt;
&lt;&lt;CONVERGENTS0&gt;&gt;
&lt;&lt;CONVERGENTS1&gt;&gt;
&lt;&lt;QR_MATRIX&gt;&gt;
&lt;&lt;CF_TRANSFORM&gt;&gt;
&lt;&lt;BIHOMOGRAPHY&gt;&gt;  
&lt;&lt;QR_TENSOR&gt;&gt;
&lt;&lt;ARITHMETIC&gt;&gt;
&lt;&lt;CF_EXAMPLES&gt;&gt;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">def</span> <span class="org-function-name">cf_pi</span>():
    <span class="org-keyword">return</span> <span class="org-builtin">iter</span>([3, 7, 15, 1, 292, 1, 1, 1, 2, 1, 3, 1, 14, 2, 1, 1, 2, 2, 2, 2])
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">import</span> math
<span class="org-keyword">import</span> numpy <span class="org-keyword">as</span> np
<span class="org-keyword">from</span> typing <span class="org-keyword">import</span> NamedTuple, Iterator, Tuple, Optional, Callable, Union, List
</pre>
</div>

<div class="org-src-container">
<pre class="src src-python"><span class="org-keyword">from</span> cont_frac <span class="org-keyword">import</span> *
<span class="org-keyword">from</span> cont_frac_io <span class="org-keyword">import</span> *
<span class="org-keyword">from</span> itertools <span class="org-keyword">import</span> islice
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="author">Author: Hsin-Hao Yu</p>
<p class="date">Created: 2022-05-01 Sun 08:56</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
